"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateMultiSlotAvailability = exports.getScheduleAvailability = exports.queryAvailability = exports.LocationLocationType = exports.SortOrder = exports.LocationType = void 0;
const transform_error_1 = require("@wix/sdk-runtime/transform-error");
const rename_all_nested_keys_1 = require("@wix/sdk-runtime/rename-all-nested-keys");
const ambassadorWixBookingsAvailabilityV1SlotAvailability = __importStar(require("./bookings-availability-v1-slot-availability-availability-calendar.http.js"));
var LocationType;
(function (LocationType) {
    LocationType["UNDEFINED"] = "UNDEFINED";
    LocationType["OWNER_BUSINESS"] = "OWNER_BUSINESS";
    LocationType["OWNER_CUSTOM"] = "OWNER_CUSTOM";
    LocationType["CUSTOM"] = "CUSTOM";
})(LocationType || (exports.LocationType = LocationType = {}));
var SortOrder;
(function (SortOrder) {
    SortOrder["ASC"] = "ASC";
    SortOrder["DESC"] = "DESC";
})(SortOrder || (exports.SortOrder = SortOrder = {}));
var LocationLocationType;
(function (LocationLocationType) {
    LocationLocationType["UNKNOWN_LOCATION_TYPE"] = "UNKNOWN_LOCATION_TYPE";
    /** A business location, either the default business address, or locations defined for the business by the Business Info. */
    LocationLocationType["BUSINESS"] = "BUSINESS";
    /** The location is unique to this service and isn't defined as one of the business locations. */
    LocationLocationType["CUSTOM"] = "CUSTOM";
    /** The location can be determined by the customer and is not set up beforehand. */
    LocationLocationType["CUSTOMER"] = "CUSTOMER";
})(LocationLocationType || (exports.LocationLocationType = LocationLocationType = {}));
/**
 * Retrieves appointment slots or class events that match specified filters.
 *
 * <blockquote>
 *
 * Query Availability doesn't use a query builder, instead it uses
 * [API query language](https://dev.wix.com/docs/sdk/articles/work-with-the-sdk/api-query-language).
 *
 * </blockquote>
 *
 * ## Course limitations
 *
 * Course events can't be retrieved with this method. Follow this
 * *sample flow* ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/bookings/sample-flows#backend-modules_bookings_bookings_book-a-course) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/sample-booking-flows#book-a-course))
 * to check course availability.
 *
 * ## Query filter
 *
 * You must include `serviceId` in your query filter. For performance, also specify
 * both `startDate` and `endDate`. Refer to the
 * *supported filters article* ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/availability-calendar/supported-filters-and-sorting) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/time-slots/availability-calendar/supported-fields-filters-and-sorting))
 * for a complete list of supported filters.
 *
 * ## Limit the number of slots returned per day
 *
 * To limit the maximum number of appointment slots returned for each date,
 * specify `slotsPerDay`. For example,  specifying `{"slotsPerDay": 3}` returns
 * a maximum of 3 appointment slots/class events for each day that's within the query
 * filter's date range.
 *
 * ## Unavailable slots
 *
 * By default, both available and unavailable appointment slots/ class events
 * are returned. To retrieve only available slots/events, specify
 * `{"bookable": true}` in the filter.
 *
 * ## Sorting
 *
 * Slots/events can be sorted only by `startDate`. Unavailable slots/events
 * always appear after available ones.
 *
 * ## Availability calculation
 *
 * Wix Bookings calculates availability differently for appointment-based
 * services and classes.
 *
 * ### Appointment availability
 *
 * An appointment slot is `bookable` if:
 * - The slot's `startDate` is later than or equal to `query.filter.startDate`.
 * - The slot's `endDate` is before or equal to `query.filter.endDate`.
 * - The service's `onlineBooking.enabled` is `true`.
 * - The service's early/late booking policies are either not enabled or the
 *   current time is within the defined limits.
 *
 * ### Class event availability
 *
 * A class event is `bookable` if:
 * - The event's `startDate` is later than or equal to `query.filter.startDate`.
 * - The event's `endDate` is before or equal to `query.filter.endDate`.
 * - The event's `remainingCapacity` is greater than `0`.
 * - The service's `onlineBooking.enabled` is `true`.
 * - The service's early/late booking policies are either not enabled or the
 *   current time is within the defined limits.
 *
 * If you want to restrict returned class events to those with a minimum number
 * of remaining spots, specify `openSpots` in the filter. By default, all class
 * events, even those with no open spot, are returned.
 *
 * ## Daylight Savings Time (DST)
 *
 * Due to DST, some local times may not exist or may occur twice. For example,
 * in Santiago, Chile, on September 7, 2025, 0:05 AM doesn't exist because the
 * clock advances from 0:00 AM to 1:00 AM.
 *
 * *Query Availability* automatically adjusts for these gaps. Non-existent times
 * are moved forward by 1 hour, while existing times remain unchanged. For
 * instance, if you call *Query Availability* with a `startDate` of
 * `2025-09-07T00:00:01.000` and an `endDate` of `2025-09-08T00:00:02.000`, the
 * adjusted query will use `2025-09-07T01:00:01.000` as the new start time.
 * @param query - Query options. Refer to the
 * _supported filters article_
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/availability-calendar/supported-filters-and-sorting) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/time-slots/availability-calendar/supported-fields-filters-and-sorting))
 * for a complete list of supported filters.
 * @public
 * @documentationMaturity preview
 * @requiredField query
 * @requiredField query.filter
 * @param options - Options to use for querying availability.
 * @permissionId BOOKINGS.AVAILABILITY_READ
 * @permissionScope Read Bookings - Public Data
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-PUBLIC
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Read Bookings - Including Participants
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-SENSITIVE
 * @permissionScope Read Bookings - all read permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.READ-BOOKINGS
 * @permissionScope Read Bookings Calendar Availability
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-CALENDAR
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @applicableIdentity VISITOR
 * @fqn com.wixpress.bookings.availability.AvailabilityCalendar.QueryAvailability
 */
async function queryAvailability(query, options) {
    // @ts-ignore
    const { httpClient, sideEffects } = arguments[2];
    const payload = (0, rename_all_nested_keys_1.renameKeysFromSDKRequestToRESTRequest)({
        query: query,
        timezone: options?.timezone,
        slotsPerDay: options?.slotsPerDay,
    });
    const reqOpts = ambassadorWixBookingsAvailabilityV1SlotAvailability.queryAvailability(payload);
    sideEffects?.onSiteCall?.();
    try {
        const result = await httpClient.request(reqOpts);
        sideEffects?.onSuccess?.(result);
        return (0, rename_all_nested_keys_1.renameKeysFromRESTResponseToSDKResponse)(result.data);
    }
    catch (err) {
        const transformedError = (0, transform_error_1.transformError)(err, {
            spreadPathsToArguments: {},
            explicitPathsToArguments: {
                query: '$[0]',
                timezone: '$[1].timezone',
                slotsPerDay: '$[1].slotsPerDay',
            },
            singleArgumentUnchanged: false,
        }, ['query', 'options']);
        sideEffects?.onError?.(err);
        throw transformedError;
    }
}
exports.queryAvailability = queryAvailability;
/**
 * Returns availability for a given schedule ID
 * The availability for a course is calculated by:
 * - Checking for total spots by the schedule's capacity
 * - Checking for open spots by subtracting the current number of participants from the total spots
 * current number of participants is calculated by summing the number of participants of all bookings booked to the schedule
 * @param scheduleId - The schedule ID for which availability is being checked.
 * @public
 * @documentationMaturity preview
 * @requiredField scheduleId
 * @fqn com.wixpress.bookings.availability.AvailabilityCalendar.GetScheduleAvailability
 * @deprecated
 */
async function getScheduleAvailability(scheduleId) {
    // @ts-ignore
    const { httpClient, sideEffects } = arguments[1];
    const payload = (0, rename_all_nested_keys_1.renameKeysFromSDKRequestToRESTRequest)({
        scheduleId: scheduleId,
    });
    const reqOpts = ambassadorWixBookingsAvailabilityV1SlotAvailability.getScheduleAvailability(payload);
    sideEffects?.onSiteCall?.();
    try {
        const result = await httpClient.request(reqOpts);
        sideEffects?.onSuccess?.(result);
        return (0, rename_all_nested_keys_1.renameKeysFromRESTResponseToSDKResponse)(result.data);
    }
    catch (err) {
        const transformedError = (0, transform_error_1.transformError)(err, {
            spreadPathsToArguments: {},
            explicitPathsToArguments: { scheduleId: '$[0]' },
            singleArgumentUnchanged: false,
        }, ['scheduleId']);
        sideEffects?.onError?.(err);
        throw transformedError;
    }
}
exports.getScheduleAvailability = getScheduleAvailability;
/** @public
 * @documentationMaturity preview
 * @permissionId BOOKINGS.AVAILABILITY_READ_MULTI_SLOT
 * @permissionScope Read Bookings - Public Data
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-PUBLIC
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Read Bookings - Including Participants
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-SENSITIVE
 * @permissionScope Read Bookings - all read permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.READ-BOOKINGS
 * @permissionScope Read Bookings Calendar Availability
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-CALENDAR
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @applicableIdentity VISITOR
 * @fqn com.wixpress.bookings.availability.AvailabilityCalendar.CalculateMultiSlotAvailability
 */
async function calculateMultiSlotAvailability(options) {
    // @ts-ignore
    const { httpClient, sideEffects } = arguments[1];
    const payload = (0, rename_all_nested_keys_1.renameKeysFromSDKRequestToRESTRequest)({
        from: options?.from,
        to: options?.to,
        timeZone: options?.timeZone,
        bookable: options?.bookable,
        bookingPolicyViolations: options?.bookingPolicyViolations,
        location: options?.location,
        slots: options?.slots,
        slotsPerDay: options?.slotsPerDay,
        cursorPaging: options?.cursorPaging,
    });
    const reqOpts = ambassadorWixBookingsAvailabilityV1SlotAvailability.calculateMultiSlotAvailability(payload);
    sideEffects?.onSiteCall?.();
    try {
        const result = await httpClient.request(reqOpts);
        sideEffects?.onSuccess?.(result);
        return (0, rename_all_nested_keys_1.renameKeysFromRESTResponseToSDKResponse)(result.data);
    }
    catch (err) {
        const transformedError = (0, transform_error_1.transformError)(err, {
            spreadPathsToArguments: {},
            explicitPathsToArguments: {
                from: '$[0].from',
                to: '$[0].to',
                timeZone: '$[0].timeZone',
                bookable: '$[0].bookable',
                bookingPolicyViolations: '$[0].bookingPolicyViolations',
                location: '$[0].location',
                slots: '$[0].slots',
                slotsPerDay: '$[0].slotsPerDay',
                cursorPaging: '$[0].cursorPaging',
            },
            singleArgumentUnchanged: false,
        }, ['options']);
        sideEffects?.onError?.(err);
        throw transformedError;
    }
}
exports.calculateMultiSlotAvailability = calculateMultiSlotAvailability;
//# sourceMappingURL=bookings-availability-v1-slot-availability-availability-calendar.universal.js.map