interface Follower {
    /**
     * Member ID of the member who performed the action.
     * @format GUID
     */
    memberId?: string;
    /**
     * Member ID of the member being followed or unfollowed.
     * @format GUID
     */
    affectedMemberId?: string;
}
interface InvalidateCache extends InvalidateCacheGetByOneOf {
    /**
     * Invalidate by msId. NOT recommended, as this will invalidate the entire site cache!
     * @format GUID
     */
    metaSiteId?: string;
    /**
     * Invalidate by Site ID. NOT recommended, as this will invalidate the entire site cache!
     * @format GUID
     */
    siteId?: string;
    /** Invalidate by App */
    app?: App;
    /** Invalidate by page id */
    page?: Page;
    /** Invalidate by URI path */
    uri?: URI;
    /** Invalidate by file (for media files such as PDFs) */
    file?: File;
    /**
     * tell us why you're invalidating the cache. You don't need to add your app name
     * @maxLength 256
     */
    reason?: string | null;
    /** Is local DS */
    localDc?: boolean;
    hardPurge?: boolean;
}
/** @oneof */
interface InvalidateCacheGetByOneOf {
    /**
     * Invalidate by msId. NOT recommended, as this will invalidate the entire site cache!
     * @format GUID
     */
    metaSiteId?: string;
    /**
     * Invalidate by Site ID. NOT recommended, as this will invalidate the entire site cache!
     * @format GUID
     */
    siteId?: string;
    /** Invalidate by App */
    app?: App;
    /** Invalidate by page id */
    page?: Page;
    /** Invalidate by URI path */
    uri?: URI;
    /** Invalidate by file (for media files such as PDFs) */
    file?: File;
}
interface App {
    /**
     * The AppDefId
     * @minLength 1
     */
    appDefId?: string;
    /**
     * The instance Id
     * @format GUID
     */
    instanceId?: string;
}
interface Page {
    /**
     * the msid the page is on
     * @format GUID
     */
    metaSiteId?: string;
    /**
     * Invalidate by Page ID
     * @minLength 1
     */
    pageId?: string;
}
interface URI {
    /**
     * the msid the URI is on
     * @format GUID
     */
    metaSiteId?: string;
    /**
     * URI path to invalidate (e.g. page/my/path) - without leading/trailing slashes
     * @minLength 1
     */
    uriPath?: string;
}
interface File {
    /**
     * the msid the file is related to
     * @format GUID
     */
    metaSiteId?: string;
    /**
     * Invalidate by filename (for media files such as PDFs)
     * @minLength 1
     * @maxLength 256
     */
    fileName?: string;
}
interface FollowMemberRequest {
    /**
     * ID of the member to follow.
     * @format GUID
     */
    memberId: string;
}
interface FollowMemberResponse {
}
interface MemberFollowed {
    /** Member who is following the other member. */
    memberConnection?: Follower;
}
interface UnfollowMemberRequest {
    /**
     * ID of the member to unfollow.
     * @format GUID
     */
    memberId: string;
}
interface UnfollowMemberResponse {
}
interface MemberUnfollowed {
    /** Member who is unfollowing the other member. */
    memberConnection?: Follower;
}
interface ListMyMemberFollowingRequest {
    /**
     * Pagination options. For more information, see
     * [Sorting and Paging](https://dev.wix.com/docs/rest/articles/getting-started/sorting-and-paging).
     */
    paging?: CursorPaging;
}
interface CursorPaging {
    /**
     * Number of items to return. See [Sorting and Paging](https://dev.wix.com/docs/rest/articles/getting-started/sorting-and-paging).
     * @min 1
     * @max 100
     */
    limit?: number | null;
    /** Cursor returned from last query response. */
    cursor?: string | null;
}
interface ListMyMemberFollowingResponse {
    /**
     * Retrieved list of members followed by the current member.
     * @format GUID
     */
    memberIds?: string[];
    /** Details on the paged set of results returned. */
    pagingMetadata?: PagingMetadataV2;
}
interface PagingMetadataV2 {
    /** Number of items starting from given cursor. */
    count?: number | null;
    /** Cursors to navigate through the result pages using `next` and `prev`. */
    cursors?: Cursors;
}
interface Cursors {
    /**
     * Cursor string pointing to the next page in the list of results.
     * @maxLength 16000
     */
    next?: string | null;
    /**
     * Cursor pointing to the previous page in the list of results.
     * @maxLength 16000
     */
    prev?: string | null;
}
interface ListMemberFollowingRequest {
    /**
     * ID of the member whose followers to list.
     * @format GUID
     */
    memberId: string;
    /**
     * Pagination options. For more information, see
     * [Sorting and Paging](https://dev.wix.com/docs/rest/articles/getting-started/sorting-and-paging).
     */
    paging?: CursorPaging;
}
interface ListMemberFollowingResponse {
    /**
     * Retrieved list of members who are followed by the given member.
     * @format GUID
     */
    memberIds?: string[];
    /** Details on the paged set of results returned. */
    pagingMetadata?: PagingMetadataV2;
}
interface ListMyMemberFollowersRequest {
    /**
     * Pagination options. For more information, see
     * [Sorting and Paging](https://dev.wix.com/docs/rest/articles/getting-started/sorting-and-paging).
     */
    paging?: CursorPaging;
}
interface ListMyMemberFollowersResponse {
    /**
     * Retrieved list of members who are following the current member.
     * @format GUID
     */
    memberIds?: string[];
    /** Details on the paged set of results returned. */
    pagingMetadata?: PagingMetadataV2;
}
interface ListMemberFollowersRequest {
    /**
     * ID of the member whose followed members to list.
     * @format GUID
     */
    memberId: string;
    /**
     * Pagination options. For more information, see
     * [Sorting and Paging](https://dev.wix.com/docs/rest/articles/getting-started/sorting-and-paging).
     */
    paging?: CursorPaging;
}
interface ListMemberFollowersResponse {
    /**
     * Retrieved list of members who are following the given member.
     * @format GUID
     */
    memberIds?: string[];
    /** Details on the paged set of results returned. */
    pagingMetadata?: PagingMetadataV2;
}
interface QueryMyMemberConnectionsRequest {
    /**
     * List of member IDs whose connections to the current member will be retrieved.
     * @format GUID
     * @maxSize 100
     */
    connectedMemberIds: string[];
}
interface QueryMyMemberConnectionsResponse {
    /** Retrieved list of members whose connections to the current member were retrieved. */
    connectedMembers?: ConnectedMembers[];
}
interface ConnectedMembers {
    /**
     * Site member ID.
     * @format GUID
     */
    connectedMemberId?: string;
    /** Whether the listed member is followed by the given member. */
    followedByMember?: boolean;
    /** Whether the listed member follows the given member. */
    followingMember?: boolean;
}
interface QueryMemberConnectionsRequest {
    /**
     * List of member IDs whose connections to the given member will be retrieved.
     * @format GUID
     * @maxSize 100
     */
    connectedMemberIds: string[];
    /**
     * Member ID.
     * @format GUID
     */
    memberId: string;
}
interface QueryMemberConnectionsResponse {
    /** Retrieved list of members whose connections to the given member were retrieved. */
    connectedMembers?: ConnectedMembers[];
}
interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /**
     * Unique event ID.
     * Allows clients to ignore duplicate webhooks.
     */
    _id?: string;
    /**
     * Assumes actions are also always typed to an entity_type
     * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
     */
    entityFqdn?: string;
    /**
     * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
     * This is although the created/updated/deleted notion is duplication of the oneof types
     * Example: created/updated/deleted/started/completed/email_opened
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number defining the order of updates to the underlying entity.
     * For example, given that some entity was updated at 16:00 and than again at 16:01,
     * it is guaranteed that the sequence number of the second update is strictly higher than the first.
     * As the consumer, you can use this value to ensure that you handle messages in the correct order.
     * To do so, you will need to persist this number on your end, and compare the sequence number from the
     * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
interface EntityCreatedEvent {
    entity?: string;
}
interface RestoreInfo {
    deletedDate?: Date | null;
}
interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntity?: string;
}
interface EntityDeletedEvent {
    /** Entity that was deleted */
    deletedEntity?: string | null;
}
interface ActionEvent {
    body?: string;
}
interface Empty {
}
interface MessageEnvelope {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
interface IdentificationData extends IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityType;
}
/** @oneof */
interface IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
}
declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
interface BaseEventMetadata {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
}
interface EventMetadata extends BaseEventMetadata {
    /**
     * Unique event ID.
     * Allows clients to ignore duplicate webhooks.
     */
    _id?: string;
    /**
     * Assumes actions are also always typed to an entity_type
     * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
     */
    entityFqdn?: string;
    /**
     * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
     * This is although the created/updated/deleted notion is duplication of the oneof types
     * Example: created/updated/deleted/started/completed/email_opened
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number defining the order of updates to the underlying entity.
     * For example, given that some entity was updated at 16:00 and than again at 16:01,
     * it is guaranteed that the sequence number of the second update is strictly higher than the first.
     * As the consumer, you can use this value to ensure that you handle messages in the correct order.
     * To do so, you will need to persist this number on your end, and compare the sequence number from the
     * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
     */
    entityEventSequence?: string | null;
}
interface FollowMemberFollowedEnvelope {
    data: MemberFollowed;
    metadata: EventMetadata;
}
interface FollowMemberUnfollowedEnvelope {
    data: MemberUnfollowed;
    metadata: EventMetadata;
}
interface ListCurrentMemberFollowingOptions {
    /**
     * Pagination options. For more information, see
     * [Sorting and Paging](https://dev.wix.com/docs/rest/articles/getting-started/sorting-and-paging).
     */
    paging?: CursorPaging;
}
interface ListCurrentMemberFollowingResult {
    memberIds: string[];
    metadata: PagingMetadataV2;
}
interface ListMemberFollowingOptions {
    /**
     * Pagination options. For more information, see
     * [Sorting and Paging](https://dev.wix.com/docs/rest/articles/getting-started/sorting-and-paging).
     */
    paging?: CursorPaging;
}
interface ListMemberFollowingResult {
    memberIds: string[];
    metadata: PagingMetadataV2;
}
interface ListCurrentMemberFollowersOptions {
    /**
     * Pagination options. For more information, see
     * [Sorting and Paging](https://dev.wix.com/docs/rest/articles/getting-started/sorting-and-paging).
     */
    paging?: CursorPaging;
}
interface ListCurrentMemberFollowersResult {
    memberIds: string[];
    metadata: PagingMetadataV2;
}
interface ListMemberFollowersOptions {
    /**
     * Pagination options. For more information, see
     * [Sorting and Paging](https://dev.wix.com/docs/rest/articles/getting-started/sorting-and-paging).
     */
    paging?: CursorPaging;
}
interface ListMemberFollowersResult {
    memberIds: string[];
    metadata: PagingMetadataV2;
}

export { type App as A, type ConnectedMembers as B, type CursorPaging as C, type QueryMemberConnectionsRequest as D, type DomainEvent as E, type Follower as F, type DomainEventBodyOneOf as G, type EntityCreatedEvent as H, type InvalidateCache as I, type EntityUpdatedEvent as J, type EntityDeletedEvent as K, type ListCurrentMemberFollowingOptions as L, type MemberFollowed as M, type ActionEvent as N, type Empty as O, type Page as P, type QueryMyMemberConnectionsResponse as Q, type RestoreInfo as R, type MessageEnvelope as S, type IdentificationData as T, type URI as U, type IdentificationDataIdOneOf as V, WebhookIdentityType as W, type BaseEventMetadata as X, type EventMetadata as Y, type FollowMemberFollowedEnvelope as Z, type FollowMemberUnfollowedEnvelope as _, type ListCurrentMemberFollowingResult as a, type ListMemberFollowingOptions as b, type ListMemberFollowingResult as c, type ListCurrentMemberFollowersOptions as d, type ListCurrentMemberFollowersResult as e, type ListMemberFollowersOptions as f, type ListMemberFollowersResult as g, type QueryMemberConnectionsResponse as h, type InvalidateCacheGetByOneOf as i, type File as j, type FollowMemberRequest as k, type FollowMemberResponse as l, type UnfollowMemberRequest as m, type UnfollowMemberResponse as n, type MemberUnfollowed as o, type ListMyMemberFollowingRequest as p, type ListMyMemberFollowingResponse as q, type PagingMetadataV2 as r, type Cursors as s, type ListMemberFollowingRequest as t, type ListMemberFollowingResponse as u, type ListMyMemberFollowersRequest as v, type ListMyMemberFollowersResponse as w, type ListMemberFollowersRequest as x, type ListMemberFollowersResponse as y, type QueryMyMemberConnectionsRequest as z };
