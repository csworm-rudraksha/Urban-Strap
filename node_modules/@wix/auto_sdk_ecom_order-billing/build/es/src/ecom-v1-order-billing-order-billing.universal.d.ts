import { NonNullablePaths } from '@wix/sdk-types';
export interface OrderBilling {
    /**
     * Entity ID.
     * @format GUID
     */
    _id?: string | null;
}
export interface GetOrderRefundabilityRequest {
    /**
     * Order ID.
     * @format GUID
     */
    orderId: string;
}
export interface GetOrderRefundabilityResponse {
    /**
     * Payments and their refundability amounts and statuses.
     * @maxSize 100
     */
    payments?: PaymentRefundability[];
    /** Aggregated payments summary. */
    paymentsSummary?: PaymentsSummary;
    /**
     * List of line item refund quantities.
     * @maxSize 300
     */
    lineItems?: LineItemRefundability[];
    /** Shipping refund amounts - both previously refunded and the amount still available for refund. */
    shipping?: ShippingRefundability;
    /**
     * List of additional fee refund amounts - both previously refunded and the amount still available for refund.
     * @maxSize 100
     */
    additionalFees?: AdditionalFeeRefundability[];
}
export interface PaymentRefundability extends PaymentRefundabilityStatusOneOf {
    /** Whether the payment is available for both automatic and manual refunds. */
    refundable?: boolean;
    /** Reason why the payment is only manually refundable. */
    manuallyRefundable?: ManuallyRefundablePaymentStatus;
    /** Reason why the payment is not refundable. */
    nonRefundable?: NonRefundablePaymentStatus;
    /** Payment details. */
    payment?: PaymentInfo;
    /**
     * URL to the payment provider's dashboard.
     * @format WEB_URL
     */
    providerLink?: string | null;
}
/** @oneof */
export interface PaymentRefundabilityStatusOneOf {
    /** Whether the payment is available for both automatic and manual refunds. */
    refundable?: boolean;
    /** Reason why the payment is only manually refundable. */
    manuallyRefundable?: ManuallyRefundablePaymentStatus;
    /** Reason why the payment is not refundable. */
    nonRefundable?: NonRefundablePaymentStatus;
}
export interface PaymentInfo extends PaymentInfoSummaryOneOf, PaymentInfoPaymentMethodDetailsOneOf {
    /** Monetary payment summary. */
    monetary?: MonetaryPaymentSummary;
    /** Membership payment summary. */
    membership?: MembershipPaymentSummary;
    /** Details of the credit card used for this payment. */
    creditCardDetails?: CreditCardPaymentMethodDetails;
    /**
     * Payment ID.
     * @format GUID
     */
    paymentId?: string;
    /**
     * Payment method. Non-exhaustive list of supported values:
     *
     * `CreditCard`, `Alipay`, `AstropayCash`, `AstropayDBT`, `AstropayMBT`, `Bitcoin`, `BitPay`, `Cash`, `ConvenienceStore`, `EPay`, `Fake`, `Giropay`, `IDeal`, `InPerson`, `Klarna`, `MercadoPago`, `Netpay`, `NordeaSolo`, `Offline`, `PagSeguro`, `PayEasy`, `PayPal`, `Paysafecard`, `Paysafecash`, `PointOfSale`, `Poli`, `Privat24`, `Przelewy24`, `RapidTransfer`, `Sepa`, `Skrill`, `Sofort`, `Trustly`, `Neteller`, `Unionpay`, `UniPay`, `Yandex`
     * @maxLength 50
     */
    paymentMethod?: string | null;
    /** Whether the payment was made offline. For example, when using cash or when marked as paid in the Business Manager. */
    offlinePayment?: boolean;
}
/** @oneof */
export interface PaymentInfoSummaryOneOf {
    /** Monetary payment summary. */
    monetary?: MonetaryPaymentSummary;
    /** Membership payment summary. */
    membership?: MembershipPaymentSummary;
}
/** @oneof */
export interface PaymentInfoPaymentMethodDetailsOneOf {
    /** Details of the credit card used for this payment. */
    creditCardDetails?: CreditCardPaymentMethodDetails;
}
export interface MonetaryPaymentSummary {
    /** Paid amount. */
    paid?: Price;
    /** Refunded amount. */
    refunded?: Price;
    /** Pending refund amount. */
    refundPending?: Price;
    /**
     * Maximum amount to refund,  **if** the refund is available.
     * max_refund = paid - refunded - refund_pending
     * `maxRefund` is calculated as `paid` minus `refunded` minus `refundPending`.
     */
    maxRefund?: Price;
}
export interface Price {
    /**
     * Amount.
     * @decimalValue options { gte:0, lte:1000000000000000 }
     */
    amount?: string;
    /**
     * Amount formatted with currency symbol.
     * @readonly
     */
    formattedAmount?: string;
}
export interface MembershipPaymentSummary {
    /**
     * IDs of line items paid with a membership.
     * @format GUID
     * @maxSize 100
     */
    paidLineItemIds?: string[];
    /**
     * IDs of line items previously refunded, and paid with a membership.
     * @format GUID
     * @maxSize 100
     */
    refundedLineItemIds?: string[];
    /**
     * IDs of line items paid with a membership and available for refund.
     * @format GUID
     * @maxSize 100
     */
    refundableLineItemIds?: string[];
}
export interface CreditCardPaymentMethodDetails {
    /**
     * The last 4 digits of the card number.
     * @maxLength 4
     */
    lastFourDigits?: string | null;
    /**
     * Card issuer's brand.
     * @maxLength 100
     */
    brand?: string | null;
}
export interface ManuallyRefundablePaymentStatus {
    /** Reason why the payment must be manually refunded via the payment provider's dashboard. */
    reason?: ManuallyRefundableReason;
}
export declare enum ManuallyRefundableReason {
    UNKNOWN_REASON = "UNKNOWN_REASON",
    EXPIRED = "EXPIRED",
    NOT_SUPPORTED = "NOT_SUPPORTED",
    OFFLINE = "OFFLINE",
    REQUIRES_CARD_READER = "REQUIRES_CARD_READER"
}
export interface NonRefundablePaymentStatus {
    /** Reason why the payment is not refundable. */
    reason?: NonRefundableReason;
}
export declare enum NonRefundableReason {
    UNKNOWN_REASON = "UNKNOWN_REASON",
    ALREADY_REFUNDED = "ALREADY_REFUNDED",
    PROVIDER_IS_DOWN = "PROVIDER_IS_DOWN",
    NOT_PAID = "NOT_PAID",
    ZERO_PRICE = "ZERO_PRICE",
    DISABLED_BY_PROVIDER = "DISABLED_BY_PROVIDER",
    PENDING_REFUND = "PENDING_REFUND",
    FORBIDDEN = "FORBIDDEN",
    TRANSACTION_NOT_FOUND = "TRANSACTION_NOT_FOUND",
    ORDER_IS_PENDING = "ORDER_IS_PENDING",
    ORDER_IS_REJECTED = "ORDER_IS_REJECTED"
}
export interface PaymentsSummary {
    /** Monetary payments summary. */
    monetary?: MonetaryPaymentSummary;
    /** Membership payments summary. */
    membership?: MembershipPaymentSummary;
}
export interface LineItemRefundability {
    /**
     * Line item ID.
     * @format GUID
     */
    lineItemId?: string;
    /** Original line item quantity before any refunds. */
    originalQuantity?: number;
    /** Previously refunded line item quantity. */
    refundedQuantity?: number;
    /** Line item quantity that is available for refund. */
    availableRefundQuantity?: number;
}
export interface ShippingRefundability {
    /** Original shipping fee amount. */
    amount?: Price;
    /** Previously refunded shipping fee amount. */
    refundedAmount?: Price;
    /** Shipping fee amount available for refund. */
    availableRefundAmount?: Price;
}
export interface AdditionalFeeRefundability {
    /**
     * Additional fee ID.
     * @format GUID
     */
    additionalFeeId?: string;
    /** Original additional fee amount. */
    amount?: Price;
    /** Previously refunded additional fee amount. */
    refundedAmount?: Price;
    /** Additional fee amount available for refund. */
    availableRefundAmount?: Price;
}
export interface CalculateRefundRequest {
    /**
     * Order ID.
     * @format GUID
     */
    orderId: string;
    /** List of line items, shipping and additional fees to be calculated for refund. */
    refundItems?: RefundItems;
}
export interface RefundItems {
    /**
     * Line items and their quantities to refund.
     * @maxSize 300
     */
    lineItems?: LineItemRefund[];
    /**
     * Additional fees and their amounts to refund.
     * @maxSize 100
     */
    additionalFees?: AdditionalFeeRefund[];
    /** Shipping amount to refund. */
    shipping?: ShippingRefund;
}
export interface LineItemRefund {
    /**
     * Line item ID.
     * @format GUID
     */
    lineItemId?: string;
    /**
     * Quantity to refund.
     * @min 1
     * @max 100000
     */
    quantity?: number;
}
export interface AdditionalFeeRefund {
    /**
     * Additional fee ID.
     * @format GUID
     */
    additionalFeeId?: string;
    /**
     * Amount to refund.
     *
     * Passing an empty value will refund the remaining refundable amount.
     */
    amount?: Price;
}
export interface ShippingRefund {
    /**
     * Amount to refund.
     *
     * Passing an empty value will refund the remaining refundable amount.
     */
    amount?: Price;
}
export interface CalculateRefundResponse extends CalculateRefundResponseStatusOneOf {
    /** Whether refund is available for the given list of items. */
    available?: boolean;
    /** If the calculated refund is not available, this field contains error details and amounts for each item. */
    notAvailable?: CalculatedRefundNotAvailableStatus;
    /**
     * Aggregated summary of all items provided for refund.
     *
     * This field is not returned when refund is not available for the given list of items.
     */
    summary?: AggregatedRefundSummary;
    /** Calculated summary of each item provided for refund. */
    calculatedRefundItems?: CalculatedRefundItems;
}
/** @oneof */
export interface CalculateRefundResponseStatusOneOf {
    /** Whether refund is available for the given list of items. */
    available?: boolean;
    /** If the calculated refund is not available, this field contains error details and amounts for each item. */
    notAvailable?: CalculatedRefundNotAvailableStatus;
}
export interface AggregatedRefundSummary {
    /** Total refund amount. */
    total?: Price;
    /** Tax amount for the items being refunded. */
    tax?: Price;
    /** Discount amount for the items being refunded. */
    discount?: Price;
    /** Total cost of the items being refunded (without tax and discount). */
    subtotal?: Price;
    /** Total cost of the line items being refunded (without tax and discount). */
    lineItemsSubtotal?: Price;
    /** Total cost of the additional fees being refunded. */
    additionalFeesTotal?: Price;
}
export interface CalculatedRefundItems {
    /**
     * Calculated refund details for each line item.
     * @maxSize 300
     */
    lineItems?: CalculatedLineItemRefund[];
    /**
     * Calculated refund details for each additional fee.
     * @maxSize 100
     */
    additionalFees?: CalculatedAdditionalFeeRefund[];
    /** Calculated refund details for the shipping fee. */
    shipping?: CalculatedShippingRefund;
}
export interface CalculatedLineItemRefund {
    /** Line item refund details. */
    item?: LineItemRefund;
    /** Calculated refund summary for this line item. */
    summary?: CalculatedRefundSummary;
}
export interface CalculatedRefundSummary {
    /** Total refundable amount. */
    total?: Price;
    /** Tax amount for the items being refunded. */
    tax?: Price;
    /** Discount amount for the items being refunded. */
    discount?: Price;
    /** Total cost of the items being refunded (without tax and discount). */
    subtotal?: Price;
}
export interface CalculatedAdditionalFeeRefund {
    /** Additional fee refund details. */
    additionalFee?: AdditionalFeeRefund;
    /** Calculated refund summary for this additional fee. */
    summary?: CalculatedRefundSummary;
}
export interface CalculatedShippingRefund {
    /** Shipping refund details. */
    shipping?: ShippingRefund;
    /** Calculated refund summary for shipping. */
    summary?: CalculatedRefundSummary;
}
export interface CalculatedRefundNotAvailableStatus {
    /**
     * Refund calculation errors.
     * @maxSize 401
     */
    errors?: CalculationError[];
}
export interface CalculationError extends CalculationErrorItemOneOf {
    /** Line item */
    lineItem?: LineItemRefund;
    /** Additional fee */
    additionalFee?: AdditionalFeeRefund;
    /** Shipping */
    shipping?: ShippingRefund;
    /** Error details */
    error?: Details;
}
/** @oneof */
export interface CalculationErrorItemOneOf {
    /** Line item */
    lineItem?: LineItemRefund;
    /** Additional fee */
    additionalFee?: AdditionalFeeRefund;
    /** Shipping */
    shipping?: ShippingRefund;
}
export interface Details extends DetailsKindOneOf {
    applicationError?: ApplicationError;
    validationError?: ValidationError;
    systemError?: SystemError;
    /**
     * deprecated in API's - to enable migration from rendering arbitrary tracing to rest response
     * @deprecated
     */
    tracing?: Record<string, string>;
}
/** @oneof */
export interface DetailsKindOneOf {
    applicationError?: ApplicationError;
    validationError?: ValidationError;
    systemError?: SystemError;
}
export interface ApplicationError {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
/**
 * example result:
 * {
 * "fieldViolations": [
 * {
 * "field": "fieldA",
 * "description": "invalid music note. supported notes: [do,re,mi,fa,sol,la,ti]",
 * "violatedRule": "OTHER",
 * "ruleName": "INVALID_NOTE",
 * "data": {
 * "value": "FI"
 * }
 * },
 * {
 * "field": "fieldB",
 * "description": "field value out of range. supported range: [0-20]",
 * "violatedRule": "MAX",
 * "data": {
 * "threshold": 20
 * }
 * },
 * {
 * "field": "fieldC",
 * "description": "invalid phone number. provide a valid phone number of size: [7-12], supported characters: [0-9, +, -, (, )]",
 * "violatedRule": "FORMAT",
 * "data": {
 * "type": "PHONE"
 * }
 * }
 * ]
 * }
 */
export interface ValidationError {
    fieldViolations?: FieldViolation[];
}
export declare enum RuleType {
    VALIDATION = "VALIDATION",
    OTHER = "OTHER",
    MAX = "MAX",
    MIN = "MIN",
    MAX_LENGTH = "MAX_LENGTH",
    MIN_LENGTH = "MIN_LENGTH",
    MAX_SIZE = "MAX_SIZE",
    MIN_SIZE = "MIN_SIZE",
    FORMAT = "FORMAT",
    DECIMAL_LTE = "DECIMAL_LTE",
    DECIMAL_GTE = "DECIMAL_GTE",
    DECIMAL_LT = "DECIMAL_LT",
    DECIMAL_GT = "DECIMAL_GT",
    DECIMAL_MAX_SCALE = "DECIMAL_MAX_SCALE",
    INVALID_ENUM_VALUE = "INVALID_ENUM_VALUE",
    REQUIRED_FIELD = "REQUIRED_FIELD",
    FIELD_NOT_ALLOWED = "FIELD_NOT_ALLOWED",
    ONE_OF_ALIGNMENT = "ONE_OF_ALIGNMENT",
    EXACT_LENGTH = "EXACT_LENGTH",
    EXACT_SIZE = "EXACT_SIZE",
    REQUIRED_ONE_OF_FIELD = "REQUIRED_ONE_OF_FIELD"
}
export interface FieldViolation {
    field?: string;
    description?: string;
    violatedRule?: RuleType;
    /** applicable when violated_rule=OTHER */
    ruleName?: string | null;
    data?: Record<string, any> | null;
}
export interface SystemError {
    /** Error code. */
    errorCode?: string | null;
}
export interface RefundPaymentsRequest {
    /**
     * Order ID.
     * @format GUID
     */
    orderId: string;
    /**
     * List of payments and their amounts to refund.
     * @minSize 1
     * @maxSize 50
     */
    paymentRefunds: PaymentRefund[];
    /** Side effect actions for restocking and notifications. */
    sideEffects?: RefundSideEffects;
    /** List of line items, shipping and additional fees to refund. */
    refundItems?: RefundItems;
    /**
     * Customer-provided reason for the refund.
     * @maxLength 200
     */
    customerReason?: string | null;
}
export interface PaymentRefund {
    /**
     * Specific payment within the order to refund
     * @format GUID
     */
    paymentId?: string;
    /** Refund amount. Not relevant for membership and gift card refunds. */
    amount?: Price;
    /**
     * Indicates that refund is made externally and manually (on the payment provider's side)
     * When false (default), the payment gateway will be called in order to make an actual refund, and then the payment will be marked as refunded.
     * When true, the payment will only be *marked* as refunded, and no actual refund will be performed.
     */
    externalRefund?: boolean;
}
export interface RefundSideEffects {
    /** Restocking side effects. */
    restock?: RestockSideEffects;
    /** Notification side effects. */
    notifications?: NotificationSideEffects;
}
export interface RestockItem {
    /**
     * Line item ID.
     * @format GUID
     */
    lineItemId?: string;
    /**
     * Quantity to restock.
     * @min 1
     * @max 100000
     */
    quantity?: number;
}
export interface RestockSideEffects {
    /**
     * List of items to restock.
     * @maxSize 300
     */
    lineItems?: RestockItem[];
}
export interface NotificationSideEffects {
    /**
     * Whether to send a refund confirmation email to the customer.
     *
     * Default: `false`
     */
    sendCustomerEmail?: boolean;
    /**
     * Custom message added to the refund confirmation email.
     * @minLength 1
     * @maxLength 1000
     */
    customMessage?: string | null;
}
export interface RefundPaymentsResponse {
    /** Refund details. */
    refund?: Refund;
    /** The order's transactions records after the refunds were performed. */
    orderTransactions?: OrderTransactions;
}
export interface Refund {
    /**
     * Refund ID.
     * @format GUID
     * @readonly
     */
    _id?: string;
    /**
     * List of transactions.
     * @maxSize 50
     */
    transactions?: RefundTransaction[];
    /** Refund business details. */
    details?: RefundDetails;
    /**
     * Date and time the refund was created in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. Defaults to current time when not provided.
     * @readonly
     * @immutable
     */
    _createdDate?: Date | null;
    /**
     * Aggregated refund summary.
     * @readonly
     */
    summary?: V1AggregatedRefundSummary;
    /**
     * ID of the app that initiated this refund.
     * @format GUID
     * @readonly
     * @immutable
     */
    requestingServiceAppId?: string | null;
}
export interface RefundTransaction {
    /**
     * ID of the payment associated with this refund.
     * @format GUID
     * @immutable
     */
    paymentId?: string;
    /**
     * Refund amount.
     * @immutable
     */
    amount?: Price;
    /** Refund status. */
    refundStatus?: RefundStatus;
    /** Optional details of current refund status. */
    refundStatusInfo?: RefundStatusInfo;
    /**
     * Payment gateway's refund ID.
     * This field is only returned when the value of `external_refund` is `false`.
     * @format GUID
     */
    gatewayRefundId?: string | null;
    /** ID of the refund in the payment provider's system. For example, at PayPal, Square, Stripe, etc. Not returned for external refunds. */
    providerRefundId?: string | null;
    /**
     * Whether refund was made externally and manually on the payment provider's side.
     * @immutable
     */
    externalRefund?: boolean;
}
/** Refund transaction status. */
export declare enum RefundStatus {
    /** Refund was initiated on payment provider side. PENDING status was assigned by provider. */
    PENDING = "PENDING",
    /** Refund transaction succeeded. */
    SUCCEEDED = "SUCCEEDED",
    /** Refund transaction failed. */
    FAILED = "FAILED",
    /** Refund request acknowledged, and will be executed soon. */
    SCHEDULED = "SCHEDULED",
    /** Refund was initiated on payment provider side. */
    STARTED = "STARTED"
}
export interface RefundStatusInfo {
    /**
     * Reason code for the refund's current status.
     *
     * Learn more about [reason codes](https://dev.wix.com/docs/rest/business-management/payments/service-plugins/payment-service-provider-service-plugin/reason-codes).
     * @minLength 1
     * @maxLength 10
     */
    paymentGatewayReasonCode?: string | null;
    /**
     * Free text explanation of current refund status.
     * @minLength 1
     * @maxLength 1000
     */
    description?: string | null;
}
/** Business model of a refund request */
export interface RefundDetails {
    /**
     * Order line item IDs and quantities that were refunded.
     * @maxSize 300
     */
    items?: RefundItem[];
    /** Whether the shipping fee was also refunded. */
    shippingIncluded?: boolean;
    /**
     * Reason for the refund, provided by customer (optional).
     * @maxLength 200
     */
    reason?: string | null;
    /**
     * Line items that were refunded.
     * @maxSize 300
     */
    lineItems?: V1LineItemRefund[];
    /**
     * Additional fees that were refunded.
     * @maxSize 100
     */
    additionalFees?: V1AdditionalFeeRefund[];
    /** Shipping amount that was refunded. */
    shipping?: V1ShippingRefund;
}
export interface RefundItem {
    /**
     * Line item ID the refunded line item.
     * @format GUID
     */
    lineItemId?: string;
    /**
     * Line item quantity refunded.
     * @min 1
     * @max 100000
     */
    quantity?: number;
}
export interface V1LineItemRefund {
    /**
     * Line item ID.
     * @format GUID
     * @immutable
     */
    lineItemId?: string;
    /**
     * Refund quantity.
     * @min 1
     * @max 100000
     * @immutable
     */
    quantity?: number;
}
export interface V1AdditionalFeeRefund {
    /**
     * Additional fee ID.
     * @format GUID
     * @immutable
     */
    additionalFeeId?: string;
    /**
     * Refund amount.
     * @immutable
     */
    amount?: Price;
}
export interface V1ShippingRefund {
    /**
     * Refund amount.
     * @immutable
     */
    amount?: Price;
}
export interface V1AggregatedRefundSummary {
    /** Total amount requested for refund. */
    requestedRefund?: Price;
    /** Pending refund amount - the portion of `requestedRefund` that is still pending. */
    pendingRefund?: Price;
    /** Refunded amount - the portion of `requestedRefund` that refunded successfully. */
    refunded?: Price;
    /** Failed refund amount - the portion of `requestedRefund` that failed. */
    failedRefundAmount?: Price;
    /** Whether at least one refund transaction is still in `"PENDING"` status. */
    pending?: boolean;
    /** Breakdown of refunded items. Available only after refund is complete. */
    breakdown?: RefundItemsBreakdown;
}
export interface RefundItemsBreakdown {
    /**
     * Refunded line items and the amount refunded for each.
     * @maxSize 300
     */
    lineItems?: LineItemRefundSummary[];
}
export interface LineItemRefundSummary {
    /**
     * ID of the refunded line item.
     * @format GUID
     */
    lineItemId?: string;
    /** Total refunded amount for the line item. */
    totalRefundedAmount?: Price;
}
export interface OrderTransactions {
    /**
     * Order ID.
     * @format GUID
     */
    orderId?: string;
    /**
     * Record of payments made to the merchant.
     * @maxSize 100
     */
    payments?: Payment[];
    /**
     * Record of refunds made to the buyer.
     * @maxSize 300
     */
    refunds?: Refund[];
}
export interface Payment extends PaymentPaymentDetailsOneOf, PaymentReceiptInfoOneOf {
    /** Regular payment details. */
    regularPaymentDetails?: RegularPaymentDetails;
    /** Gift card payment details. */
    giftcardPaymentDetails?: GiftCardPaymentDetails;
    /**
     * Payment ID.
     * @format GUID
     * @readonly
     */
    _id?: string | null;
    /** Date and time the payment was created in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. Defaults to current time when not provided. */
    _createdDate?: Date | null;
    /**
     * Date and time the payment was last updated in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format.
     * @readonly
     */
    _updatedDate?: Date | null;
    /** Payment amount. */
    amount?: Price;
    /**
     * Whether refunds for this payment are disabled.
     * + `true`: This payment is not refundable.
     * + `false`: This payment may be refunded. However, this ultimately depends on the payment provider.
     */
    refundDisabled?: boolean;
}
/** @oneof */
export interface PaymentPaymentDetailsOneOf {
    /** Regular payment details. */
    regularPaymentDetails?: RegularPaymentDetails;
    /** Gift card payment details. */
    giftcardPaymentDetails?: GiftCardPaymentDetails;
}
/** @oneof */
export interface PaymentReceiptInfoOneOf {
}
export interface RegularPaymentDetails extends RegularPaymentDetailsPaymentMethodDetailsOneOf {
    /** Whether regular card used */
    creditCardDetails?: CreditCardPaymentMethodDetails;
    /**
     * Wix Payments order ID.
     * @maxLength 100
     */
    paymentOrderId?: string | null;
    /**
     * Payment gateway's transaction ID.
     * This field is only returned when the value of `offline_payment` is `false`.
     * @maxLength 100
     */
    gatewayTransactionId?: string | null;
    /**
     * Payment method. Non-exhaustive list of supported values:
     * + `CreditCard`, `Alipay`, `AstropayCash`, `AstropayDBT`, `AstropayMBT`, `Bitcoin`, `BitPay`, `Cash`, `ConvenienceStore`, `EPay`, `Fake`, `Giropay`, `IDeal`, `InPerson`, `Klarna`, `MercadoPago`, `Netpay`, `NordeaSolo`, `Offline`, `PagSeguro`, `PayEasy`, `PayPal`, `Paysafecard`, `Paysafecash`, `PointOfSale`, `Poli`, `Privat24`, `Przelewy24`, `RapidTransfer`, `Sepa`, `Skrill`, `Sofort`, `Trustly`, `Neteller`, `Unionpay`, `UniPay`, `Yandex`
     * @maxLength 100
     */
    paymentMethod?: string | null;
    /**
     * Transaction ID in the payment provider's system. For example, at PayPal, Square, Stripe, etc. Not returned for offline payments.
     * @maxLength 100
     */
    providerTransactionId?: string | null;
    /** Whether the payment was made offline. For example, when using cash or when marked as paid in the Business Manager. */
    offlinePayment?: boolean;
    /** Payment status. */
    status?: TransactionStatus;
    /**
     * Whether there is a payment agreement that allows for future charges.
     * @immutable
     */
    savedPaymentMethod?: boolean;
    /** Authorization details. */
    authorizationDetails?: AuthorizationDetails;
}
/** @oneof */
export interface RegularPaymentDetailsPaymentMethodDetailsOneOf {
    /** Whether regular card used */
    creditCardDetails?: CreditCardPaymentMethodDetails;
}
export declare enum TransactionStatus {
    UNDEFINED = "UNDEFINED",
    APPROVED = "APPROVED",
    PENDING = "PENDING",
    PENDING_MERCHANT = "PENDING_MERCHANT",
    CANCELED = "CANCELED",
    DECLINED = "DECLINED",
    REFUNDED = "REFUNDED",
    PARTIALLY_REFUNDED = "PARTIALLY_REFUNDED",
    AUTHORIZED = "AUTHORIZED",
    VOIDED = "VOIDED"
}
export interface AuthorizationDetails {
    /**
     * Whether the authorized payment is of a delayed capture.
     * @readonly
     */
    delayedCapture?: boolean;
    /** Date and time the payment was authorized in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. */
    authorizedDate?: Date | null;
    /**
     * List of captures associated with payment
     * In case of failed it can be replaced with new one with PENDING or SUCCESS statuses
     * @maxSize 1
     */
    captures?: AuthorizationCapture[];
    /** Void associated with payment */
    void?: AuthorizationVoid;
    /** Scheduled action for this transaction */
    scheduledAction?: V1ScheduledAction;
}
export interface AuthorizationCapture {
    /**
     * Capture ID.
     * @format GUID
     * @readonly
     */
    _id?: string | null;
    /** Status of this capture action */
    status?: AuthorizationCaptureStatus;
    /**
     * Amount of this capture
     * @immutable
     */
    amount?: Price;
    /** Date and time the capture was initiated in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. */
    _createdDate?: Date | null;
    /** In case of status is FAILED may contain failure details */
    failureDetails?: AuthorizationActionFailureDetails;
}
export declare enum AuthorizationCaptureStatus {
    UNKNOWN_STATUS = "UNKNOWN_STATUS",
    /** Capture operation still in progress. */
    PENDING = "PENDING",
    /** Capture operation succeeded. */
    SUCCEEDED = "SUCCEEDED",
    /** Capture operation failed. */
    FAILED = "FAILED"
}
export interface AuthorizationActionFailureDetails {
    /** @maxLength 100 */
    failureCode?: string;
}
export interface AuthorizationVoid {
    /** Status of this void action */
    status?: AuthorizationVoidStatus;
    /** Date and time the void was initiated in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601#Combined_date_and_time_representations) format. */
    voidedDate?: Date | null;
    /** In case of status is FAILED may contain failure details */
    failureDetails?: AuthorizationActionFailureDetails;
    /** Reason of void action */
    reason?: Reason;
}
export declare enum AuthorizationVoidStatus {
    UNKNOWN_STATUS = "UNKNOWN_STATUS",
    /** Void operation still in progress. */
    PENDING = "PENDING",
    /** Void operation succeeded. */
    SUCCEEDED = "SUCCEEDED",
    /** Void operation failed. */
    FAILED = "FAILED"
}
/** Reason the authorization was voided. */
export declare enum Reason {
    UNKNOWN_REASON = "UNKNOWN_REASON",
    /** Authorization was voided by user. */
    MANUAL = "MANUAL",
    /** Authorization passed execution date. */
    SCHEDULED = "SCHEDULED"
}
export interface V1ScheduledAction {
    /** Type of the action. */
    actionType?: ActionType;
    /** The date and time of the action. */
    executionDate?: Date | null;
}
export declare enum ActionType {
    UNKNOWN_ACTION_TYPE = "UNKNOWN_ACTION_TYPE",
    VOID = "VOID",
    CAPTURE = "CAPTURE"
}
export interface GiftCardPaymentDetails {
    /**
     * Gift card payment ID.
     * @minLength 1
     * @maxLength 100
     */
    giftCardPaymentId?: string;
    /**
     * ID of the app that created the gift card.
     * @format GUID
     */
    appId?: string;
    /**
     * Whether the gift card is voided.
     * @readonly
     */
    voided?: boolean;
}
export interface MembershipPaymentDetails {
    /**
     * Membership ID.
     * @minLength 1
     * @maxLength 100
     */
    membershipId?: string;
    /**
     * ID of the line item this membership applies to.
     * @minLength 1
     * @maxLength 100
     */
    lineItemId?: string;
    /** Payment status. */
    status?: MembershipPaymentStatus;
    /** Membership name. */
    name?: MembershipName;
    /**
     * The transaction ID in the membership system. Can be used to void the transaction.
     * @minLength 1
     * @maxLength 100
     */
    externalTransactionId?: string | null;
    /**
     * Whether the membership is voided.
     * @readonly
     */
    voided?: boolean;
    /**
     * ID of the application providing this payment option.
     * @format GUID
     */
    providerAppId?: string;
}
export declare enum MembershipPaymentStatus {
    /** Payment was charged. */
    CHARGED = "CHARGED",
    /** The attempt to charge the payment failed, for example, due to lack of credits. */
    CHARGE_FAILED = "CHARGE_FAILED"
}
export interface MembershipName {
    /**
     * Membership name.
     * @maxLength 100
     */
    original?: string;
    /**
     * Translated membership name. Defaults to `original` when not provided.
     * @maxLength 100
     */
    translated?: string | null;
}
export interface WixReceiptInfo {
    /**
     * Receipt ID
     * @format GUID
     */
    receiptId?: string;
    /**
     * Display number of receipt
     * @minLength 1
     * @maxLength 40
     */
    displayNumber?: string | null;
}
export interface ExternalReceiptInfo {
    /**
     * External receipt ID
     * @maxLength 100
     */
    receiptId?: string | null;
    /**
     * ID of the app providing the receipt
     * @format GUID
     */
    appId?: string | null;
    /**
     * Display number of receipt
     * @minLength 1
     * @maxLength 40
     */
    displayNumber?: string | null;
}
export interface PaymentNotRefundableDetails {
    /**
     * Payment ID.
     * @format GUID
     */
    paymentId?: string;
    /** Reason why payment is not refundable. */
    nonRefundableReason?: NonRefundableReason;
}
export interface AuthorizeChargeWithSavedPaymentMethodRequest {
    /**
     * Order ID.
     *
     * The order must have a saved payment method associated.
     * Pass the order ID to the List Transactions For Single Order method and search the response for a payment with `regularPaymentDetails.savedPaymentMethod: true`.
     * If no saved payment exists, the call will fail.
     * @format GUID
     */
    orderId: string;
    /** Amount to authorize. */
    amount: Price;
    /**
     * Currency code, in [ISO-4217](https://en.wikipedia.org/wiki/ISO_4217#List_of_ISO_4217_currency_codes) format.
     * @format CURRENCY
     */
    currency: string;
    /** Settings for scheduled action to perform automatically. */
    delayedCaptureSettings: DelayedCaptureSettings;
}
export interface DelayedCaptureSettings {
    /** The action to perform on the authorized payment after the specified duration. */
    scheduledAction?: ScheduledAction;
    /**
     * Delay duration before performing the scheduled action.
     * > **Note:** If not set, the payment provider's default period will be used.
     */
    delayDuration?: Duration;
}
export declare enum ScheduledAction {
    UNSPECIFIED = "UNSPECIFIED",
    /** Whether payment will be auto-voided when duration passes. */
    VOID = "VOID",
    /** Whether payment will be auto-captured when duration passes. */
    CAPTURE = "CAPTURE"
}
export interface Duration {
    /**
     * Amount of units. For example, 30 MINUTES, 1 HOURS, 7 DAYS, etc
     * @min 1
     */
    count?: number;
    /** Duration unit: MINUTES, HOURS and DAYS */
    unit?: DurationUnit;
}
export declare enum DurationUnit {
    UNKNOWN_DURATION_UNIT = "UNKNOWN_DURATION_UNIT",
    MINUTES = "MINUTES",
    HOURS = "HOURS",
    DAYS = "DAYS"
}
export interface AuthorizeChargeWithSavedPaymentMethodResponse {
    /** Authorized payment. */
    payment?: Payment;
    /** Order transactions updated with authorized payment. */
    orderTransactions?: OrderTransactions;
}
export interface VoidAuthorizedPaymentsRequest {
    /**
     * Order ID.
     * @format GUID
     */
    orderId: string;
    /**
     * IDs of the authorized payments to void.
     * @minSize 1
     * @maxSize 100
     * @format GUID
     */
    paymentIds: string[];
}
export interface VoidAuthorizedPaymentsResponse {
    /** Order transactions updated with voided payment. */
    orderTransactions?: OrderTransactions;
}
export interface CaptureAuthorizedPaymentsRequest {
    /**
     * Order ID.
     * @format GUID
     */
    orderId: string;
    /**
     * List payment IDs and amounts to capture.
     * @minSize 1
     * @maxSize 100
     */
    payments: PaymentCapture[];
}
export interface PaymentCapture {
    /**
     * ID of the payment to capture.
     * @format GUID
     */
    paymentId?: string;
    /**
     * Capture amount.
     *
     * > **Note:** If not provided, the full authorized amount will be captured.
     */
    amount?: Price;
}
export interface CaptureAuthorizedPaymentsResponse {
    /** Order transactions updated with captured payment. */
    orderTransactions?: OrderTransactions;
}
export interface GenerateReceiptsRequest {
    /**
     * Order ID.
     * @format GUID
     */
    orderId: string;
    /**
     * Payment IDs.
     * @minSize 1
     * @maxSize 1
     * @format GUID
     */
    paymentIds: string[];
}
export interface GenerateReceiptsResponse {
    /** Generated receipts information. */
    receipts?: ReceiptInfo[];
}
export interface ReceiptInfo {
    /**
     * Payment ID.
     * @format GUID
     */
    paymentId?: string;
    /**
     * Receipt ID.
     * @format GUID
     */
    receiptId?: string;
}
export interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /**
     * Unique event ID.
     * Allows clients to ignore duplicate webhooks.
     */
    _id?: string;
    /**
     * Assumes actions are also always typed to an entity_type
     * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
     */
    entityFqdn?: string;
    /**
     * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
     * This is although the created/updated/deleted notion is duplication of the oneof types
     * Example: created/updated/deleted/started/completed/email_opened
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number defining the order of updates to the underlying entity.
     * For example, given that some entity was updated at 16:00 and than again at 16:01,
     * it is guaranteed that the sequence number of the second update is strictly higher than the first.
     * As the consumer, you can use this value to ensure that you handle messages in the correct order.
     * To do so, you will need to persist this number on your end, and compare the sequence number from the
     * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
export interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
export interface EntityCreatedEvent {
    entity?: string;
}
export interface RestoreInfo {
    deletedDate?: Date | null;
}
export interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntity?: string;
}
export interface EntityDeletedEvent {
    /** Entity that was deleted */
    deletedEntity?: string | null;
}
export interface ActionEvent {
    body?: string;
}
export interface Empty {
}
/**
 * Retrieves refund information about an order's payments, line items, shipping, and additional fees.
 *
 * The following information is returned:
 * - Whether a payment is refundable; previously refunded amounts; possible refund amounts for each payment.
 * - Refundable and previously refunded quantities for each line item, as well as shipping and additional fees.
 * @param orderId - Order ID.
 * @public
 * @documentationMaturity preview
 * @requiredField orderId
 * @permissionId ECOM.ORDER_BILLING_GET_ORDER_REFUNDABILITY
 * @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionScope Manage eCommerce - all permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.MANAGE-ECOM
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-STORES.MANAGE-ORDERS
 * @applicableIdentity APP
 * @fqn com.wix.ecom.orders.billing.v1.OrderBillingService.GetOrderRefundability
 */
export declare function getOrderRefundability(orderId: string): Promise<NonNullablePaths<GetOrderRefundabilityResponse, `payments` | `payments.${number}.refundable` | `payments.${number}.manuallyRefundable.reason` | `payments.${number}.nonRefundable.reason` | `payments.${number}.payment.monetary.paid.amount` | `payments.${number}.payment.monetary.paid.formattedAmount` | `payments.${number}.payment.paymentId` | `payments.${number}.payment.offlinePayment` | `paymentsSummary.monetary.paid.amount` | `paymentsSummary.monetary.paid.formattedAmount` | `paymentsSummary.membership.paidLineItemIds` | `paymentsSummary.membership.refundedLineItemIds` | `paymentsSummary.membership.refundableLineItemIds` | `lineItems` | `lineItems.${number}.lineItemId` | `lineItems.${number}.originalQuantity` | `lineItems.${number}.refundedQuantity` | `lineItems.${number}.availableRefundQuantity` | `shipping.amount.amount` | `shipping.amount.formattedAmount` | `additionalFees` | `additionalFees.${number}.additionalFeeId` | `additionalFees.${number}.amount.amount` | `additionalFees.${number}.amount.formattedAmount`>>;
/**
 * Calculates refund amounts for a given list of an order's line items, shipping, and additional fees.
 * @param orderId - Order ID.
 * @public
 * @documentationMaturity preview
 * @requiredField options.refundItems.additionalFees.additionalFeeId
 * @requiredField options.refundItems.lineItems.lineItemId
 * @requiredField options.refundItems.lineItems.quantity
 * @requiredField orderId
 * @permissionId ECOM.ORDER_BILLING_CALCULATE_REFUND
 * @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionScope Manage eCommerce - all permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.MANAGE-ECOM
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-STORES.MANAGE-ORDERS
 * @applicableIdentity APP
 * @fqn com.wix.ecom.orders.billing.v1.OrderBillingService.CalculateRefund
 */
export declare function calculateRefund(orderId: string, options?: NonNullablePaths<CalculateRefundOptions, `refundItems.additionalFees.${number}.additionalFeeId` | `refundItems.lineItems.${number}.lineItemId` | `refundItems.lineItems.${number}.quantity`>): Promise<NonNullablePaths<CalculateRefundResponse, `available` | `notAvailable.errors` | `notAvailable.errors.${number}.lineItem.lineItemId` | `notAvailable.errors.${number}.lineItem.quantity` | `notAvailable.errors.${number}.additionalFee.additionalFeeId` | `notAvailable.errors.${number}.additionalFee.amount.amount` | `notAvailable.errors.${number}.additionalFee.amount.formattedAmount` | `notAvailable.errors.${number}.error.applicationError.code` | `notAvailable.errors.${number}.error.applicationError.description` | `summary.total.amount` | `summary.total.formattedAmount` | `calculatedRefundItems.lineItems` | `calculatedRefundItems.lineItems.${number}.item.lineItemId` | `calculatedRefundItems.lineItems.${number}.item.quantity` | `calculatedRefundItems.lineItems.${number}.summary.total.amount` | `calculatedRefundItems.lineItems.${number}.summary.total.formattedAmount` | `calculatedRefundItems.additionalFees` | `calculatedRefundItems.additionalFees.${number}.additionalFee.additionalFeeId`>>;
export interface CalculateRefundOptions {
    /** List of line items, shipping and additional fees to be calculated for refund. */
    refundItems?: RefundItems;
}
/**
 * Calls relevant payment providers and creates refund transactions for the requested payments.
 *
 * Refunds marked with `paymentRefunds.externalRefund = true` do not call payment providers and
 * only update the order's transactions records.
 * @param orderId - Order ID.
 * @public
 * @documentationMaturity preview
 * @requiredField options.paymentRefunds
 * @requiredField options.paymentRefunds.paymentId
 * @requiredField options.refundItems.additionalFees.additionalFeeId
 * @requiredField options.refundItems.lineItems.lineItemId
 * @requiredField options.refundItems.lineItems.quantity
 * @requiredField options.sideEffects.restock.lineItems.lineItemId
 * @requiredField options.sideEffects.restock.lineItems.quantity
 * @requiredField orderId
 * @permissionId ECOM.ORDER_BILLING_REFUND_PAYMENTS
 * @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionScope Manage eCommerce - all permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.MANAGE-ECOM
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-STORES.MANAGE-ORDERS
 * @applicableIdentity APP
 * @fqn com.wix.ecom.orders.billing.v1.OrderBillingService.RefundPayments
 */
export declare function refundPayments(orderId: string, options?: NonNullablePaths<RefundPaymentsOptions, `paymentRefunds` | `paymentRefunds.${number}.paymentId` | `refundItems.additionalFees.${number}.additionalFeeId` | `refundItems.lineItems.${number}.lineItemId` | `refundItems.lineItems.${number}.quantity` | `sideEffects.restock.lineItems.${number}.lineItemId` | `sideEffects.restock.lineItems.${number}.quantity`>): Promise<NonNullablePaths<RefundPaymentsResponse, `refund._id` | `refund.transactions` | `refund.transactions.${number}.paymentId` | `refund.transactions.${number}.amount.amount` | `refund.transactions.${number}.amount.formattedAmount` | `refund.transactions.${number}.refundStatus` | `refund.transactions.${number}.externalRefund` | `refund.details.items` | `refund.details.items.${number}.lineItemId` | `refund.details.items.${number}.quantity` | `refund.details.shippingIncluded` | `refund.details.lineItems` | `refund.details.lineItems.${number}.lineItemId` | `refund.details.lineItems.${number}.quantity` | `refund.details.additionalFees` | `refund.details.additionalFees.${number}.additionalFeeId` | `refund.summary.pending` | `refund.summary.breakdown.lineItems` | `refund.summary.breakdown.lineItems.${number}.lineItemId` | `orderTransactions.orderId` | `orderTransactions.payments` | `orderTransactions.payments.${number}.regularPaymentDetails.offlinePayment` | `orderTransactions.payments.${number}.regularPaymentDetails.status` | `orderTransactions.payments.${number}.regularPaymentDetails.savedPaymentMethod` | `orderTransactions.payments.${number}.regularPaymentDetails.authorizationDetails.delayedCapture` | `orderTransactions.payments.${number}.regularPaymentDetails.authorizationDetails.void.status` | `orderTransactions.payments.${number}.regularPaymentDetails.authorizationDetails.void.reason` | `orderTransactions.payments.${number}.regularPaymentDetails.authorizationDetails.scheduledAction.actionType` | `orderTransactions.payments.${number}.giftcardPaymentDetails.giftCardPaymentId` | `orderTransactions.payments.${number}.giftcardPaymentDetails.appId` | `orderTransactions.payments.${number}.giftcardPaymentDetails.voided` | `orderTransactions.payments.${number}.refundDisabled` | `orderTransactions.refunds` | `orderTransactions.refunds.${number}._id` | `orderTransactions.refunds.${number}.details.shippingIncluded` | `orderTransactions.refunds.${number}.summary.pending`>>;
export interface RefundPaymentsOptions {
    /**
     * List of payments and their amounts to refund.
     * @minSize 1
     * @maxSize 50
     */
    paymentRefunds: PaymentRefund[];
    /** Side effect actions for restocking and notifications. */
    sideEffects?: RefundSideEffects;
    /** List of line items, shipping and additional fees to refund. */
    refundItems?: RefundItems;
    /**
     * Customer-provided reason for the refund.
     * @maxLength 200
     */
    customerReason?: string | null;
}
/**
 * Authorizes a payment using an order's saved payment method.
 *
 * Use the `delayedCaptureSettings` field to specify whether the payment should also be captured/voided immediately or at a later time.
 * Alternatively, the payment can be manually captured or voided using the Capture Authorized Payments or Void Authorized Payments methods.
 * @param orderId - Order ID.
 *
 * The order must have a saved payment method associated.
 * Pass the order ID to the List Transactions For Single Order method and search the response for a payment with `regularPaymentDetails.savedPaymentMethod: true`.
 * If no saved payment exists, the call will fail.
 * @public
 * @documentationMaturity preview
 * @requiredField options
 * @requiredField options.amount
 * @requiredField options.amount.amount
 * @requiredField options.currency
 * @requiredField options.delayedCaptureSettings
 * @requiredField options.delayedCaptureSettings.scheduledAction
 * @requiredField orderId
 * @permissionId ECOM.ORDER_BILLING_AUTHORIZE_CHARGE_WITH_SAVED_PAYMENT_METHOD
 * @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionScope Manage eCommerce - all permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.MANAGE-ECOM
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-STORES.MANAGE-ORDERS
 * @applicableIdentity APP
 * @fqn com.wix.ecom.orders.billing.v1.OrderBillingService.AuthorizeChargeWithSavedPaymentMethod
 */
export declare function authorizeChargeWithSavedPaymentMethod(orderId: string, options: NonNullablePaths<AuthorizeChargeWithSavedPaymentMethodOptions, `amount` | `amount.amount` | `currency` | `delayedCaptureSettings` | `delayedCaptureSettings.scheduledAction`>): Promise<NonNullablePaths<AuthorizeChargeWithSavedPaymentMethodResponse, `payment.regularPaymentDetails.offlinePayment` | `payment.regularPaymentDetails.status` | `payment.regularPaymentDetails.savedPaymentMethod` | `payment.regularPaymentDetails.authorizationDetails.delayedCapture` | `payment.regularPaymentDetails.authorizationDetails.captures` | `payment.regularPaymentDetails.authorizationDetails.captures.${number}.status` | `payment.regularPaymentDetails.authorizationDetails.captures.${number}.amount.amount` | `payment.regularPaymentDetails.authorizationDetails.captures.${number}.amount.formattedAmount` | `payment.regularPaymentDetails.authorizationDetails.captures.${number}.failureDetails.failureCode` | `payment.regularPaymentDetails.authorizationDetails.void.status` | `payment.regularPaymentDetails.authorizationDetails.void.reason` | `payment.regularPaymentDetails.authorizationDetails.scheduledAction.actionType` | `payment.giftcardPaymentDetails.giftCardPaymentId` | `payment.giftcardPaymentDetails.appId` | `payment.giftcardPaymentDetails.voided` | `payment.refundDisabled` | `orderTransactions.orderId` | `orderTransactions.payments` | `orderTransactions.payments.${number}.regularPaymentDetails.offlinePayment` | `orderTransactions.payments.${number}.regularPaymentDetails.status` | `orderTransactions.payments.${number}.regularPaymentDetails.savedPaymentMethod` | `orderTransactions.payments.${number}.regularPaymentDetails.authorizationDetails.delayedCapture` | `orderTransactions.payments.${number}.regularPaymentDetails.authorizationDetails.void.status` | `orderTransactions.payments.${number}.regularPaymentDetails.authorizationDetails.void.reason` | `orderTransactions.payments.${number}.regularPaymentDetails.authorizationDetails.scheduledAction.actionType` | `orderTransactions.payments.${number}.giftcardPaymentDetails.giftCardPaymentId` | `orderTransactions.payments.${number}.giftcardPaymentDetails.appId` | `orderTransactions.payments.${number}.giftcardPaymentDetails.voided` | `orderTransactions.payments.${number}.refundDisabled` | `orderTransactions.refunds` | `orderTransactions.refunds.${number}._id` | `orderTransactions.refunds.${number}.details.shippingIncluded` | `orderTransactions.refunds.${number}.summary.pending`>>;
export interface AuthorizeChargeWithSavedPaymentMethodOptions {
    /** Amount to authorize. */
    amount: Price;
    /**
     * Currency code, in [ISO-4217](https://en.wikipedia.org/wiki/ISO_4217#List_of_ISO_4217_currency_codes) format.
     * @format CURRENCY
     */
    currency: string;
    /** Settings for scheduled action to perform automatically. */
    delayedCaptureSettings: DelayedCaptureSettings;
}
/**
 * Voids an order's authorized payments.
 * @param orderId - Order ID.
 * @public
 * @documentationMaturity preview
 * @requiredField options
 * @requiredField options.paymentIds
 * @requiredField orderId
 * @permissionId ECOM.ORDER_BILLING_VOID_AUTHORIZED_PAYMENTS
 * @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionScope Manage eCommerce - all permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.MANAGE-ECOM
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-STORES.MANAGE-ORDERS
 * @applicableIdentity APP
 * @fqn com.wix.ecom.orders.billing.v1.OrderBillingService.VoidAuthorizedPayments
 */
export declare function voidAuthorizedPayments(orderId: string, options: NonNullablePaths<VoidAuthorizedPaymentsOptions, `paymentIds`>): Promise<NonNullablePaths<VoidAuthorizedPaymentsResponse, `orderTransactions.orderId` | `orderTransactions.payments` | `orderTransactions.payments.${number}.regularPaymentDetails.offlinePayment` | `orderTransactions.payments.${number}.regularPaymentDetails.status` | `orderTransactions.payments.${number}.regularPaymentDetails.savedPaymentMethod` | `orderTransactions.payments.${number}.regularPaymentDetails.authorizationDetails.delayedCapture` | `orderTransactions.payments.${number}.regularPaymentDetails.authorizationDetails.void.status` | `orderTransactions.payments.${number}.regularPaymentDetails.authorizationDetails.void.reason` | `orderTransactions.payments.${number}.regularPaymentDetails.authorizationDetails.scheduledAction.actionType` | `orderTransactions.payments.${number}.giftcardPaymentDetails.giftCardPaymentId` | `orderTransactions.payments.${number}.giftcardPaymentDetails.appId` | `orderTransactions.payments.${number}.giftcardPaymentDetails.voided` | `orderTransactions.payments.${number}.refundDisabled` | `orderTransactions.refunds` | `orderTransactions.refunds.${number}._id` | `orderTransactions.refunds.${number}.details.shippingIncluded` | `orderTransactions.refunds.${number}.summary.pending`>>;
export interface VoidAuthorizedPaymentsOptions {
    /**
     * IDs of the authorized payments to void.
     * @minSize 1
     * @maxSize 100
     * @format GUID
     */
    paymentIds: string[];
}
/**
 * Captures an order's authorized payments.
 * @param orderId - Order ID.
 * @public
 * @documentationMaturity preview
 * @requiredField options
 * @requiredField options.payments
 * @requiredField options.payments.paymentId
 * @requiredField orderId
 * @permissionId ECOM.ORDER_BILLING_CAPTURE_AUTHORIZED_PAYMENTS
 * @permissionScope Manage Stores - all permissions
 * @permissionScopeId SCOPE.DC-STORES-MEGA.MANAGE-STORES
 * @permissionScope Manage Restaurants - all permissions
 * @permissionScopeId SCOPE.RESTAURANTS.MEGA-SCOPES
 * @permissionScope Manage eCommerce - all permissions
 * @permissionScopeId SCOPE.DC-ECOM-MEGA.MANAGE-ECOM
 * @permissionScope Manage Orders
 * @permissionScopeId SCOPE.DC-STORES.MANAGE-ORDERS
 * @applicableIdentity APP
 * @fqn com.wix.ecom.orders.billing.v1.OrderBillingService.CaptureAuthorizedPayments
 */
export declare function captureAuthorizedPayments(orderId: string, options: NonNullablePaths<CaptureAuthorizedPaymentsOptions, `payments` | `payments.${number}.paymentId`>): Promise<NonNullablePaths<CaptureAuthorizedPaymentsResponse, `orderTransactions.orderId` | `orderTransactions.payments` | `orderTransactions.payments.${number}.regularPaymentDetails.offlinePayment` | `orderTransactions.payments.${number}.regularPaymentDetails.status` | `orderTransactions.payments.${number}.regularPaymentDetails.savedPaymentMethod` | `orderTransactions.payments.${number}.regularPaymentDetails.authorizationDetails.delayedCapture` | `orderTransactions.payments.${number}.regularPaymentDetails.authorizationDetails.void.status` | `orderTransactions.payments.${number}.regularPaymentDetails.authorizationDetails.void.reason` | `orderTransactions.payments.${number}.regularPaymentDetails.authorizationDetails.scheduledAction.actionType` | `orderTransactions.payments.${number}.giftcardPaymentDetails.giftCardPaymentId` | `orderTransactions.payments.${number}.giftcardPaymentDetails.appId` | `orderTransactions.payments.${number}.giftcardPaymentDetails.voided` | `orderTransactions.payments.${number}.refundDisabled` | `orderTransactions.refunds` | `orderTransactions.refunds.${number}._id` | `orderTransactions.refunds.${number}.details.shippingIncluded` | `orderTransactions.refunds.${number}.summary.pending`>>;
export interface CaptureAuthorizedPaymentsOptions {
    /**
     * List payment IDs and amounts to capture.
     * @minSize 1
     * @maxSize 100
     */
    payments: PaymentCapture[];
}
export interface GenerateReceiptsOptions {
    /**
     * Payment IDs.
     * @minSize 1
     * @maxSize 1
     * @format GUID
     */
    paymentIds: string[];
}
