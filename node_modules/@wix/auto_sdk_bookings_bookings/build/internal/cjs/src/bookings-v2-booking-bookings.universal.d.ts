/** An entity representing a scheduled appointment, class session, or course. */
export interface Booking extends BookingParticipantsInfoOneOf {
    /**
     * Total number of participants. Available only when the relevant service
     * doesn't have _variants and options_
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/service-options-and-variants/introduction) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/service-options-and-variants/introduction)).
     * @min 1
     */
    totalParticipants?: number;
    /**
     * Information about the booked service choices and participants.
     * Available only when the booking includes multiple _service variants_
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/service-options-and-variants/introduction) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/service-options-and-variants/introduction)).
     */
    participantsChoices?: ParticipantChoices;
    /**
     * Booking ID.
     * @format GUID
     * @readonly
     */
    _id?: string | null;
    /**
     * An object describing the *slot*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/availability-calendar/query-availability) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/bookings-and-time-slots/time-slots/availability-calendar/query-availability))
     * or *schedule*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/calendar/schedules/introduction) | [REST](https://dev.wix.com/docs/rest/business-management/calendar/schedules-v3/introduction))
     * that was booked.
     */
    bookedEntity?: BookedEntity;
    /**
     * Contact details of the site visitor or *member*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/members/members/introduction) | [REST](https://dev.wix.com/docs/rest/crm/members-contacts/members/members/introduction))
     * making the booking.
     */
    contactDetails?: ContactDetails;
    /** Additional custom fields submitted with the booking form. */
    additionalFields?: CustomFormField[];
    /**
     * Booking status. A booking is automatically confirmed if the service allows it
     * and an eCommerce order is created. It is automatically declined if there is a
     * double booking and the customer hasn't paid or is eligible for an automatic
     * refund. Currently, only payments with pricing plans are automatically refundable.
     */
    status?: BookingStatus;
    /**
     * The payment status of the booking corresponds to the `paymentStatus` of the
     * related *eCommerce order*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/ecom/orders/setup)| [REST](https://dev.wix.com/docs/rest/business-solutions/e-commerce/orders/introduction)),
     * if one exists. All payment statuses are supported for every booking `status`.
     */
    paymentStatus?: PaymentStatus;
    /**
     * Payment option selected by the customer. If the customer hasn't completed their
     * checkout, they may still change the payment method. Must be one of the payment
     * options offered by the service ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/services/setup) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/services-v2/introduction)),
     * unless `skipSelectedPaymentOptionValidation` is `true`.
     * When undefined during an *eCommerce checkout*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/ecom/checkout/setup) | [REST](https://dev.wix.com/docs/rest/business-solutions/e-commerce/checkout/introduction)),
     * Wix Bookings uses the service's default payment option
     */
    selectedPaymentOption?: SelectedPaymentOption;
    /**
     * Date and time the booking was created in `YYYY-MM-DDThh:mm:ss.sssZ` format.
     * @readonly
     */
    _createdDate?: Date | null;
    /** External user ID that you can provide. */
    externalUserId?: string | null;
    /**
     * Revision number to be used when updating, rescheduling, or cancelling the
     * booking. Increments by 1 each time the booking is updated, rescheduled, or
     * canceled. To prevent conflicting changes, the current revision must be
     * specified when updating the booking.
     */
    revision?: string | null;
    /**
     * ID of the creator of the booking.
     * If `appId` and another ID are present, the other ID takes precedence.
     * @readonly
     */
    createdBy?: CommonIdentificationData;
    /**
     * The start date of the booking in `YYYY-MM-DDThh:mm:ss.sssZ` format.
     * For a slot, this is the start date of the slot. For a schedule, this is the start date of the first session.
     * @readonly
     */
    startDate?: Date | null;
    /**
     * The end date of the booking in `YYYY-MM-DDThh:mm:ss.sssZ` format.
     * For a slot, this is the end date of the slot. For a schedule, this is the end date of the last session.
     * @readonly
     */
    endDate?: Date | null;
    /**
     * Date and time the booking was updated in `YYYY-MM-DDThh:mm:ss.sssZ` format.
     * @readonly
     */
    _updatedDate?: Date | null;
    /**
     * Custom field data for this object.
     * Extended fields must be configured in the app dashboard before they can be accessed with API calls.
     */
    extendedFields?: ExtendedFields;
    /**
     * Whether this booking overlaps with another confirmed booking. Returned
     * only if set to `true`.
     * @readonly
     */
    doubleBooked?: boolean | null;
}
/** @oneof */
export interface BookingParticipantsInfoOneOf {
    /**
     * Total number of participants. Available only when the relevant service
     * doesn't have _variants and options_
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/service-options-and-variants/introduction) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/service-options-and-variants/introduction)).
     * @min 1
     */
    totalParticipants?: number;
    /**
     * Information about the booked service choices and participants.
     * Available only when the booking includes multiple _service variants_
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/service-options-and-variants/introduction) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/service-options-and-variants/introduction)).
     */
    participantsChoices?: ParticipantChoices;
}
/**
 * A multi-service booking is considered available if all individual bookings are available as returned from List Multi Service Availability Time Slots.
 * Currently, `SEPARATE_BOOKINGS` and `PARALLEL_BOOKINGS` are not supported.
 * Multi-service booking is available if each of its bookings is available separately.
 * For `SEQUENTIAL_BOOKINGS`, see `List Multi Service Availability Time Slots` documentation.
 */
export declare enum MultiServiceBookingType {
    SEQUENTIAL_BOOKINGS = "SEQUENTIAL_BOOKINGS",
    SEPARATE_BOOKINGS = "SEPARATE_BOOKINGS",
    PARALLEL_BOOKINGS = "PARALLEL_BOOKINGS"
}
export interface BookedEntity extends BookedEntityItemOneOf {
    /**
     * Booked *slot*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/availability-calendar/query-availability) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/bookings-and-time-slots/time-slots/availability-calendar/query-availability)).
     * Available only for appointment-based services and classes.
     * For appointment-based services, a new session is created, while for classes,
     * the booking is automatically linked to the existing session.
     */
    slot?: BookedSlot;
    /**
     * Booked *schedule*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/calendar/schedules/introduction) | [REST](https://dev.wix.com/docs/rest/business-management/calendar/schedules-v3/introduction)).
     * Available only for course bookings.
     */
    schedule?: BookedSchedule;
    /**
     * Session title at the time of booking. If there is no pre-existing session,
     * for example for appointment-based services, `title` is set to the service name.
     * @readonly
     * @maxLength 6000
     */
    title?: string | null;
    /**
     * List of tags for the booking.
     *
     * - "INDIVIDUAL": For bookings of appointment-based services. Including when the appointment is for a group of participants.
     * - "GROUP": For bookings of individual class sessions.
     * - "COURSE": For course bookings.
     */
    tags?: string[] | null;
}
/** @oneof */
export interface BookedEntityItemOneOf {
    /**
     * Booked *slot*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/availability-calendar/query-availability) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/bookings-and-time-slots/time-slots/availability-calendar/query-availability)).
     * Available only for appointment-based services and classes.
     * For appointment-based services, a new session is created, while for classes,
     * the booking is automatically linked to the existing session.
     */
    slot?: BookedSlot;
    /**
     * Booked *schedule*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/calendar/schedules/introduction) | [REST](https://dev.wix.com/docs/rest/business-management/calendar/schedules-v3/introduction)).
     * Available only for course bookings.
     */
    schedule?: BookedSchedule;
}
export interface BookedSlot {
    /** Session ID. */
    sessionId?: string | null;
    /** Service ID. */
    serviceId?: string;
    /** Schedule ID. */
    scheduleId?: string;
    /**
     * ID of the corresponding *event*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/calendar/events/introduction) | [REST](https://dev.wix.com/docs/rest/business-management/calendar/events-v3/introduction)).
     * Available for both appointment and class bookings, not available for course bookings.
     * For appointment-based services, Wix Bookings automatically populates `eventId`
     * when the booking `status` changes to `CONFIRMED`. For class bookings, it's
     * automatically populated upon booking creation.
     * @minLength 36
     * @maxLength 250
     */
    eventId?: string | null;
    /**
     * The start time of this slot in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339)
     * format.
     */
    startDate?: string | null;
    /**
     * The end time of this slot in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339)
     * format.
     */
    endDate?: string | null;
    /** The timezone according to which the slot was shown to the user when booking, and should be shown in the future. */
    timezone?: string | null;
    /**
     * Primary *resource*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/resources/introduction) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/resources/resources-v2/introduction))
     * for the booking. For example, the *staff member*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/staff-members/introduction) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/staff-members/introduction))
     * providing the
     * service.
     */
    resource?: BookedResource;
    /** Location where the session takes place. */
    location?: Location;
}
export interface BookedResource {
    /**
     * ID of the booking's primary resource.
     * @format GUID
     */
    _id?: string;
    /**
     * Resource's name at the time of booking.
     * @maxLength 40
     */
    name?: string | null;
    /**
     * Resource's email at the time of booking.
     * @maxLength 500
     */
    email?: string | null;
    /**
     * ID of the schedule belonging to the booking's primary resource.
     * @format GUID
     */
    scheduleId?: string | null;
}
export interface Location {
    /**
     * Business location ID. Available only for locations that are business locations,
     * meaning the `location_type` is `"OWNER_BUSINESS"`.
     * @format GUID
     */
    _id?: string | null;
    /** Location name. */
    name?: string | null;
    /** The full address of this location. */
    formattedAddress?: string | null;
    /**
     * The full translated address of this location.
     * @maxLength 512
     */
    formattedAddressTranslated?: string | null;
    /**
     * Location type.
     *
     * - `"OWNER_BUSINESS"`: The business address, as set in the siteâ€™s general settings.
     * - `"OWNER_CUSTOM"`: The address as set when creating the service.
     * - `"CUSTOM"`: The address as set for the individual session.
     */
    locationType?: LocationType;
}
export declare enum LocationType {
    UNDEFINED = "UNDEFINED",
    OWNER_BUSINESS = "OWNER_BUSINESS",
    OWNER_CUSTOM = "OWNER_CUSTOM",
    CUSTOM = "CUSTOM"
}
export interface BookedSchedule {
    /**
     * _Schedule ID_
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/calendar/schedules/introduction) | [REST](https://dev.wix.com/docs/rest/business-management/calendar/schedules-v3/introduction)).
     */
    scheduleId?: string;
    /**
     * Booked service ID.
     * @format GUID
     */
    serviceId?: string | null;
    /**
     * _Location_
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/business-tools/locations/introduction) | [REST](https://dev.wix.com/docs/rest/business-management/locations/introduction))
     * where the schedule's sessions take place.
     * @readonly
     */
    location?: Location;
    /**
     * Timezone in which the slot or session was shown to the customer when they booked.
     * Also used whenever the customer reviews the booking's timing in the future.
     */
    timezone?: string | null;
    /**
     * Start time of the first session related to the booking in
     * [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339) format.
     * @readonly
     */
    firstSessionStart?: string | null;
    /**
     * End time of the last session related to the booking in
     * [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339) format.
     * @readonly
     */
    lastSessionEnd?: string | null;
}
export interface ContactDetails {
    /**
     * Contact ID.
     * @format GUID
     */
    contactId?: string | null;
    /**
     * Contact's first name. When populated from a standard booking form, this
     * property corresponds to the `name` field.
     */
    firstName?: string | null;
    /** Contact's last name. */
    lastName?: string | null;
    /**
     * Contact's email. If no [contact](https://dev.wix.com/docs/rest/crm/members-contacts/contacts/contacts/contact-v4/contact-object)
     * with this email exist, a new contact is created.
     * Used to validate coupon usage limitations per contact. If not specified,
     * the coupon usage limitation will not be enforced. (Coupon usage limitation
     * validation is not supported yet).
     * @format EMAIL
     */
    email?: string | null;
    /** Contact's phone number. */
    phone?: string | null;
    /** Contact's full address. */
    fullAddress?: Address;
    /**
     * Contact's time zone.
     * @deprecated
     */
    timeZone?: string | null;
    /**
     * Contact's country in [ISO 3166-1 alpha-2 code](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2)
     * format.
     * @format COUNTRY
     */
    countryCode?: string | null;
}
/** Physical address */
export interface Address extends AddressStreetOneOf {
    /** Street name, number and apartment number. */
    streetAddress?: StreetAddress;
    /** Main address line, usually street and number, as free text. */
    addressLine?: string | null;
    /**
     * Country code.
     * @format COUNTRY
     */
    country?: string | null;
    /** Subdivision. Usually state, region, prefecture or province code, according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). */
    subdivision?: string | null;
    /** City name. */
    city?: string | null;
    /** Zip/postal code. */
    postalCode?: string | null;
    /** Free text providing more detailed address info. Usually contains Apt, Suite, and Floor. */
    addressLine2?: string | null;
    /** A string containing the full address of this location. */
    formattedAddress?: string | null;
    /** Free text to help find the address. */
    hint?: string | null;
    /** Coordinates of the physical address. */
    geocode?: AddressLocation;
    /** Country full name. */
    countryFullname?: string | null;
    /** Multi-level subdivisions from top to bottom. */
    subdivisions?: Subdivision[];
}
/** @oneof */
export interface AddressStreetOneOf {
    /** Street name, number and apartment number. */
    streetAddress?: StreetAddress;
    /** Main address line, usually street and number, as free text. */
    addressLine?: string | null;
}
export interface StreetAddress {
    /** Street number. */
    number?: string;
    /** Street name. */
    name?: string;
    /** Apartment number. */
    apt?: string;
}
export interface AddressLocation {
    /** Address latitude. */
    latitude?: number | null;
    /** Address longitude. */
    longitude?: number | null;
}
export interface Subdivision {
    /** Subdivision code. Usually state, region, prefecture or province code, according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). */
    code?: string;
    /** Subdivision full name. */
    name?: string;
}
export interface CustomFormField {
    /**
     * ID of the form field as defined in the form.
     * @format GUID
     */
    _id?: string;
    /** Value that was submitted for this field. */
    value?: string | null;
    /**
     * Form field's label at the time of submission.
     * @readonly
     */
    label?: string | null;
    valueType?: ValueType;
}
export declare enum ValueType {
    /** Short text. This is the default value type. */
    SHORT_TEXT = "SHORT_TEXT",
    /** Long text. */
    LONG_TEXT = "LONG_TEXT",
    /** A text that represents the check box value. If selected the value is `true`, otherwise `false`. */
    CHECK_BOX = "CHECK_BOX"
}
/** Booking status. */
export declare enum BookingStatus {
    /**
     * The booking was created, but the customer hasn't completed the related
     * eCommerce order yet.
     */
    CREATED = "CREATED",
    /**
     * The merchant has confirmed the booking and it appears in the
     * business calendar. Merchants can set up their *services*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/services/setup) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/services-v2/introduction))
     * to automatically confirm all `PENDING` bookings.
     */
    CONFIRMED = "CONFIRMED",
    /**
     * The customer has canceled the booking. Depending on the relevant service's
     * _policy snapshot_
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/booking-policy-snapshots/introduction) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/policies/booking-policy-snapshots/introduction))
     * they may have to pay a _cancellation fee_
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/booking-fees/introduction) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/pricing/booking-fees/introduction)).
     */
    CANCELED = "CANCELED",
    /**
     * The merchant must manually confirm the booking before it appears
     * in the business calendar.
     */
    PENDING = "PENDING",
    /** The merchant has declined the booking before the customer was charged. */
    DECLINED = "DECLINED",
    /**
     * The booking is on a waitlist.
     * Currently, you can't call Register to Waitlist
     * ([REST](https://dev.wix.com/docs/rest/business-solutions/bookings/bookings/waitlist/register-to-waitlist))
     * for course or appointment bookings, even though this is supported in live sites.
     * You can call Register to Waitlist only for class session bookings.
     */
    WAITING_LIST = "WAITING_LIST"
}
/**
 * Payment status.
 * Automatically updated when using eCommerce checkout APIs.
 */
export declare enum PaymentStatus {
    /** Undefined payment status. */
    UNDEFINED = "UNDEFINED",
    /** The booking isn't paid. */
    NOT_PAID = "NOT_PAID",
    /** The booking is fully paid. */
    PAID = "PAID",
    /** The booking is partially paid. */
    PARTIALLY_PAID = "PARTIALLY_PAID",
    /** The booking is refunded. */
    REFUNDED = "REFUNDED",
    /** The booking is free of charge. */
    EXEMPT = "EXEMPT"
}
/**
 * Selected payment option.
 *
 * One of the payment options offered by the service.
 * This field is set when the user selects an option during booking.
 * If left undefined, the payment option is resolved by the service configuration on checkout.
 */
export declare enum SelectedPaymentOption {
    /** Undefined payment option. */
    UNDEFINED = "UNDEFINED",
    /** Offline payment. */
    OFFLINE = "OFFLINE",
    /** Online payment. */
    ONLINE = "ONLINE",
    /** Payment using a Wix Pricing Plan. */
    MEMBERSHIP = "MEMBERSHIP",
    /**
     * Customers can pay only in person with a Wix Pricing Plan, while the Wix user
     * must manually redeem the pricing plan in the dashboard.
     */
    MEMBERSHIP_OFFLINE = "MEMBERSHIP_OFFLINE"
}
export interface BookingSource {
    /** Platform from which a booking was created. */
    platform?: Platform;
    /** Actor that created this booking. */
    actor?: Actor;
    /**
     * Wix site ID of the application that created the booking.
     * @format GUID
     * @readonly
     */
    appDefId?: string | null;
    /**
     * Name of the application that created the booking, as saved in Wix Developers Center at the time of booking.
     * @readonly
     */
    appName?: string | null;
}
export declare enum Platform {
    UNDEFINED_PLATFORM = "UNDEFINED_PLATFORM",
    WEB = "WEB",
    MOBILE_APP = "MOBILE_APP"
}
export declare enum Actor {
    UNDEFINED_ACTOR = "UNDEFINED_ACTOR",
    BUSINESS = "BUSINESS",
    CUSTOMER = "CUSTOMER"
}
export interface ParticipantNotification {
    /**
     * Whether to send the message about the changes to the customer.
     *
     * Default: `false`
     */
    notifyParticipants?: boolean;
    /** Custom message to send to the participants about the changes to the booking. */
    message?: string | null;
}
export interface CommonIdentificationData extends CommonIdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
    /**
     * ID of of a contact in the site's [CRM by Ascend](https://www.wix.com/ascend/crm) system.
     * @format GUID
     */
    contactId?: string | null;
}
/** @oneof */
export interface CommonIdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
}
export declare enum IdentificationDataIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
export interface FlowControlSettings {
    /** Whether availability is checked when creating or confirming the booking. */
    skipAvailabilityValidation?: boolean;
    /**
     * Whether the booking's `status` is automatically updated to `CONFIRMED` when
     * the customer completes the *eCommerce checkout*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/ecom/checkout/setup) | [REST](https://dev.wix.com/docs/rest/business-solutions/e-commerce/checkout/introduction)),
     * regardless of whether the relevant service requires manual business confirmation.
     */
    skipBusinessConfirmation?: boolean;
    /**
     * Whether the customer is allowed to pay with a payment method that isn't
     * supported for the relevant service.
     */
    skipSelectedPaymentOptionValidation?: boolean;
    /**
     * Whether the customer receives an automatic refund if there's a double booking
     * conflict. Only available if the customer has paid with a
     * pricing plan.
     */
    withRefund?: boolean | null;
}
export interface ExtendedFields {
    /**
     * Extended field data. Each key corresponds to the namespace of the app that created the extended fields.
     * The value of each key is structured according to the schema defined when the extended fields were configured.
     *
     * You can only access fields for which you have the appropriate permissions.
     *
     * Learn more about [extended fields](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields).
     */
    namespaces?: Record<string, Record<string, any>>;
}
export interface ParticipantChoices {
    /**
     * Information about the booked service choices. Includes the number of participants.
     * @minSize 1
     * @maxSize 20
     */
    serviceChoices?: ServiceChoices[];
}
export interface ServiceChoices {
    /**
     * Number of participants for this _variant_
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/service-options-and-variants/introduction) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/service-options-and-variants/introduction)).
     * @min 1
     */
    numberOfParticipants?: number | null;
    /**
     * Service choices for these participants.
     * @maxSize 5
     */
    choices?: ServiceChoice[];
}
export interface ServiceChoice extends ServiceChoiceChoiceOneOf {
    /**
     * Value for one of the choices in the [`CustomServiceOption.choices`](https://example.com) list.
     * Choices are specific values for an option the customer can choose to book. For example,
     * the option `ageGroup` may have these choices: `child`, `student`, `adult`, and `senior`.
     * Each choice may have a different price.
     */
    custom?: string;
    duration?: Duration;
    /**
     * ID of the corresponding option for the choice. For example, the choice `child`
     * could correspond to the option `ageGroup`. In this case, `optionId` is the ID
     * for the `ageGroup` option.
     * @format GUID
     */
    optionId?: string;
}
/** @oneof */
export interface ServiceChoiceChoiceOneOf {
    /**
     * Value for one of the choices in the [`CustomServiceOption.choices`](https://example.com) list.
     * Choices are specific values for an option the customer can choose to book. For example,
     * the option `ageGroup` may have these choices: `child`, `student`, `adult`, and `senior`.
     * Each choice may have a different price.
     */
    custom?: string;
    duration?: Duration;
}
export interface Duration {
    /**
     * Duration of the service in minutes.
     * Min: 1 minute, Max: 30 days, 23 hours, and 59 minutes
     * @min 1
     * @max 44639
     */
    minutes?: number;
    /**
     * Name of the duration option.
     * Defaults to the formatted duration e.g. "1 hour, 30 minutes".
     * @maxLength 255
     */
    name?: string | null;
}
export interface MultiServiceBookingInfo {
    /**
     * Multi-service booking ID.
     * @format GUID
     * @readonly
     */
    _id?: string | null;
    /** Type of the multi-service booking. */
    type?: MultiServiceBookingType;
}
export interface BookingFormFilled {
    /** The booking object that form was filled for. */
    booking?: Booking;
    /**
     * The submitted form data, where key is the form field and value is the data submitted for the given field.
     * See the [form submission object](https://dev.wix.com/docs/rest/crm/forms/form-submissions/submission-object)
     * for more details.
     */
    formSubmission?: Record<string, any> | null;
    /**
     * ID of the [form](https://dev.wix.com/docs/rest/crm/forms/form-schemas/form-object)
     * that was filled.
     * @format GUID
     */
    formId?: string | null;
}
export interface SetBookingFormAndSubmissionIdRequest extends SetBookingFormAndSubmissionIdRequestCreatedByOneOf {
    /**
     * The visitor who created the booking.
     * @format GUID
     */
    visitorId?: string | null;
    /**
     * The member that created the booking.
     * @format GUID
     */
    memberId?: string | null;
    /**
     * The app that created the booking.
     * @format GUID
     */
    appId?: string | null;
    /**
     * ID of the booking to set `formId` and `submissionId` for.
     * @format GUID
     */
    bookingId?: string | null;
    /**
     * ID of the form to set on the booking.
     * @format GUID
     */
    formId?: string | null;
    /**
     * ID of the form submission to set on the booking.
     * @format GUID
     */
    submissionId?: string | null;
    /**
     * MetaSite ID
     * @format GUID
     */
    msid?: string | null;
    /**
     * Instance ID
     * @format GUID
     */
    instanceId?: string | null;
}
/** @oneof */
export interface SetBookingFormAndSubmissionIdRequestCreatedByOneOf {
    /**
     * The visitor who created the booking.
     * @format GUID
     */
    visitorId?: string | null;
    /**
     * The member that created the booking.
     * @format GUID
     */
    memberId?: string | null;
    /**
     * The app that created the booking.
     * @format GUID
     */
    appId?: string | null;
}
export interface SetBookingFormAndSubmissionIdResponse {
    /** Updated booking. */
    booking?: Booking;
}
export interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /**
     * Unique event ID.
     * Allows clients to ignore duplicate webhooks.
     */
    _id?: string;
    /**
     * Assumes actions are also always typed to an entity_type
     * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
     */
    entityFqdn?: string;
    /**
     * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
     * This is although the created/updated/deleted notion is duplication of the oneof types
     * Example: created/updated/deleted/started/completed/email_opened
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number defining the order of updates to the underlying entity.
     * For example, given that some entity was updated at 16:00 and than again at 16:01,
     * it is guaranteed that the sequence number of the second update is strictly higher than the first.
     * As the consumer, you can use this value to ensure that you handle messages in the correct order.
     * To do so, you will need to persist this number on your end, and compare the sequence number from the
     * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
export interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
export interface EntityCreatedEvent {
    entity?: string;
}
export interface RestoreInfo {
    deletedDate?: Date | null;
}
export interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntity?: string;
}
export interface EntityDeletedEvent {
    /** Entity that was deleted */
    deletedEntity?: string | null;
}
export interface ActionEvent {
    body?: string;
}
export interface MessageEnvelope {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: WebhooksIdentificationData;
    /** Stringify payload. */
    data?: string;
}
export interface WebhooksIdentificationData extends WebhooksIdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityType;
}
/** @oneof */
export interface WebhooksIdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
}
export declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
export interface V2CreateBookingRequest extends V2CreateBookingRequestBookableItemOneOf, V2CreateBookingRequestParticipantsInfoOneOf {
    /**
     * Information about the slot to create a booking for.
     * If you set `slot.location.locationType` to `CUSTOM`, the created slot's
     * location is set to `slot.location.formattedAddress` when provided.
     * Otherwise it's set to `contactDetails.fullAddress.formattedAddress`.
     */
    slot?: Slot;
    /** Information about the schedule to create a booking for. */
    schedule?: BookedSchedule;
    /** Contact details of the customer booking the service. */
    contactDetails?: ContactDetails;
    /**
     * Booking status.
     * One of:
     * - `"CREATED"` - The booking was created.
     * - `"UPDATED"` - The booking was updated.
     * - `"CONFIRMED"` - The booking has been confirmed and appears on the bookings calendar.
     * Booking can be manually confirmed using the Set As Confirmed endpoint.
     * Booking can be automatically confirmed when the following requirements are met:
     * + The service is configured as automatically confirmed.
     * + Invoking eCommerce checkout API and an order has been created.
     * - `"CANCELED"` - The booking has been canceled and synced to bookings calendar.
     * The booking can be canceled using cancel API.
     * - `"PENDING"` - The booking waiting to be confirmed or declined buy the owner and is synced to bookings calendar.
     * Bookings can be manually set as pending using setAsPending API, requires manage booking status permissions.
     * Booking can be automatically set as pending when the following requirements are met:
     * + The Service is configured as manually confirmed.
     * + Invoking the eCommerce checkout API and an order has been created.
     * - `"WAITING_LIST"` - The booking is pending on a waiting list.
     * Booking can be created with this status when invoking waiting list join API.
     * - `"DECLINED"` - The booking was declined by the owner and synced to bookings calendar.
     * Booking can be manually declined using decline API and requires manage booking permissions.
     * Booking can be automatically declined when the following requirements are met:
     * + Invoking eCommerce checkout API and the order declined event has been sent.
     * + Invoking eCommerce checkout API and order approved event has been sent, but the booking is offline and the booking causes a double booking.
     */
    status?: BookingStatus;
    /**
     * Additional custom fields of the booking form. The customer must provide
     * information for each field when booking the service. For example, that they
     * bring their own towels or whether they use a wheelchair.
     *
     * Max: 100 fields
     * @maxSize 100
     */
    additionalFields?: CustomFormField[];
    /**
     * Total number of participants. Available only when the service doesn't have
     * [variants](https://dev.wix.com/api/rest/wix-bookings/service-options-and-variants/introduction).
     *
     * Max: `20`
     */
    numberOfParticipants?: number | null;
    /**
     * Internal business note. Not visible to the customer.
     *
     * Max: 200 characters
     */
    internalBusinessNote?: string | null;
    /**
     * Payment option the customer intends to use.
     * Must be one of the payment options defined for the service, unless
     * you pass `flowControlSettings.skipSelectedPaymentOptionValidation` as `true`.
     */
    selectedPaymentOption?: SelectedPaymentOption;
    /**
     * Identifies the source (platform, actor and app) that created this booking.
     * This property of the booking cannot be changed.
     * The app_def_id and app_name will be resolved automatically.
     * TODO GAP See if we need this - might be able to get this data from the headers?
     */
    bookingSource?: BookingSource;
    /**
     * A user identifier of an external application user that initiated the book request.
     * Allows an external application to later identify its own bookings and correlate to its own internal users
     */
    externalUserId?: string | null;
    /** Information about a message to send to the customer. */
    participantNotification?: ParticipantNotification;
    /**
     * Whether to send an SMS reminder to the customer 24 hours before the
     * session starts. The phone number is taken from `contactDetails.phone`.
     *
     * Default: `true`.
     */
    sendSmsReminder?: boolean | null;
    /**
     * Information about whether specific procedures of the standard Wix Bookings
     * creation flow are changed. For example, whether the availability is
     * checked before creating the booking or if additional payment options are
     * accepted.
     */
    flowControlSettings?: CreateBookingRequestFlowControlSettings;
}
/** @oneof */
export interface V2CreateBookingRequestBookableItemOneOf {
    /**
     * Information about the slot to create a booking for.
     * If you set `slot.location.locationType` to `CUSTOM`, the created slot's
     * location is set to `slot.location.formattedAddress` when provided.
     * Otherwise it's set to `contactDetails.fullAddress.formattedAddress`.
     */
    slot?: Slot;
    /** Information about the schedule to create a booking for. */
    schedule?: BookedSchedule;
}
/** @oneof */
export interface V2CreateBookingRequestParticipantsInfoOneOf {
}
export interface Slot {
    /**
     * ID for the slot's corresponding session, when the session is either a single session
     * or a specific session generated from a recurring session.
     *
     * Deprecated. Please use `eventId` instead.
     * @deprecated ID for the slot's corresponding session, when the session is either a single session
     * or a specific session generated from a recurring session.
     *
     * Deprecated. Please use `eventId` instead.
     * @replacedBy event_id
     * @targetRemovalDate 2025-09-30
     */
    sessionId?: string | null;
    /** Service ID. */
    serviceId?: string;
    /** Schedule ID. */
    scheduleId?: string;
    /**
     * The start time of this slot in [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339)
     * format.
     *
     * If `timezone` is specified,
     * dates are based on the local date/time. This means that the timezone offset
     * in the `start_date` is ignored.
     */
    startDate?: string | null;
    /**
     * The end time of this slot in
     * [RFC 3339](https://www.rfc-editor.org/rfc/rfc3339) format.
     *
     * If `timezone` is specified,
     * dates are based on the local date/time. This means that the timezone offset
     * in the `end_date` is ignored.
     */
    endDate?: string | null;
    /**
     * The timezone for which slot availability is to be calculated.
     *
     * Learn more about [handling Daylight Savings Time (DST) for local time zones](https://dev.wix.com/api/rest/wix-bookings/availability-calendar/query-availability#wix-bookings_availability-calendar_query-availability_handling-daylight-savings-time-dst-for-local-time-zones)
     * when calculating availability.
     */
    timezone?: string | null;
    /**
     * The resource required for this slot. Currently, the only supported resource
     * is the relevant staff member for the slot.
     */
    resource?: SlotResource;
    /** Geographic location of the slot. */
    location?: Location;
    /**
     * ID for the slot's corresponding event, when the event is either a single event
     * or a specific event generated from a recurring event.
     * @minLength 36
     * @maxLength 250
     */
    eventId?: string | null;
}
export interface SlotResource {
    /**
     * Resource ID.
     * @format GUID
     * @readonly
     */
    _id?: string | null;
    /**
     * Resource name. Read only.
     * @maxLength 1200
     */
    name?: string | null;
}
export interface CreateBookingRequestFlowControlSettings {
    /**
     * Whether the availability is checked before creating the booking. When
     * passing `false` a booking is only created when the slot or schedule is
     * available. Your app must have the `BOOKINGS.OVERRIDE_AVAILABILITY`
     * permission scope when passing `true`.
     *
     * Default: `false`.
     */
    skipAvailabilityValidation?: boolean;
    /**
     * Whether `PENDING` bookings are automatically set to `CONFIRMED` for
     * services that normally require the owner's manual confirmation. Your
     * app must have the `BOOKINGS.OVERRIDE_AVAILABILITY` permission scope
     * when passing `true`.
     *
     * Default: `false`.
     */
    skipBusinessConfirmation?: boolean;
    /**
     * Whether customers can pay using a payment method that isn't supported
     * for the service, but that's supported for other services. Your app
     * must have the `BOOKINGS.MANAGE_PAYMENTS` permission scope when passing
     * `true`.
     *
     * Default: `false`.
     */
    skipSelectedPaymentOptionValidation?: boolean;
}
export interface V2CreateBookingResponse {
    /** Created booking. */
    booking?: Booking;
}
export interface V2CancelBookingRequest {
    /**
     * ID of the booking to cancel.
     * @format GUID
     */
    bookingId?: string;
    /**
     * Information about whether to notify the customer about the cancellation and
     * the message to send.
     */
    participantNotification?: ParticipantNotification;
    /**
     * Revision number, which increments by 1 each time the booking is updated.
     * To prevent conflicting changes,
     * the current revision must be passed when managing the booking.
     */
    revision?: string | null;
}
export interface CancelBookingRequestFlowControlSettings {
    /**
     * Whether the cancellation policy applies when canceling the booking. When
     * passing `false` you can only cancel a booking if the cancellation policy
     * allows it. Your app must have the `BOOKINGS.IGNORE_BOOKING_POLICY `
     * permission scope when passing `true`.
     *
     * Default: `false`.
     */
    ignoreCancellationPolicy?: boolean;
    /**
     * Whether to issue a refund when canceling the booking.
     * The refund will be issued only if the booking is refundable.
     * Currently, booking is considered refundable when it was paid by membership.
     * If passing `true`, the booking flow control settings will be set with refund,
     * otherwise, either if `false` is passed or the field remains empty,
     * the booking flow control settings will be set with no refund.
     *
     * Default: `false`.
     */
    withRefund?: boolean | null;
}
export interface V2CancelBookingResponse {
    /** Canceled booking. */
    booking?: Booking;
}
export interface V2RescheduleBookingRequest extends V2RescheduleBookingRequestParticipantsInfoOneOf {
    /**
     * Id of the booking to reschedule.
     * @format GUID
     */
    bookingId?: string;
    /** Information about the new slot. */
    slot?: Slot;
    /**
     * Revision number, which increments by 1 each time the booking is updated.
     * To prevent conflicting changes, the current revision must be passed when
     * managing the booking.
     */
    revision?: string | null;
    /**
     * Information about whether to notify the customer about the rescheduling and
     * the message to send.
     */
    participantNotification?: ParticipantNotification;
}
/** @oneof */
export interface V2RescheduleBookingRequestParticipantsInfoOneOf {
}
export interface RescheduleBookingRequestFlowControlSettings {
    /**
     * Whether the rescheduling policy applies when rescheduling the booking.
     * When passing `false` you can only cancel a booking if the rescheduling
     * policy allows it. Your app must have the `BOOKINGS.IGNORE_BOOKING_POLICY `
     * permission scope when passing `true`.
     *
     * Default: `false`.
     */
    ignoreReschedulePolicy?: boolean;
    /**
     * Whether the availability is checked before rescheduling the booking.
     * When passing `false` a booking is only created when the slot or
     * schedule is available. Your app must have the `BOOKINGS.OVERRIDE_AVAILABILITY`
     * permission scope when passing `true`.
     *
     * Default: `false`.
     */
    skipAvailabilityValidation?: boolean;
    /**
     * Whether the rescheduled booking's status is automatically set to
     * `CONFIRMED` for services that normally require the owner's manual
     * confirmation. Your app must have the `BOOKINGS.OVERRIDE_AVAILABILITY`
     * permission scope when passing `true`.
     *
     * Default: `false`.
     */
    skipBusinessConfirmation?: boolean;
}
export interface V2RescheduleBookingResponse {
    /** Rescheduled booking. */
    booking?: Booking;
}
export interface V2ConfirmBookingRequest {
    /**
     * ID of the booking to confirm.
     * @format GUID
     */
    bookingId?: string;
    /**
     * Revision number, which increments by 1 each time the booking is updated.
     * To prevent conflicting changes, the current revision must be passed when
     * managing the booking.
     */
    revision?: string | null;
    /**
     * Information about whether to notify the customer about the confirmation and
     * the message to send.
     */
    participantNotification?: ParticipantNotification;
}
export interface V2ConfirmBookingResponse {
    booking?: Booking;
}
export interface V2DeclineBookingRequest {
    /**
     * ID of the booking to decline.
     * @format GUID
     */
    bookingId?: string;
    /**
     * Revision number, which increments by 1 each time the booking is updated.
     * To prevent conflicting changes, the current revision must be passed when
     * managing the booking.
     */
    revision?: string | null;
    /**
     * Information about whether to notify the customer about the decline and
     * the message to send.
     */
    participantNotification?: ParticipantNotification;
}
export interface V2DeclineBookingResponse {
    /** Declined booking. */
    booking?: Booking;
}
export interface V2UpdateNumberOfParticipantsRequest extends V2UpdateNumberOfParticipantsRequestParticipantsInfoOneOf {
    /**
     * ID of the booking to update the number of participants for.
     * @format GUID
     */
    bookingId?: string;
    /** Updated number of participants. */
    numberOfParticipants?: number | null;
    /**
     * Revision number, which increments by 1 each time the booking is updated.
     * To prevent conflicting changes, the current revision must be passed when
     * managing the booking.
     */
    revision?: string | null;
}
/** @oneof */
export interface V2UpdateNumberOfParticipantsRequestParticipantsInfoOneOf {
}
export interface V2UpdateNumberOfParticipantsResponse {
    /** Booking with updated number of participants. */
    booking?: Booking;
}
export interface ConfirmOrDeclineBookingRequest {
    /**
     * ID of the booking to confirm or decline.
     * @format GUID
     */
    bookingId: string;
    /**
     * Current payment status of the booking when using a custom checkout page and
     * not the *eCommerce checkout*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/ecom/checkout/setup) | [REST](https://dev.wix.com/docs/rest/business-solutions/e-commerce/checkout/introduction)).
     *
     * The booking is declined if there is a double booking conflict and you provide
     * one of these payment statuses: `UNDEFINED`, `NOT_PAID`, `REFUNDED`, or `EXEMPT`.
     */
    paymentStatus?: PaymentStatus;
}
export interface ConfirmOrDeclineBookingResponse {
    /** Updated booking. */
    booking?: Booking;
}
export interface BulkConfirmOrDeclineBookingRequest {
    /**
     * Bookings to confirm or decline.
     * @minSize 1
     * @maxSize 300
     */
    details: BulkConfirmOrDeclineBookingRequestBookingDetails[];
    /** Whether to return the confirmed or declined booking objects. */
    returnEntity?: boolean;
}
export interface BulkConfirmOrDeclineBookingRequestBookingDetails {
    /**
     * ID of the booking to confirm or decline.
     * @format GUID
     */
    bookingId?: string;
    /**
     * Current payment status of the booking when using a custom checkout page and
     * not the *eCommerce checkout*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/ecom/checkout/setup) | [REST](https://dev.wix.com/docs/rest/business-solutions/e-commerce/checkout/introduction)).
     *
     * The booking is declined if there is a double booking conflict and you provide
     * one of these payment statuses: `UNDEFINED`, `NOT_PAID`, `REFUNDED`, or `EXEMPT`.
     */
    paymentStatus?: PaymentStatus;
}
export interface BulkConfirmOrDeclineBookingResponse {
    /** List of confirmed or declined bookings, including metadata. */
    results?: BulkBookingResult[];
    /** Total successes and failures of the Bulk Confirm Or Decline call. */
    bulkActionMetadata?: BulkActionMetadata;
}
export interface BulkBookingResult {
    /**
     * Information about the booking that was created or updated.
     * Including its ID, index in the bulk request and whether it was
     * successfully created or updated.
     */
    itemMetadata?: ItemMetadata;
    /**
     * Created or updated booking. Available only if you requested
     * to return the booking entity.
     */
    item?: Booking;
}
export interface ItemMetadata {
    /** Item ID. Should always be available, unless it's impossible (for example, when failing to create an item). */
    _id?: string | null;
    /** Index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
    success?: boolean;
    /** Details about the error in case of failure. */
    error?: ApplicationError;
}
export interface ApplicationError {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
export interface BulkActionMetadata {
    /** Number of items that were successfully processed. */
    totalSuccesses?: number;
    /** Number of items that couldn't be processed. */
    totalFailures?: number;
    /** Number of failures without details because detailed failure threshold was exceeded. */
    undetailedFailures?: number;
}
export interface BookingChanged {
    /** The booking before the changes. */
    previousBooking?: Booking;
    /** The booking after the changes. */
    currentBooking?: Booking;
}
export interface CreateBookingRequest {
    /** The booking to create. */
    booking: Booking;
    /**
     * Information about whether to notify the customer and
     * the message to send.
     */
    participantNotification?: ParticipantNotification;
    /**
     * Whether to send an SMS reminder to the customer 24 hours before the
     * session starts. The phone number is taken from `contactDetails.phone`.
     * Default: `true`.
     */
    sendSmsReminder?: boolean | null;
    /**
     * Whether to ignore specific standard procedures of the Wix Bookings flow.
     * For example, whether to check availability when creating a booking.
     */
    flowControlSettings?: CreateBookingFlowControlSettings;
}
export interface CreateBookingFlowControlSettings {
    /**
     * Whether the availability is checked before creating the booking.
     *
     * When passing `false`, a booking is only created when the slot or schedule is available.
     * Default: `false`.
     */
    skipAvailabilityValidation?: boolean;
    /**
     * Whether `PENDING` bookings are automatically set to `CONFIRMED` for
     * services that normally require the owner's manual confirmation.
     *
     * Your app must have the `BOOKINGS.OVERRIDE_AVAILABILITY` permission scope
     * when passing `true`.
     * Default: `false`.
     */
    skipBusinessConfirmation?: boolean;
    /**
     * Whether customers can pay using a payment method that isn't supported
     * for the service, but that's supported for other services.
     *
     * Your app must have the `BOOKINGS.MANAGE_PAYMENTS` permission scope when passing
     * `true`.
     * Default: `false`.
     */
    skipSelectedPaymentOptionValidation?: boolean;
}
export interface CreateBookingResponse {
    /** Created booking. */
    booking?: Booking;
}
/**
 * The `fieldMask` should not include both the `numberOfParticipants` and `participantsInfo` paths. Including both results
 * in an error. `participantsInfo` is preferred over `numberOfParticipants`.
 */
export interface UpdateBookingRequest {
    booking?: Booking;
}
export interface UpdateBookingResponse {
    booking?: Booking;
}
export interface LegacyCreateBookingRequest {
    booking?: Booking;
}
export interface LegacyCreateBookingResponse {
    booking?: Booking;
}
/**
 * The `fieldMask` for each booking should not include both the `numberOfParticipants` and `participantsInfo` paths. Including both results
 * in an error. `participantsInfo` is preferred over `numberOfParticipants`.
 */
export interface BulkUpdateBookingRequest {
    bookings?: MaskedBooking[];
}
export interface MaskedBooking {
    booking?: Booking;
    mask?: string[];
}
export interface BulkUpdateBookingResponse {
    /**
     * Information about the booking that was updated.
     * Including its ID, index in the bulk request and whether it was
     * successfully updated.
     */
    results?: ItemMetadata[];
    /** Total number of successes and failures for Bulk Update Bookings. */
    bulkActionMetadata?: BulkActionMetadata;
}
export interface BulkCreateBookingRequest {
    /**
     * Bookings to create.
     *
     * Max: 8 bookings
     * @minSize 1
     * @maxSize 8
     */
    createBookingsInfo: CreateBookingInfo[];
    /** Whether to return the created bookings. */
    returnFullEntity?: boolean;
}
export interface CreateBookingInfo {
    /** Booking to create. */
    booking?: Booking;
    /**
     * Information about whether to notify the customer and
     * the message to send.
     */
    participantNotification?: ParticipantNotification;
    /**
     * Whether to send an SMS reminder to the customer 24 hours before the
     * session starts. The phone number is taken from `contactDetails.phone`.
     * Default: `true`.
     */
    sendSmsReminder?: boolean | null;
    /**
     * Whether to ignore specific standard procedures of the Wix Bookings flow.
     * For example, whether to check availability when creating a booking.
     */
    flowControlSettings?: CreateBookingFlowControlSettings;
}
export interface BulkCreateBookingResponse {
    /** List of individual Bulk Create Bookings results. */
    results?: BulkBookingResult[];
    /** Total number of successes and failures for Bulk Create Bookings. */
    bulkActionMetadata?: BulkActionMetadata;
}
export interface RescheduleBookingRequest extends RescheduleBookingRequestParticipantsInfoOneOf {
    /**
     * Total number of participants. Specify when all participants have booked the
     * same service variant.
     */
    totalParticipants?: number;
    /**
     * Information about the service choices to book. Specify when not all
     * participants have booked the same service variant.
     */
    participantsChoices?: ParticipantChoices;
    /**
     * ID of the booking to reschedule.
     * @format GUID
     */
    bookingId: string;
    /** New slot of the booking. */
    slot: V2Slot;
    /**
     * Revision number, which increments by 1 each time the booking is rescheduled.
     * To prevent conflicting changes, the current revision must be passed when
     * rescheduling the booking.
     */
    revision: string | null;
    /**
     * Information about whether to notify the customer about the rescheduling and
     * the message to send.
     */
    participantNotification?: ParticipantNotification;
    /**
     * Whether to ignore specific standard procedures of the Wix Bookings flow.
     * For example, whether to check availability when rescheduling a booking.
     */
    flowControlSettings?: RescheduleBookingFlowControlSettings;
}
/** @oneof */
export interface RescheduleBookingRequestParticipantsInfoOneOf {
    /**
     * Total number of participants. Specify when all participants have booked the
     * same service variant.
     */
    totalParticipants?: number;
    /**
     * Information about the service choices to book. Specify when not all
     * participants have booked the same service variant.
     */
    participantsChoices?: ParticipantChoices;
}
export interface V2Slot {
    /** Identifier for the underlying session when the session is a single session or generated from a recurring session. */
    sessionId?: string | null;
    /** Service identifier. Required. */
    serviceId?: string;
    /** Schedule identifier. Required. */
    scheduleId?: string;
    /** The start time of this slot (formatted according to RFC3339). */
    startDate?: string | null;
    /** The end time of this slot (formatted according to RFC3339). */
    endDate?: string | null;
    /** The timezone according to which the slot is calculated and presented. */
    timezone?: string | null;
    /**
     * The resource required for this slot.
     * When populated, the specified resource will be assigned to the slot upon confirmation according to its availability.
     * When empty, if `skip_availability_validation` is `false`, a random available resource will be assigned to the slot upon confirmation.
     * Otherwise, one of the service resources will be assigned to the slot randomly upon confirmation.
     */
    resource?: SlotSlotResource;
    /** Geographic location of the slot. */
    location?: SlotLocation;
    /**
     * Calendar event ID - not supported.
     * If not empty, on all write flows (create/update), it takes priority over `sessionId`.
     * So if both `sessionId` and `eventId` are provided, the `sessionId` will be based on the `eventId`.
     * Otherwise, if `eventId` is empty on write flow,
     * @minLength 36
     * @maxLength 250
     */
    eventId?: string | null;
}
export declare enum LocationLocationType {
    /** Undefined location type. */
    UNDEFINED = "UNDEFINED",
    /** The business address as set in the siteâ€™s general settings. */
    OWNER_BUSINESS = "OWNER_BUSINESS",
    /** The address set when creating the service. */
    OWNER_CUSTOM = "OWNER_CUSTOM",
    /** The address set for the individual session. */
    CUSTOM = "CUSTOM"
}
export interface SlotSlotResource {
    /**
     * Resource ID.
     * @format GUID
     * @readonly
     */
    _id?: string | null;
    /**
     * Resource name.
     * @maxLength 1200
     */
    name?: string | null;
}
export interface SlotLocation {
    /**
     * Business Location ID. Present if the location is a business location.
     * @format GUID
     */
    _id?: string | null;
    /** Location name. */
    name?: string | null;
    /** A string containing the full address of this location. */
    formattedAddress?: string | null;
    /** Location type. */
    locationType?: LocationLocationType;
}
export interface RescheduleBookingFlowControlSettings {
    /**
     * Whether the rescheduling policy applies when rescheduling the booking.
     *
     * When passing `false`, you can only cancel a booking if the rescheduling
     * policy allows it.
     * Default: `false`.
     */
    ignoreReschedulePolicy?: boolean;
    /**
     * Whether the availability is checked before rescheduling the booking.
     *
     * When passing `false`, a booking is only created when the slot or
     * schedule is available.
     * Default: `false`.
     */
    skipAvailabilityValidation?: boolean;
    /**
     * Whether the rescheduled booking's status is automatically set to
     * `CONFIRMED` for services that normally require the owner's manual
     * confirmation.
     * Default: `false`.
     */
    skipBusinessConfirmation?: boolean;
}
export interface RescheduleBookingResponse {
    /** Rescheduled booking. */
    booking?: Booking;
}
export interface BookingRescheduled extends BookingRescheduledPreviousParticipantsInfoOneOf {
    /**
     * The previous total number of participants. Available only when the booking includes
     * a single service variant.
     */
    previousTotalParticipants?: number;
    /**
     * Information about the previous booked service choices and participants.
     * Available only when the booking includes multiple service variants.
     */
    previousParticipantsChoices?: ParticipantChoices;
    /** The rescheduled booking object. */
    booking?: Booking;
    /** Information about whether to notify the customer about the rescheduling and the message to send. */
    participantNotification?: ParticipantNotification;
    /**
     * Information about whether specific procedures of the standard Wix Bookings
     * rescheduling flow are changed. For example, whether the availability of
     * the new slot is checked before rescheduling the booking or if you can
     * reschedule the booking even though the rescheduling policy doesn't allow it.
     */
    flowControlSettings?: RescheduleBookingFlowControlSettings;
    /** ID of the rescheduling initiator. */
    initiatedBy?: IdentificationData;
    /** The previous status of the booking. */
    previousStatus?: BookingStatus;
    /** An object describing the previous slot or schedule of the booking. */
    previousBookedEntity?: BookedEntity;
    /**
     * The previous start date of the booking.
     * For a slot, this is the start date of the slot.
     * For a schedule, this is the start date of the first session.
     */
    previousStartDate?: Date | null;
    /**
     * The previous end date of the booking.
     * For a slot, this is the end date of the slot.
     * For a schedule, this is the end date of the last session.
     */
    previousEndDate?: Date | null;
}
/** @oneof */
export interface BookingRescheduledPreviousParticipantsInfoOneOf {
    /**
     * The previous total number of participants. Available only when the booking includes
     * a single service variant.
     */
    previousTotalParticipants?: number;
    /**
     * Information about the previous booked service choices and participants.
     * Available only when the booking includes multiple service variants.
     */
    previousParticipantsChoices?: ParticipantChoices;
}
export interface IdentificationData extends IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
    /**
     * ID of of a contact in the site's [CRM by Ascend](https://www.wix.com/ascend/crm) system.
     * @format GUID
     * @readonly
     */
    contactId?: string | null;
}
/** @oneof */
export interface IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
}
export declare enum IdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
export interface BulkRescheduleBookingRequest {
    /**
     * Reschedule multiple bookings to multiple slots.
     * @minSize 1
     */
    slotsBookings?: SlotBookings[];
    /**
     * Information about whether to notify the customer about the rescheduling and
     * the message to send.
     */
    participantNotification?: ParticipantNotification;
}
export interface BulkRescheduleBookingRequestBooking {
    /**
     * ID of the booking to reschedule.
     * @format GUID
     */
    _id?: string;
    /**
     * Revision number, which increments by 1 each time the booking is rescheduled.
     * To prevent conflicting changes,
     * the current revision must be specified when rescheduling the booking.
     */
    revision?: string | null;
}
/** Bookings to be rescheduled to the given slot. */
export interface SlotBookings {
    /**
     * The bookings details.
     * @minSize 1
     */
    bookings?: BulkRescheduleBookingRequestBooking[];
    /**
     * The slot to which the bookings were rescheduled.
     * These bookings are automatically assigned to the session, if given. Otherwise, a new session is created.
     */
    slot?: BookedSlot;
}
export interface BulkRescheduleBookingResponse {
    /**
     * Information about the booking that was rescheduled.
     * Including its ID, index in the bulk request and whether it was
     * successfully rescheduled.
     */
    results?: ItemMetadata[];
    /** Total number of successes and failures for Bulk Reschedule Bookings. */
    bulkActionMetadata?: BulkActionMetadata;
}
/** Update the booked schedule of multiple bookings to the given schedule. */
export interface BulkUpdateBookedScheduleRequest {
    /**
     * The bookings whose booked schedule is to be updated to the given schedule.
     * @minSize 1
     */
    bookings?: BookingDetails[];
    /** ID of the schedule to update. */
    scheduleId?: string;
    /**
     * Information about whether to notify the customer about the rescheduling and
     * the message to send.
     */
    participantNotification?: ParticipantNotification;
}
export interface BookingDetails {
    /**
     * ID of the bookings to be updated.
     * @format GUID
     */
    _id?: string;
    revision?: string | null;
}
export interface BulkUpdateBookedScheduleResponse {
    /**
     * Information about the schedule that was updated.
     * Including its ID, index in the bulk request and whether it was
     * succesfully updated.
     */
    results?: ItemMetadata[];
    /** Total number of successes and failures for Bulk Updated Booked Schedules. */
    bulkActionMetadata?: BulkActionMetadata;
}
export interface QueryBookingsRequest {
    /** Information about filters, paging, and sorting. */
    query?: QueryV2;
}
export interface QueryV2 extends QueryV2PagingMethodOneOf {
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
    /**
     * Cursor token pointing to a page of results. In the first request,
     * specify `cursorPaging.limit`. For following requests, specify the
     * retrieved `cursorPaging.cursor` token and not `query.filter` or
     * `query.sort`.
     */
    cursorPaging?: CursorPaging;
    /**
     * Filter object in the following format:
     * `"filter" : {
     * "fieldName1": "value1",
     * "fieldName2":{"$operator":"value2"}
     * }`
     * Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object in the following format:
     * `[{"fieldName":"sortField1","order":"ASC"},{"fieldName":"sortField2","order":"DESC"}]`
     */
    sort?: Sorting[];
    /** Array of projected fields. A list of specific field names to return. If `fieldsets` are also specified, the union of `fieldsets` and `fields` is returned. */
    fields?: string[];
    /** Array of named, predefined sets of projected fields. A array of predefined named sets of fields to be returned. Specifying multiple `fieldsets` will return the union of fields from all sets. If `fields` are also specified, the union of `fieldsets` and `fields` is returned. */
    fieldsets?: string[];
}
/** @oneof */
export interface QueryV2PagingMethodOneOf {
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
    /**
     * Cursor token pointing to a page of results. In the first request,
     * specify `cursorPaging.limit`. For following requests, specify the
     * retrieved `cursorPaging.cursor` token and not `query.filter` or
     * `query.sort`.
     */
    cursorPaging?: CursorPaging;
}
export interface Sorting {
    /**
     * Name of the field to sort by.
     * @maxLength 512
     */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrder;
}
export declare enum SortOrder {
    ASC = "ASC",
    DESC = "DESC"
}
export interface Paging {
    /** Number of items to load. */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
export interface CursorPaging {
    /**
     * Maximum number of items to return in the results.
     * @max 100
     */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     * @maxLength 16000
     */
    cursor?: string | null;
}
export interface QueryBookingsResponse {
    /** Retrieved bookings. */
    bookings?: Booking[];
    /** Paging metadata. */
    pagingMetadata?: PagingMetadataV2;
}
export interface PagingMetadataV2 {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Offset that was requested. */
    offset?: number | null;
    /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
    total?: number | null;
    /** Flag that indicates the server failed to calculate the `total` field. */
    tooManyToCount?: boolean | null;
    /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
    cursors?: Cursors;
}
export interface Cursors {
    /**
     * Cursor string pointing to the next page in the list of results.
     * @maxLength 16000
     */
    next?: string | null;
    /**
     * Cursor pointing to the previous page in the list of results.
     * @maxLength 16000
     */
    prev?: string | null;
}
export interface ConfirmRequest {
    /**
     * ID of the booking to confirm.
     * @format GUID
     */
    _id?: string;
    /**
     * Information about whether to notify the customer about the confirmation and
     * the message to send.
     */
    participantNotification?: ParticipantNotification;
}
export interface ConfirmResponse {
    /** Confirmed booking. */
    booking?: Booking;
    /** Whether this booking has a conflict with at least 1 other confirmed booking. */
    doubleBooked?: boolean | null;
}
export interface ConfirmBookingRequest {
    /**
     * ID of the booking to confirm.
     * @format GUID
     */
    bookingId: string;
    /**
     * Revision number, which increments by 1 each time the booking is updated.
     * To prevent conflicting changes, the current revision must be passed when
     * updating the booking.
     */
    revision: string | null;
    /**
     * Information about whether to notify the customer about the confirmation and
     * the message to send.
     */
    participantNotification?: ParticipantNotification;
    /**
     * Whether to send an SMS reminder to the customer 24 hours before the
     * session starts. The phone number is taken from `contactDetails.phone`.
     */
    sendSmsReminder?: boolean | null;
    /** Payment status to set for the booking. */
    paymentStatus?: PaymentStatus;
    /** Whether this booking has a conflict with at least 1 other confirmed booking. */
    doubleBooked?: boolean | null;
    /**
     * Whether to ignore specific standard procedures of the Wix Bookings flow.
     * For example, whether to check availability when confirming a booking.
     */
    flowControlSettings?: ConfirmBookingFlowControlSettings;
}
export interface ConfirmBookingFlowControlSettings {
    /**
     * Whether the availability is checked before confirming the booking.
     *
     * When specifying `false`, a booking is only updated with status `CONFIRMED`.
     * Default: `false`.
     */
    checkAvailabilityValidation?: boolean;
}
export interface ConfirmBookingResponse {
    /** Confirmed booking. */
    booking?: Booking;
}
export interface BookingConfirmed {
    /** The confirmed booking object. */
    booking?: Booking;
    /** Information about whether to notify the customer about the confirmation and the message to send. */
    participantNotification?: ParticipantNotification;
    /**
     * Whether to send an SMS reminder to the customer 24 hours before the session starts.
     * The phone number is taken from `contactDetails.phone`.
     */
    sendSmsReminder?: boolean | null;
    /** Whether this booking overlaps with another existing confirmed booking. */
    doubleBooked?: boolean | null;
    /** ID of the confirmation initiator. */
    initiatedBy?: IdentificationData;
    /** The previous status of the booking. */
    previousStatus?: BookingStatus;
    /** The previous payment status of the booking. */
    previousPaymentStatus?: PaymentStatus;
}
export interface ConsistentQueryBookingsRequest {
    /** Information about filters, paging, and sorting. */
    query?: QueryV2;
}
export interface ConsistentQueryBookingsResponse {
    /** Retrieved bookings. */
    bookings?: Booking[];
    /** Paging metadata. */
    pagingMetadata?: PagingMetadataV2;
}
export interface SetBookingSessionIdRequest {
    /**
     * ID of the booking to set `sessionId` for.
     * @format GUID
     */
    _id?: string;
    /** ID of the session to set on the booking. */
    sessionId?: string;
}
export interface SetBookingSessionIdResponse {
    /** Updated booking. */
    booking?: Booking;
}
export interface SetBookingSubmissionIdRequest {
    /**
     * ID of the booking to set `submissionId` for.
     * @format GUID
     */
    bookingId?: string;
    /**
     * ID of the form submission to set on the booking.
     * @format GUID
     */
    submissionId?: string;
}
export interface SetBookingSubmissionIdResponse {
    /** Updated booking. */
    booking?: Booking;
}
export interface UpdateExtendedFieldsRequest {
    /** ID of the entity to update. */
    _id: string;
    /** Identifier for the app whose extended fields are being updated. */
    namespace: string;
    /** Data to update. Structured according to the [schema](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields#json-schema-for-extended-fields) defined when the extended fields were configured. */
    namespaceData: Record<string, any> | null;
}
export interface UpdateExtendedFieldsResponse {
    /**
     * Updated namespace.
     * @maxLength 164
     */
    namespace?: string;
    /** Updated data. */
    namespaceData?: Record<string, any> | null;
}
export interface DeclineBookingRequest {
    /**
     * ID of the booking to decline.
     * @format GUID
     */
    bookingId: string;
    /**
     * Revision number, which increments by 1 each time the booking is updated.
     *
     * To prevent conflicting changes, the current revision must be specified when
     * declining the booking.
     * @min 1
     */
    revision: string | null;
    /**
     * Information about whether to notify the customer and
     * the message to send.
     */
    participantNotification?: ParticipantNotification;
    /** Payment status to set for the booking. */
    paymentStatus?: PaymentStatus;
    /** Whether this booking has a conflict with at least 1 other confirmed booking. */
    doubleBooked?: boolean | null;
    /**
     * Whether to ignore specific standard procedures of the Wix Bookings flow.
     * For example, whether to refund a declined booking.
     */
    flowControlSettings?: DeclineBookingFlowControlSettings;
}
export interface DeclineBookingFlowControlSettings {
    /**
     * Whether to issue a refund when declining the booking.
     *
     * The refund will be issued only if the booking is refundable.
     * Currently, a booking is considered refundable when it was paid by membership.
     * If specifying `true`, the booking flow control settings will be set with a refund.
     * If you specify `false` or an empty field,
     * the booking flow control settings are set without refund.
     *
     * Default: `false`.
     */
    withRefund?: boolean | null;
}
export interface DeclineBookingResponse {
    /** Declined booking. */
    booking?: Booking;
}
export interface BookingDeclined {
    /** The declined booking object. */
    booking?: Booking;
    /** Information about whether to notify the customer about the decline and the message to send. */
    participantNotification?: ParticipantNotification;
    /** Whether this booking overlaps with another existing confirmed booking. */
    doubleBooked?: boolean | null;
    /** ID of the decline initiator. */
    initiatedBy?: IdentificationData;
    /** The previous status of the booking. */
    previousStatus?: BookingStatus;
    /** The previous payment status of the booking. */
    previousPaymentStatus?: PaymentStatus;
    /**
     * Information about whether specific procedures of the standard Wix Bookings
     * declining flow are changed. For example, whether to issue a refund.
     */
    flowControlSettings?: DeclineBookingFlowControlSettings;
}
export interface CancelBookingRequest {
    /**
     * ID of the booking to cancel.
     * @format GUID
     */
    bookingId: string;
    /**
     * Information about whether to notify the customer about the cancellation and
     * the message to send.
     */
    participantNotification?: ParticipantNotification;
    /**
     * Whether to ignore specific standard procedures of the Wix Bookings flow.
     * For example, whether to allow a cancellation even though the service's
     * policy doesn't allow it.
     */
    flowControlSettings?: CancelBookingFlowControlSettings;
    /**
     * Revision number, which increments by 1 each time the booking is updated.
     *
     * To prevent conflicting changes, the current revision must be specified when
     * managing the booking.
     */
    revision: string | null;
}
export interface CancelBookingFlowControlSettings {
    /**
     * Whether the cancellation policy applies when canceling the booking.
     *
     * When passing `false`, you can only cancel a booking if the cancellation policy allows it.
     * Default: `false`.
     */
    ignoreCancellationPolicy?: boolean | null;
    /**
     * Whether to issue a refund when canceling the booking.
     *
     * The refund will be issued only if the booking is refundable.
     * Currently, a booking is considered refundable when it was paid by membership.
     * If you specify `true`, the booking flow control settings is set to include a refund.
     * If `false` is specified or the field remains empty,
     * the booking flow control settings are set without refund.
     *
     * Default: `false`.
     */
    withRefund?: boolean | null;
}
export interface CancelBookingResponse {
    /** Canceled booking. */
    booking?: Booking;
}
export interface BookingCanceled {
    /** The canceled booking object. */
    booking?: Booking;
    /** Information about whether to notify the customer about the cancellation and the message to send. */
    participantNotification?: ParticipantNotification;
    /**
     * Information about whether specific procedures of the standard Wix Bookings
     * cancellation flow are changed. For example, whether you can cancel
     * a booking even though the cancellation policy doesn't allow it or whether
     * to issue a refund.
     */
    flowControlSettings?: CancelBookingFlowControlSettings;
    /** ID of the cancellation initiator. */
    initiatedBy?: IdentificationData;
    /** The previous status of the booking. */
    previousStatus?: BookingStatus;
}
export interface UpdateNumberOfParticipantsRequest extends UpdateNumberOfParticipantsRequestParticipantsInfoOneOf {
    /**
     * Total number of participants. Specify when all participants have booked the
     * same service variant.
     */
    totalParticipants?: number;
    /**
     * Information about the service choices the participants have booked. Specify
     * when not all participants have booked the same service variant.
     */
    participantsChoices?: ParticipantChoices;
    /**
     * ID of the booking to update the number of participants for.
     * @format GUID
     */
    bookingId: string;
    /**
     * Revision number, which increments by 1 each time the booking is updated.
     *
     * To prevent conflicting changes, the current revision must be specified
     * when updating the booking.
     */
    revision: string | null;
}
/** @oneof */
export interface UpdateNumberOfParticipantsRequestParticipantsInfoOneOf {
    /**
     * Total number of participants. Specify when all participants have booked the
     * same service variant.
     */
    totalParticipants?: number;
    /**
     * Information about the service choices the participants have booked. Specify
     * when not all participants have booked the same service variant.
     */
    participantsChoices?: ParticipantChoices;
}
export interface UpdateNumberOfParticipantsResponse {
    /** Updated booking. */
    booking?: Booking;
}
export interface NumberOfParticipantsUpdated extends NumberOfParticipantsUpdatedPreviousParticipantsInfoOneOf {
    /**
     * The previous total number of participants. Available only when the booking includes
     * a single service variant.
     */
    previousTotalParticipants?: number;
    /**
     * Information about the previous booked service choices and participants.
     * Available only when the booking includes multiple service variants.
     */
    previousParticipantsChoices?: ParticipantChoices;
    /** The updated booking object. */
    booking?: Booking;
    /** ID of the participant number update initiator. */
    initiatedBy?: IdentificationData;
}
/** @oneof */
export interface NumberOfParticipantsUpdatedPreviousParticipantsInfoOneOf {
    /**
     * The previous total number of participants. Available only when the booking includes
     * a single service variant.
     */
    previousTotalParticipants?: number;
    /**
     * Information about the previous booked service choices and participants.
     * Available only when the booking includes multiple service variants.
     */
    previousParticipantsChoices?: ParticipantChoices;
}
export interface BulkCalculateAllowedActionsRequest {
    /**
     * The booking IDs for which we want to calculate the allowed actions.
     * @minSize 1
     */
    bookingIds?: string[] | null;
}
export interface BulkCalculateAllowedActionsResponse {
    results?: BulkCalculateAllowedActionsResult[];
    /** Total number of successes and failures for Bulk Calculate Allowed Actions. */
    bulkActionMetadata?: BulkActionMetadata;
}
export interface BulkCalculateAllowedActionsResult {
    /** Metadata for the booking. Including ID, index in the provided sequence, success status, and error. */
    itemMetadata?: ItemMetadata;
    /** Booking entity. */
    item?: AllowedActions;
}
/** Possible actions allowed for the booking. */
export interface AllowedActions {
    /** Whether canceling the booking is allowed. */
    cancel?: boolean;
    /** Whether rescheduling the booking is allowed. */
    reschedule?: boolean;
}
export interface GetSlotAvailabilityRequest {
    /** The slot for which the availability is checked. */
    slot?: V2Slot;
    /** The timezone for which availability is to be calculated. */
    timezone?: string | null;
}
export interface GetSlotAvailabilityResponse {
    availability?: SlotAvailability;
    bookingPolicySettings?: BookingPolicySettings;
}
export interface SlotAvailability {
    /** Identifier for the underlying session when the session is a single session or generated from a recurring session. Required. */
    slot?: V2Slot;
    /** Whether this available slot is bookable. */
    bookable?: boolean;
    /**
     * Total number of spots for this availability.
     * For example, for a class of 10 spots with 3 spots booked, `totalSpots` is 10 and `openSpots` is 7.
     */
    totalSpots?: number | null;
    /**
     * Number of open spots for this availability.
     * For appointments, if there are existing bookings with overlapping time, service & resource, `openSpots` is 0. Otherwise, `openSpots` is 1.
     */
    openSpots?: number | null;
    /** An object describing the slot's waiting list and its occupancy. */
    waitingList?: WaitingList;
    /** Indicators for booking policy violations for the slot. */
    bookingPolicyViolations?: BookingPolicyViolations;
    /** Indicates whether this slot is locked. */
    locked?: boolean | null;
}
export interface WaitingList {
    /**
     * Total number of spots and open spots for this waiting list.
     * For example, a Yoga class of 10 waiting list spots with 3 registered on the waiting list has `total_spots`: 10 and `open_spots`: 7.
     */
    totalSpots?: number | null;
    openSpots?: number | null;
}
export interface BookingPolicyViolations {
    /** Booking policy violation: Too early to book this slot. */
    tooEarlyToBook?: boolean | null;
    /** Booking policy violation: Too late to book this slot. */
    tooLateToBook?: boolean | null;
    /** Booking policy violation: Online booking is disabled for this slot. */
    bookOnlineDisabled?: boolean | null;
}
export interface BookingPolicySettings {
    /** Booking policy settings for a given slot or schedule. */
    maxParticipantsPerBooking?: number | null;
}
export interface AvailableResources {
    /**
     * Resource type ID.
     * @format GUID
     */
    resourceTypeId?: string | null;
    /**
     * Available resources for the slot.
     * `maxSize` is defined by 135 staff members + 3 resource types and 50 resources per type.
     * `Availability-2` currently has no `maxSize` defined.
     * @format GUID
     * @maxSize 275
     */
    resourceIds?: string[];
}
export interface GetScheduleAvailabilityRequest {
    /**
     * ID of the schedule for which to check availability.
     * @format GUID
     */
    scheduleId?: string;
}
export interface GetScheduleAvailabilityResponse {
    availability?: ScheduleAvailability;
    bookingPolicySettings?: BookingPolicySettings;
}
export interface ScheduleAvailability {
    /** Total number of spots. */
    totalSpots?: number | null;
    /** Number of remaining open spots. */
    openSpots?: number | null;
    /** Indicators of booking policy violations for the specified schedule. */
    bookingPolicyViolations?: BookingPolicyViolations;
}
export interface MarkBookingAsPendingRequest {
    /**
     * ID of the booking to mark as `PENDING`.
     * @format GUID
     */
    bookingId?: string;
    /**
     * Revision number, which increments by 1 each time the booking is updated.
     *
     * To prevent conflicting changes, the current revision must be specified when
     * managing the booking.
     */
    revision?: string | null;
    /**
     * Information about whether to notify the customer and
     * the message to send.
     */
    participantNotification?: ParticipantNotification;
    /**
     * Whether to send an SMS reminder to the customer 24 hours before the
     * session starts. The phone number is taken from `contactDetails.phone`.
     */
    sendSmsReminder?: boolean | null;
    /** Payment status to set for the booking. */
    paymentStatus?: PaymentStatus;
    /** Whether this booking has a conflict with at least 1 other confirmed booking. */
    doubleBooked?: boolean | null;
    /**
     * Whether to ignore specific standard procedures of the Wix Bookings flow.
     * For example, whether to check availability before updating the status.
     */
    flowControlSettings?: MarkBookingAsPendingFlowControlSettings;
}
export interface MarkBookingAsPendingFlowControlSettings {
    /**
     * Whether to check for double bookings before updating the booking as pending.
     *
     * When passing `false`, a booking is only updated with status `PENDING`.
     * Default: `false`.
     */
    checkAvailabilityValidation?: boolean;
    /**
     * Whether to validate that the booking to be marked as pending has a `booking.slot.serviceId`
     * of a pending approval service.
     *
     * Default: `false`.
     */
    skipPendingApprovalServiceValidation?: boolean;
}
export interface MarkBookingAsPendingResponse {
    /** Updated booking. */
    booking?: Booking;
}
export interface BookingMarkedAsPending {
    /** The booking object that was marked as pending. */
    booking?: Booking;
    /** Information about whether to notify the customer upon manual confirmation of the pending booking and the message to send. */
    participantNotification?: ParticipantNotification;
    /**
     * Whether to send an SMS reminder to the customer 24 hours before the session starts.
     * The phone number is taken from `contactDetails.phone`.
     */
    sendSmsReminder?: boolean | null;
    /** Whether this booking overlaps with another existing confirmed booking. */
    doubleBooked?: boolean | null;
    /** ID of the mark as pending initiator. */
    initiatedBy?: IdentificationData;
    /** The previous status of the booking. */
    previousStatus?: BookingStatus;
    /** The previous payment status of the booking. */
    previousPaymentStatus?: PaymentStatus;
}
export interface MigrationCheckIfClashesWithBlockedTimeRequest {
    msidAndBookingIds?: MsidAndBookingId[];
}
export interface MsidAndBookingId {
    msid?: string;
    bookingId?: string;
}
export interface MigrationCheckIfClashesWithBlockedTimeResponse {
    clashes?: Clash[];
}
export interface Clash {
    msid?: string;
    bookingId?: string;
    sessionId?: string;
    resourceName?: string;
    contactName?: string;
}
export interface CountBookingsRequest {
    /**
     * Filter object in the following format:
     * `"filter" : {
     * "fieldName1": "value1",
     * "fieldName2":{"$operator":"value2"}
     * }`
     * Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`, `$contains`
     */
    filter?: Record<string, any> | null;
}
export interface CountBookingsResponse {
    /** Number of bookings matching the specified filter. */
    count?: number;
}
export interface CreateMultiServiceBookingRequest {
    /**
     * Single-service bookings to combine in a multi-service booking.
     * @minSize 2
     * @maxSize 8
     */
    bookings: Booking[];
    /**
     * Information about whether to notify the customer and
     * the message to send.
     */
    participantNotification?: ParticipantNotification;
    /**
     * Whether to send an SMS reminder to the customer 24 hours before the
     * session starts. The phone number is taken from `contactDetails.phone`.
     *
     * Default: `true`
     */
    sendSmsReminder?: boolean | null;
    /**
     * Whether to ignore specific standard procedures of the Wix Bookings flow.
     * For example, whether to check availability before updating the status.
     */
    flowControlSettings?: CreateBookingFlowControlSettings;
    /** Whether to return the created single-service bookings. */
    returnFullEntity?: boolean;
    /** Multi service booking type. */
    multiServiceBookingType?: MultiServiceBookingType;
}
export interface CreateMultiServiceBookingResponse {
    /**
     * Created multi service booking.
     * Contains the booking results in the same order as specified in the request.
     */
    multiServiceBooking?: MultiServiceBooking;
}
export interface MultiServiceBooking {
    /**
     * Multi-service booking ID.
     * @format GUID
     */
    _id?: string | null;
    /** The created bookings that are part of the multi-service booking. */
    bookings?: BookingResult[];
}
export interface BookingResult {
    /**
     * Booking ID.
     * @format GUID
     */
    bookingId?: string | null;
    /** Booking entity. */
    booking?: Booking;
}
export interface RescheduleMultiServiceBookingRequest {
    /**
     * ID of the multi service booking to reschedule.
     * @format GUID
     */
    multiServiceBookingId: string | null;
    /** Information about the single-service bookings to reschedule. */
    rescheduleBookingsInfo: RescheduleBookingInfo[];
    /**
     * Information about whether to notify the customer and
     * the message to send.
     */
    participantNotification?: ParticipantNotification;
    /**
     * Information about whether specific procedures of the standard Wix Bookings
     * rescheduling flow are changed. For example, whether the availability of
     * the new slot is checked before rescheduling the booking or if you can
     * reschedule the booking even though the rescheduling policy doesn't allow it.
     */
    flowControlSettings?: RescheduleBookingFlowControlSettings;
    /** Whether to return the rescheduled bookings entities. */
    returnFullEntity?: boolean;
}
export interface RescheduleBookingInfo extends RescheduleBookingInfoParticipantsInfoOneOf {
    /**
     * Total number of participants. Available only for services with variants.
     * Specify when all participants book the same variant.
     */
    totalParticipants?: number;
    /**
     * Information about the service choices to book. Available only for services with
     * variants.
     * Specify when not all participants book the same variant.
     */
    participantsChoices?: ParticipantChoices;
    /**
     * ID of the booking to reschedule.
     * @format GUID
     */
    bookingId?: string | null;
    /** Information about the new slot. */
    slot?: V2Slot;
    /**
     * Revision number, which increments by 1 each time the booking is updated.
     * To prevent conflicting changes, the current revision must be specified when
     * managing the booking.
     */
    revision?: string | null;
}
/** @oneof */
export interface RescheduleBookingInfoParticipantsInfoOneOf {
    /**
     * Total number of participants. Available only for services with variants.
     * Specify when all participants book the same variant.
     */
    totalParticipants?: number;
    /**
     * Information about the service choices to book. Available only for services with
     * variants.
     * Specify when not all participants book the same variant.
     */
    participantsChoices?: ParticipantChoices;
}
export interface RescheduleMultiServiceBookingResponse {
    /** Rescheduled multi-service booking. */
    multiServiceBooking?: MultiServiceBooking;
}
export interface GetMultiServiceBookingAvailabilityRequest {
    /**
     * ID of the multi-service booking to retrieve.
     * @format GUID
     */
    multiServiceBookingId: string | null;
}
export interface GetMultiServiceBookingAvailabilityResponse {
    /** Whether all contained single-service bookings are bookable. */
    bookable?: boolean;
    /** Total number of spots. */
    totalCapacity?: number | null;
    /** Number of open spots. */
    remainingCapacity?: number | null;
    /** Indicators for policy violations of the multi service booking. */
    policyViolations?: BookingPolicyViolations;
    /** Multi-service booking policy settings. */
    policySettings?: BookingPolicySettings;
    /** Info of the bookings this availability was calculated for. */
    multiServiceBookingInfo?: GetMultiServiceBookingAvailabilityResponseBookingInfo[];
}
export interface GetMultiServiceBookingAvailabilityResponseBookingInfo {
    /**
     * Booking ID.
     * @format GUID
     */
    bookingId?: string | null;
}
export interface CancelMultiServiceBookingRequest {
    /**
     * ID of the multi-service booking to cancel.
     * @format GUID
     */
    multiServiceBookingId: string | null;
    /**
     * Information about whether to notify the customer and
     * the message to send.
     */
    participantNotification?: ParticipantNotification;
    /**
     * Information about whether specific procedures of the standard Wix Bookings
     * cancellation flow are changed. For example, whether you can cancel
     * a booking even though the cancellation policy doesn't allow it or whether
     * to issue a refund.
     */
    flowControlSettings?: CancelBookingFlowControlSettings;
    /** Whether to return the canceled single-service bookings. */
    returnFullEntity?: boolean;
}
export interface CancelMultiServiceBookingResponse {
    /** Canceled multi-service booking. */
    multiServiceBooking?: MultiServiceBooking;
}
export interface MarkMultiServiceBookingAsPendingRequest {
    /**
     * ID of the multi-service booking to mark as `PENDING`.
     * @format GUID
     */
    multiServiceBookingId: string | null;
    /** Information about the single-service bookings to mark as `PENDING`. */
    markAsPendingBookingsInfo?: BookingInfo[];
    /**
     * Information about whether to notify the customer and
     * the message to send.
     */
    participantNotification?: ParticipantNotification;
    /**
     * Whether to send an SMS reminder to the customer 24 hours before the
     * session starts. The phone number is taken from `contactDetails.phone`.
     *
     * Default: `true`
     */
    sendSmsReminder?: boolean | null;
    /** Whether this booking has a conflict with at least 1 other confirmed booking. */
    doubleBooked?: boolean | null;
    /** Whether to return the single-service bookings that were marked as `PENDING`. */
    returnFullEntity?: boolean;
    /**
     * Information about whether specific procedures of the standard Wix Bookings
     * creation flow are changed. For example, whether the availability is checked
     * before updating the booking.
     */
    flowControlSettings?: MarkBookingAsPendingFlowControlSettings;
}
export interface BookingInfo {
    /**
     * ID of the single-service booking.
     * @format GUID
     */
    bookingId?: string | null;
    /**
     * Revision number, which increments by 1 each time the booking is updated.
     * To prevent conflicting changes, the current revision must be specified when
     * managing the booking.
     */
    revision?: string | null;
    /** Payment status to set for the single-service booking. */
    paymentStatus?: PaymentStatus;
}
export interface MarkMultiServiceBookingAsPendingResponse {
    /** Updated multi-service booking. */
    multiServiceBooking?: MultiServiceBooking;
}
export interface ConfirmMultiServiceBookingRequest {
    /**
     * ID of the multi-service booking to confirm its related bookings.
     * @format GUID
     */
    multiServiceBookingId: string | null;
    /** Information about the single-service bookings to confirm. */
    confirmBookingsInfo?: BookingInfo[];
    /**
     * Information about whether to notify the customer and
     * the message to send.
     */
    participantNotification?: ParticipantNotification;
    /**
     * Whether to send an SMS reminder to the customer 24 hours before the
     * session starts. The phone number is taken from `contactDetails.phone`.
     *
     * Default: `true`
     */
    sendSmsReminder?: boolean | null;
    /** Whether this booking has a conflict with at least 1 other confirmed booking. */
    doubleBooked?: boolean | null;
    /** Whether to return the confirmed single-service bookings. */
    returnFullEntity?: boolean;
    /**
     * Information about whether specific procedures of the standard Wix Bookings
     * confirmation flow are changed. For example, whether the availability is
     * checked before confirming the booking.
     */
    flowControlSettings?: ConfirmBookingFlowControlSettings;
}
export interface ConfirmMultiServiceBookingResponse {
    /** Confirmed multi service booking. */
    multiServiceBooking?: MultiServiceBooking;
}
export interface DeclineMultiServiceBookingRequest {
    /**
     * ID of the multi service booking to decline.
     * @format GUID
     */
    multiServiceBookingId: string | null;
    /** Information about the single-service bookings to decline. */
    declineBookingsInfo?: BookingInfo[];
    /**
     * Information about whether to notify the customer and
     * the message to send.
     */
    participantNotification?: ParticipantNotification;
    /** Whether this booking has a conflict with at least 1 other confirmed booking. */
    doubleBooked?: boolean | null;
    /** Whether to return the declined single-service bookings. */
    returnFullEntity?: boolean;
    /**
     * Information about whether specific procedures of the standard Wix Bookings
     * declining flow are changed. For example, whether to issue a refund.
     */
    flowControlSettings?: DeclineBookingFlowControlSettings;
}
export interface DeclineMultiServiceBookingResponse {
    /** Declined multi-service booking. */
    multiServiceBooking?: MultiServiceBooking;
}
export interface BulkGetMultiServiceBookingAllowedActionsRequest {
    /**
     * IDs of the multi-service bookings to retrieve allowed actions for.
     * @format GUID
     * @minSize 1
     * @maxSize 50
     */
    multiServiceBookingIds: string[] | null;
}
export interface BulkGetMultiServiceBookingAllowedActionsResponse {
    /**
     * Information about the multi-service bookings that were retrieved.
     * Including their ID, index in the bulk request and whether they were
     * successfully updated.
     */
    results?: BulkCalculateAllowedActionsResult[];
    /** Total number of successes and failures for Bulk Update Bookings. */
    bulkActionMetadata?: BulkActionMetadata;
}
export interface GetMultiServiceBookingRequest {
    /**
     * ID of the multi-service booking.
     * @format GUID
     */
    multiServiceBookingId: string | null;
}
export interface GetMultiServiceBookingResponse {
    /** Retrieved multi-service booking. */
    multiServiceBooking?: MultiServiceBooking;
    /** Details about how many single-service bookings belong to the multi-service booking. */
    metadata?: MultiServiceBookingMetadata;
}
export interface MultiServiceBookingMetadata {
    /**
     * Total number of `CONFIRMED` and `PENDING` single-service bookings belonging
     * to the multi-service booking. The total includes the number of single-service
     * bookings which couldn't be retrieved due to lack of permissions.
     */
    totalNumberOfScheduledBookings?: number | null;
}
export interface AddBookingsToMultiServiceBookingRequest {
    /**
     * ID of the multi-service booking.
     * @format GUID
     */
    multiServiceBookingId: string | null;
    /**
     * List of single-service booking IDs and their revision.
     * @maxSize 8
     */
    bookings: BookingIdAndRevision[];
    /** Whether to return the single-service bookings that were added to the multi-service booking. */
    returnFullEntity?: boolean;
}
export interface BookingIdAndRevision {
    /**
     * ID of the booking.
     * @format GUID
     */
    bookingId?: string | null;
    /**
     * Revision number, which increments by 1 each time the booking is updated.
     * To prevent conflicting changes, the current revision must be specified when
     * managing the booking.
     */
    revision?: string | null;
}
export interface AddBookingsToMultiServiceBookingResponse {
    /** Single-service bookings that were added to the multi-service booking. */
    bookings?: BookingResult[];
}
export interface RemoveBookingsFromMultiServiceBookingRequest {
    /**
     * ID of the multi-service booking.
     * @format GUID
     */
    multiServiceBookingId: string | null;
    /**
     * List of single-service booking IDs and their revision.
     * @maxSize 8
     */
    bookings?: BookingIdAndRevision[];
    /** Whether to return the single-service bookings. */
    returnFullEntity?: boolean;
}
export interface RemoveBookingsFromMultiServiceBookingResponse {
    /** Single-service bookings that were removed from the multi-service booking. */
    bookings?: BookingResult[];
}
interface DurationNonNullableFields {
    minutes: number;
}
interface ServiceChoiceNonNullableFields {
    custom: string;
    duration?: DurationNonNullableFields;
    optionId: string;
}
interface ServiceChoicesNonNullableFields {
    choices: ServiceChoiceNonNullableFields[];
}
interface ParticipantChoicesNonNullableFields {
    serviceChoices: ServiceChoicesNonNullableFields[];
}
interface BookedResourceNonNullableFields {
    _id: string;
}
interface LocationNonNullableFields {
    locationType: LocationType;
}
interface BookedSlotNonNullableFields {
    serviceId: string;
    scheduleId: string;
    resource?: BookedResourceNonNullableFields;
    location?: LocationNonNullableFields;
    additionalResources: BookedResourceNonNullableFields[];
}
interface BookedScheduleNonNullableFields {
    scheduleId: string;
    location?: LocationNonNullableFields;
}
interface BookedEntityNonNullableFields {
    slot?: BookedSlotNonNullableFields;
    schedule?: BookedScheduleNonNullableFields;
}
interface StreetAddressNonNullableFields {
    number: string;
    name: string;
    apt: string;
}
interface SubdivisionNonNullableFields {
    code: string;
    name: string;
}
interface AddressNonNullableFields {
    streetAddress?: StreetAddressNonNullableFields;
    subdivisions: SubdivisionNonNullableFields[];
}
interface ContactDetailsNonNullableFields {
    fullAddress?: AddressNonNullableFields;
}
interface CustomFormFieldNonNullableFields {
    _id: string;
    valueType: ValueType;
}
interface BookingSourceNonNullableFields {
    platform: Platform;
    actor: Actor;
}
interface ParticipantNotificationNonNullableFields {
    notifyParticipants: boolean;
}
interface CommonIdentificationDataNonNullableFields {
    anonymousVisitorId: string;
    memberId: string;
    wixUserId: string;
    appId: string;
    identityType: IdentificationDataIdentityType;
}
interface FlowControlSettingsNonNullableFields {
    ignoreBookingWindow: boolean;
    skipAvailabilityValidation: boolean;
    skipBusinessConfirmation: boolean;
    skipSelectedPaymentOptionValidation: boolean;
}
interface MultiServiceBookingInfoNonNullableFields {
    type: MultiServiceBookingType;
}
interface BookingNonNullableFields {
    totalParticipants: number;
    participantsChoices?: ParticipantChoicesNonNullableFields;
    bookedEntity?: BookedEntityNonNullableFields;
    contactDetails?: ContactDetailsNonNullableFields;
    additionalFields: CustomFormFieldNonNullableFields[];
    status: BookingStatus;
    paymentStatus: PaymentStatus;
    selectedPaymentOption: SelectedPaymentOption;
    bookingSource?: BookingSourceNonNullableFields;
    participantNotification?: ParticipantNotificationNonNullableFields;
    createdBy?: CommonIdentificationDataNonNullableFields;
    flowControlSettings?: FlowControlSettingsNonNullableFields;
    multiServiceBookingInfo?: MultiServiceBookingInfoNonNullableFields;
}
export interface ConfirmOrDeclineBookingResponseNonNullableFields {
    booking?: BookingNonNullableFields;
}
interface ApplicationErrorNonNullableFields {
    code: string;
    description: string;
}
interface ItemMetadataNonNullableFields {
    originalIndex: number;
    success: boolean;
    error?: ApplicationErrorNonNullableFields;
}
interface BulkBookingResultNonNullableFields {
    itemMetadata?: ItemMetadataNonNullableFields;
    item?: BookingNonNullableFields;
}
interface BulkActionMetadataNonNullableFields {
    totalSuccesses: number;
    totalFailures: number;
    undetailedFailures: number;
}
export interface BulkConfirmOrDeclineBookingResponseNonNullableFields {
    results: BulkBookingResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields;
}
export interface CreateBookingResponseNonNullableFields {
    booking?: BookingNonNullableFields;
}
export interface BulkCreateBookingResponseNonNullableFields {
    results: BulkBookingResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields;
}
export interface RescheduleBookingResponseNonNullableFields {
    booking?: BookingNonNullableFields;
}
export interface ConfirmBookingResponseNonNullableFields {
    booking?: BookingNonNullableFields;
}
export interface UpdateExtendedFieldsResponseNonNullableFields {
    namespace: string;
}
export interface DeclineBookingResponseNonNullableFields {
    booking?: BookingNonNullableFields;
}
export interface CancelBookingResponseNonNullableFields {
    booking?: BookingNonNullableFields;
}
export interface UpdateNumberOfParticipantsResponseNonNullableFields {
    booking?: BookingNonNullableFields;
}
interface BookingResultNonNullableFields {
    booking?: BookingNonNullableFields;
}
export interface MultiServiceBookingNonNullableFields {
    bookings: BookingResultNonNullableFields[];
}
export interface CreateMultiServiceBookingResponseNonNullableFields {
    multiServiceBooking?: MultiServiceBookingNonNullableFields;
}
export interface RescheduleMultiServiceBookingResponseNonNullableFields {
    multiServiceBooking?: MultiServiceBookingNonNullableFields;
}
export interface GetMultiServiceBookingAvailabilityResponseNonNullableFields {
    bookable: boolean;
}
export interface CancelMultiServiceBookingResponseNonNullableFields {
    multiServiceBooking?: MultiServiceBookingNonNullableFields;
}
export interface MarkMultiServiceBookingAsPendingResponseNonNullableFields {
    multiServiceBooking?: MultiServiceBookingNonNullableFields;
}
export interface ConfirmMultiServiceBookingResponseNonNullableFields {
    multiServiceBooking?: MultiServiceBookingNonNullableFields;
}
export interface DeclineMultiServiceBookingResponseNonNullableFields {
    multiServiceBooking?: MultiServiceBookingNonNullableFields;
}
interface AllowedActionsNonNullableFields {
    cancel: boolean;
    reschedule: boolean;
    bookAnother: boolean;
}
interface BulkCalculateAllowedActionsResultNonNullableFields {
    itemMetadata?: ItemMetadataNonNullableFields;
    item?: AllowedActionsNonNullableFields;
}
export interface BulkGetMultiServiceBookingAllowedActionsResponseNonNullableFields {
    results: BulkCalculateAllowedActionsResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields;
}
export interface GetMultiServiceBookingResponseNonNullableFields {
    multiServiceBooking?: MultiServiceBookingNonNullableFields;
}
export interface AddBookingsToMultiServiceBookingResponseNonNullableFields {
    bookings: BookingResultNonNullableFields[];
}
export interface RemoveBookingsFromMultiServiceBookingResponseNonNullableFields {
    bookings: BookingResultNonNullableFields[];
}
export interface BaseEventMetadata {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: WebhooksIdentificationData;
}
export interface EventMetadata extends BaseEventMetadata {
    /**
     * Unique event ID.
     * Allows clients to ignore duplicate webhooks.
     */
    _id?: string;
    /**
     * Assumes actions are also always typed to an entity_type
     * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
     */
    entityFqdn?: string;
    /**
     * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
     * This is although the created/updated/deleted notion is duplication of the oneof types
     * Example: created/updated/deleted/started/completed/email_opened
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number defining the order of updates to the underlying entity.
     * For example, given that some entity was updated at 16:00 and than again at 16:01,
     * it is guaranteed that the sequence number of the second update is strictly higher than the first.
     * As the consumer, you can use this value to ensure that you handle messages in the correct order.
     * To do so, you will need to persist this number on your end, and compare the sequence number from the
     * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
     */
    entityEventSequence?: string | null;
}
export interface BookingCanceledEnvelope {
    data: BookingCanceled;
    metadata: EventMetadata;
}
/**
 * Triggered when a booking is canceled.
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Read Bookings - Including Participants
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-SENSITIVE
 * @permissionScope Read Bookings - all read permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.READ-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @permissionScope Read bookings calendar - including participants
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-CALENDAR-WITH-PARTICIPANTS
 * @permissionId BOOKINGS.BOOKING_READ
 * @webhook
 * @eventType wix.bookings.v2.booking_canceled
 * @serviceIdentifier com.wixpress.bookings.bookings.v2.Bookings
 * @slug canceled
 */
export declare function onBookingCanceled(handler: (event: BookingCanceledEnvelope) => void | Promise<void>): void;
export interface BookingConfirmedEnvelope {
    data: BookingConfirmed;
    metadata: EventMetadata;
}
/**
 * Triggered when a booking is confirmed.
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Read Bookings - Including Participants
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-SENSITIVE
 * @permissionScope Read Bookings - all read permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.READ-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @permissionScope Read bookings calendar - including participants
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-CALENDAR-WITH-PARTICIPANTS
 * @permissionId BOOKINGS.BOOKING_READ
 * @webhook
 * @eventType wix.bookings.v2.booking_confirmed
 * @serviceIdentifier com.wixpress.bookings.bookings.v2.Bookings
 * @slug confirmed
 */
export declare function onBookingConfirmed(handler: (event: BookingConfirmedEnvelope) => void | Promise<void>): void;
export interface BookingCreatedEnvelope {
    entity: Booking;
    metadata: EventMetadata;
}
/**
 * Triggered when a booking is created.
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Read Bookings - Including Participants
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-SENSITIVE
 * @permissionScope Read Bookings - all read permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.READ-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Read Bookings - Including Participants
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-SENSITIVE
 * @permissionScope Read Bookings - all read permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.READ-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @permissionScope Read bookings calendar - including participants
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-CALENDAR-WITH-PARTICIPANTS
 * @permissionId BOOKINGS.READ_BOOKINGS
 * @permissionId BOOKINGS.BOOKING_READ
 * @webhook
 * @eventType wix.bookings.v2.booking_created
 * @serviceIdentifier com.wixpress.bookings.bookings.v2.Bookings
 * @slug created
 */
export declare function onBookingCreated(handler: (event: BookingCreatedEnvelope) => void | Promise<void>): void;
export interface BookingDeclinedEnvelope {
    data: BookingDeclined;
    metadata: EventMetadata;
}
/**
 * Triggered when a booking is declined.
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Read Bookings - Including Participants
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-SENSITIVE
 * @permissionScope Read Bookings - all read permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.READ-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @permissionScope Read bookings calendar - including participants
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-CALENDAR-WITH-PARTICIPANTS
 * @permissionId BOOKINGS.BOOKING_READ
 * @webhook
 * @eventType wix.bookings.v2.booking_declined
 * @serviceIdentifier com.wixpress.bookings.bookings.v2.Bookings
 * @slug declined
 */
export declare function onBookingDeclined(handler: (event: BookingDeclinedEnvelope) => void | Promise<void>): void;
export interface BookingNumberOfParticipantsUpdatedEnvelope {
    data: NumberOfParticipantsUpdated;
    metadata: EventMetadata;
}
/**
 * Triggered when the number of participants is updated.
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Read Bookings - Including Participants
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-SENSITIVE
 * @permissionScope Read Bookings - all read permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.READ-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @permissionScope Read bookings calendar - including participants
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-CALENDAR-WITH-PARTICIPANTS
 * @permissionId BOOKINGS.BOOKING_READ
 * @webhook
 * @eventType wix.bookings.v2.booking_number_of_participants_updated
 * @serviceIdentifier com.wixpress.bookings.bookings.v2.Bookings
 * @slug number_of_participants_updated
 */
export declare function onBookingNumberOfParticipantsUpdated(handler: (event: BookingNumberOfParticipantsUpdatedEnvelope) => void | Promise<void>): void;
export interface BookingRescheduledEnvelope {
    data: BookingRescheduled;
    metadata: EventMetadata;
}
/**
 * Triggered when a booking is rescheduled.
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Read Bookings - Including Participants
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-SENSITIVE
 * @permissionScope Read Bookings - all read permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.READ-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @permissionScope Read bookings calendar - including participants
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-CALENDAR-WITH-PARTICIPANTS
 * @permissionId BOOKINGS.BOOKING_READ
 * @webhook
 * @eventType wix.bookings.v2.booking_rescheduled
 * @serviceIdentifier com.wixpress.bookings.bookings.v2.Bookings
 * @slug rescheduled
 */
export declare function onBookingRescheduled(handler: (event: BookingRescheduledEnvelope) => void | Promise<void>): void;
export interface BookingUpdatedEnvelope {
    entity: Booking;
    metadata: EventMetadata;
}
/**
 * Triggered when a booked schedule is updated.
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Read Bookings - Including Participants
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-SENSITIVE
 * @permissionScope Read Bookings - all read permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.READ-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Read Bookings - Including Participants
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-SENSITIVE
 * @permissionScope Read Bookings - all read permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.READ-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @permissionScope Read bookings calendar - including participants
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-CALENDAR-WITH-PARTICIPANTS
 * @permissionId BOOKINGS.READ_BOOKINGS
 * @permissionId BOOKINGS.BOOKING_READ
 * @webhook
 * @eventType wix.bookings.v2.booking_updated
 * @serviceIdentifier com.wixpress.bookings.bookings.v2.Bookings
 * @slug updated
 */
export declare function onBookingUpdated(handler: (event: BookingUpdatedEnvelope) => void | Promise<void>): void;
/**
 * Updates the booking `status` to `CONFIRMED`, `PENDING`, or `DECLINED` based
 * on the `paymentStatus` you provide, double booking conflicts, and whether
 * the service requires business approval.
 *
 * ## eCommerce checkout restriction
 *
 * Call this method only when using a custom checkout page. Don't
 * call it when using a *Wix eCommerce checkout*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/ecom/orders/setup) | [REST](https://dev.wix.com/docs/rest/business-solutions/e-commerce/checkout/introduction)).
 * In such cases, Wix automatically updates the booking status based on
 * the `paymentStatus` of the corresponding *Wix eCommerce order*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/ecom/checkout/setup) | [REST](https://dev.wix.com/docs/rest/business-solutions/e-commerce/orders/introduction)).
 *
 * ## New booking status
 *
 * The booking `status` is set to `DECLINED` if both of the following conditions
 * are met:
 * + You provide `UNDEFINED`, `NOT_PAID`, `REFUNDED`, or `EXEMPT` as payment status.
 * + There is a double booking conflict.
 *
 * If only one or none of these conditions is met, `status` is set to `PENDING`
 * or `CONFIRMED` depending on whether the service requires business approval.
 *
 * ## Double bookings
 *
 * If there is a double booking conflict, but the booking has already been at least
 * partially paid, the method still marks the booking as `PENDING` or `CONFIRMED`.
 * Then, it also sets `doubleBooked` to `true`.
 *
 * ## Admin overwrites
 *
 * There are small but important differences in confirmation behavior if the
 * booking was created with special `flowControlSettings`:
 * + If the booking's `flowControlSettings.skipAvailabilityValidation` was set to
 * `true`, the booking is never declined regardless of double booking conflicts.
 * Instead, it's marked `CONFIRMED` or `PENDING`, depending on whether the
 * service requires business approval.
 * + If the booking's `flowControlSettings.skipBusinessConfirmation` was set to
 * `true`, the booking skips `PENDING` status and is marked `CONFIRMED`
 * immediately.
 * @param bookingId - ID of the booking to confirm or decline.
 * @public
 * @requiredField bookingId
 * @permissionId BOOKINGS.BOOKING_CONFIRM_OR_DECLINE
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @fqn com.wixpress.bookings.confirmator.v2.Confirmator.ConfirmOrDeclineBooking
 */
export declare function confirmOrDeclineBooking(bookingId: string, options?: ConfirmOrDeclineBookingOptions): Promise<ConfirmOrDeclineBookingResponse & ConfirmOrDeclineBookingResponseNonNullableFields>;
export interface ConfirmOrDeclineBookingOptions {
    /**
     * Current payment status of the booking when using a custom checkout page and
     * not the *eCommerce checkout*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/ecom/checkout/setup) | [REST](https://dev.wix.com/docs/rest/business-solutions/e-commerce/checkout/introduction)).
     *
     * The booking is declined if there is a double booking conflict and you provide
     * one of these payment statuses: `UNDEFINED`, `NOT_PAID`, `REFUNDED`, or `EXEMPT`.
     */
    paymentStatus?: PaymentStatus;
}
/**
 * Confirms or declines up to 300 bookings.
 *
 *
 * See *Confirm Or Decline Booking*
 * ([SDK](https://dev.wix.com/docs/velo/api-reference/wix-bookings-v2/bookings/confirm-or-decline-booking) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/bookings/bookings-writer-v2/confirm-or-decline-booking))
 * for details about when a booking is confirmed or declined.
 * @param details - Bookings to confirm or decline.
 * @public
 * @documentationMaturity preview
 * @requiredField details
 * @requiredField details.bookingId
 * @permissionId BOOKINGS.BOOKING_CONFIRM_OR_DECLINE
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @fqn com.wixpress.bookings.confirmator.v2.Confirmator.BulkConfirmOrDeclineBooking
 */
export declare function bulkConfirmOrDeclineBooking(details: BulkConfirmOrDeclineBookingRequestBookingDetails[], options?: BulkConfirmOrDeclineBookingOptions): Promise<BulkConfirmOrDeclineBookingResponse & BulkConfirmOrDeclineBookingResponseNonNullableFields>;
export interface BulkConfirmOrDeclineBookingOptions {
    /** Whether to return the confirmed or declined booking objects. */
    returnEntity?: boolean;
}
/**
 * Creates a booking.
 *
 *
 * ## Appointment booking
 *
 * For appointment-based services, specify the relevant `slot` in
 * `bookedEntity.slot`. We recommend specifying the complete
 * `availabilityEntries.slot` returned in *Query Availability*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/availability-calendar/query-availability) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/time-slots/availability-calendar/query-availability))
 * in your call's request to avoid failed calls due to unavailability.
 *
 * ## Class session booking
 *
 * For class services, specify the relevant *event ID*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/calendar/events/introduction) | [REST](https://dev.wix.com/docs/rest/business-management/calendar/events-v3/introduction))
 * as `bookedEntity.slot.eventId`.
 * We recommend retrieving the event ID from *Query Availability's*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/availability-calendar/query-availability) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/time-slots/availability-calendar/query-availability))
 * `availabilityEntries.slot.eventId` to avoid failed calls due to unavailability.
 * Specifying an event ID leads to automatic calculations of `slot.startDate`, `slot.endDate`,
 * `slot.timezone`, `slot.resource`, and `slot.location`. All manually specified
 * values are overridden.
 *
 * ## Course booking
 *
 * For course services, specify the course's schedule ID in `bookedEntity.schedule.scheduleId`.
 * We recommend following [this sample flow](https://dev.wix.com/docs/rest/business-solutions/bookings/sample-booking-flows#book-a-course)
 * to minimize failed calls due to unavailability.
 *
 * ## Related resources
 *
 * Specifying a `resource` triggers an availability check, resulting in a failed
 * call if the resource is unavailable. Omitting a resource allows Wix Bookings
 * to assign a resource belonging to the relevant type randomly when the merchant
 * confirms the booking.
 *
 * ## Participant information
 *
 * You must specify either `participantsChoices` or `totalParticipants`.
 * The call fails if the specified `participantsChoices` aren't among the supported
 * _service options and variants_
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/service-options-and-variants/introduction) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/service-options-and-variants/introduction)).
 *
 * ## Notify customers
 *
 * You can specify a `participantNotification.message` for the customer that's send
 * immediately. Ensure `participantNotification.notifyParticipants` is set to `true`
 * to send the message.
 *
 * If you specify `{"sendSmsReminder": true}`, the customer receives an SMS 24 hours
 * before the session starts. The phone number is taken from `contactDetails.phone`.
 *
 * ## Booking status
 *
 * Bookings default to the `CREATED` status, not affecting the business calendar
 * or resource availability. You can specify a different status when the calling
 * [identity](https://dev.wix.com/docs/build-apps/develop-your-app/access/about-identities)
 * has `Manage Bookings` permissions.
 *
 * ## Payment options
 *
 * The specified `selectedPaymentOption` indicates how the customer intends to
 * pay, allowing for later changes to a different method supported by the service.
 *
 * ## Payment status
 *
 * A booking is initially created with `{"paymentStatus": "UNDEFINED"}` regardless
 * of the payment status specified in Create Booking. If a customer uses an
 * _eCommerce checkout_
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/ecom/orders/setup) | [REST](https://dev.wix.com/docs/rest/business-solutions/e-commerce/checkout/introduction)),
 * Wix Bookings automatically syncs the booking's payment status from
 * the corresponding *eCommerce order*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/ecom/checkout/setup) | [REST](https://dev.wix.com/docs/rest/business-solutions/e-commerce/orders/introduction)).
 *
 * If a booking doesn't have a corresponding eCommerce order, for example, since
 * the customer didn't use the eCommerce checkout, you can update the booking's
 * payment status with *Confirm Or Decline Booking*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/bookings/confirm-or-decline-booking) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/bookings/bookings-writer-v2/confirm-or-decline-booking)).
 *
 * ## Booking form data
 *
 * When customers sign up for a service, they must fill out the booking form.
 * To create a booking with a completed booking form, specify the relevant data in
 * `formSubmission`. Ensure the values of the corresponding fields in
 * `booking.contactDetails` and `formSubmission` are identical. If these values
 * don't match, Create Booking fails. Therefore, we recommend specifying
 * only `booking.contactDetails.contactId` when providing `formSubmission`.
 *
 * ## Admin overwrites
 *
 * There are small but important differences when you specify special
 * `flowControlSettings`:
 *
 * - `{"skipAvailabilityValidation": true}`: The call succeeds
 * regardless of availability. If you don't specify any resource, the call
 * succeeds even if no resource of the relevant type is available.
 * - `{"skipBusinessConfirmation": true}`: Automatically confirms `PENDING`
 * bookings that require manual confirmation.
 * - `{"skipSelectedPaymentOptionValidation": true}`: Allows customers to pay
 * with payment methods that aren't supported for the service.
 *
 * When using special `flowControlSettings`, ensure you have sufficient
 * permissions. If you encounter failed calls due to insufficient permissions,
 * consider the following options:
 *
 * - **App developers** can use a higher
 * [permission](https://dev.wix.com/docs/build-apps/develop-your-app/access/authorization/about-permissions),
 * such as `MANAGE BOOKINGS - ALL PERMISSIONS`.
 * - **Site developers** can utilize
 * [elevation](https://dev.wix.com/docs/develop-websites/articles/coding-with-velo/authorization/elevation).
 *
 * Granting additional permissions and using elevation permits method calls that
 * would typically fail due to authorization checks. Therefore, you should use
 * them intentionally and securely.
 * @param booking - The booking to create.
 * @public
 * @requiredField booking
 * @requiredField booking.additionalFields._id
 * @requiredField booking.bookedEntity
 * @requiredField booking.bookedEntity.item
 * @permissionId BOOKINGS.BOOKING_CREATE
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @applicableIdentity VISITOR
 * @fqn com.wixpress.bookings.bookings.v2.Bookings.CreateBooking
 */
export declare function createBooking(booking: Booking, options?: CreateBookingOptions): Promise<CreateBookingResponse & CreateBookingResponseNonNullableFields>;
export interface CreateBookingOptions {
    /**
     * Information about whether to notify the customer and
     * the message to send.
     */
    participantNotification?: ParticipantNotification;
    /**
     * Whether to send an SMS reminder to the customer 24 hours before the
     * session starts. The phone number is taken from `contactDetails.phone`.
     * Default: `true`.
     */
    sendSmsReminder?: boolean | null;
    /**
     * Whether to ignore specific standard procedures of the Wix Bookings flow.
     * For example, whether to check availability when creating a booking.
     */
    flowControlSettings?: CreateBookingFlowControlSettings;
}
/**
 * Creates up to 8 bookings.
 *
 *
 * See *Create Booking*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/bookings/create-booking) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/bookings/bookings-writer-v2/create-booking))
 * for more information.
 *
 * If any of the specified bookings is missing a required field the entire call
 * fails.
 *
 * If you specify 1 or more unavailable bookings, the call succeeds
 * while the unavailable bookings aren't created. Instead, they're counted as
 * failures in the returned `bulkActionMetadata`.
 * @param createBookingsInfo - Bookings to create.
 *
 * Max: 8 bookings
 * @public
 * @requiredField createBookingsInfo
 * @requiredField createBookingsInfo.booking
 * @requiredField createBookingsInfo.booking.additionalFields._id
 * @requiredField createBookingsInfo.booking.bookedEntity
 * @requiredField createBookingsInfo.booking.bookedEntity.item
 * @permissionId BOOKINGS.BOOKING_CREATE
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @applicableIdentity VISITOR
 * @fqn com.wixpress.bookings.bookings.v2.Bookings.BulkCreateBooking
 */
export declare function bulkCreateBooking(createBookingsInfo: CreateBookingInfo[], options?: BulkCreateBookingOptions): Promise<BulkCreateBookingResponse & BulkCreateBookingResponseNonNullableFields>;
export interface BulkCreateBookingOptions {
    /** Whether to return the created bookings. */
    returnFullEntity?: boolean;
}
/**
 * Reschedules an appointment booking to a different slot or a class booking to
 * a different session.
 *
 *
 * ## Course booking limitation
 *
 * You can't reschedule course bookings.
 *
 * ## Appointment sessions
 *
 * For appointments, the old session is removed from the business calendar
 * while a new session is added. We recommend calling *Query Availability*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/availability-calendar/query-availability) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/time-slots/availability-calendar/query-availability))
 * first and specifying the entire retrieved `slot`.
 *
 * ## Class sessions
 *
 * For classes, the new session must be an existing session belonging to the
 * same class. We recommend retrieving `availabilityEntries.slot.eventId`
 * from *Query Availability*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/availability-calendar/query-availability) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/time-slots/availability-calendar/query-availability))
 * to avoid failed Reschedule Booking calls due to unavailability. Specify
 * only `slot.eventId` instead of the entire `slot` object.
 *
 * ## Notify customers
 *
 * You can specify a `participantNotification.message` for the customer. To send
 * the message, you must also specify `participantNotification.notifyParticipants`
 * as `true`.
 *
 * ## Admin overwrites
 *
 * There are small but important differences when you specify special
 * `flowControlSettings`:
 *
 * - `{"ignoreReschedulePolicy": true}`: The call succeeds even if the
 * service's `reschedulePolicy` doesn't allow it.
 * - `{"skipAvailabilityValidation": true}`: The call succeeds even if
 * the specified session, slot, or resource isn't available. If you don't
 * specify any resource, the call succeeds even if no resource of the relevant
 * type is available.
 * - `{"skipBusinessConfirmation": true}`: Any `PENDING` booking is
 * automatically confirmed even if the services requires the merchants's
 * manual confirmation.
 *
 * When using special `flowControlSettings`, ensure you have sufficient
 * permissions. If you encounter failed calls due to insufficient permissions,
 * consider the following options:
 *
 * - **App developers** can use a higher
 * [permission](https://dev.wix.com/docs/build-apps/develop-your-app/access/authorization/about-permissions),
 * such as `MANAGE BOOKINGS - ALL PERMISSIONS`.
 * - **Site developers** can utilize
 * [elevation](https://dev.wix.com/docs/develop-websites/articles/coding-with-velo/authorization/elevation).
 *
 * Granting additional permissions and using elevation permits method calls that
 * would typically fail due to authorization checks. Therefore, you should use
 * them intentionally and securely.
 * @param bookingId - ID of the booking to reschedule.
 * @param slot - New slot of the booking.
 * @public
 * @requiredField bookingId
 * @requiredField options.revision
 * @requiredField slot
 * @param options - An object representing the available options for rescheduling a booking.
 * @permissionId BOOKINGS.BOOKING_RESCHEDULE
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @applicableIdentity MEMBER
 * @fqn com.wixpress.bookings.bookings.v2.Bookings.RescheduleBooking
 */
export declare function rescheduleBooking(bookingId: string, slot: V2Slot, options?: RescheduleBookingOptions): Promise<RescheduleBookingResponse & RescheduleBookingResponseNonNullableFields>;
export interface RescheduleBookingOptions extends RescheduleBookingOptionsParticipantsInfoOneOf {
    /**
     * Revision number, which increments by 1 each time the booking is rescheduled.
     * To prevent conflicting changes, the current revision must be passed when
     * rescheduling the booking.
     */
    revision: string | null;
    /**
     * Information about whether to notify the customer about the rescheduling and
     * the message to send.
     */
    participantNotification?: ParticipantNotification;
    /**
     * Whether to ignore specific standard procedures of the Wix Bookings flow.
     * For example, whether to check availability when rescheduling a booking.
     */
    flowControlSettings?: RescheduleBookingFlowControlSettings;
    /**
     * Total number of participants. Specify when all participants have booked the
     * same service variant.
     */
    totalParticipants?: number;
    /**
     * Information about the service choices to book. Specify when not all
     * participants have booked the same service variant.
     */
    participantsChoices?: ParticipantChoices;
}
/** @oneof */
export interface RescheduleBookingOptionsParticipantsInfoOneOf {
    /**
     * Total number of participants. Specify when all participants have booked the
     * same service variant.
     */
    totalParticipants?: number;
    /**
     * Information about the service choices to book. Specify when not all
     * participants have booked the same service variant.
     */
    participantsChoices?: ParticipantChoices;
}
/**
 * Updates the booking status to `CONFIRMED` and updates the relevant session's
 * `participants.approvalStatus` to `APPROVED` without checking whether the relevant
 * slot or schedule is still available.
 *
 * ## eCommerce checkout restriction
 *
 * Call this method only when using a custom checkout page. Don't
 * call it when using a *Wix eCommerce checkout*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/ecom/orders/setup) | [REST](https://dev.wix.com/docs/rest/business-solutions/e-commerce/checkout/introduction)).
 * In such cases, Wix automatically updates the booking status based on
 * the `paymentStatus` of the corresponding *Wix eCommerce order*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/ecom/checkout/setup) | [REST](https://dev.wix.com/docs/rest/business-solutions/e-commerce/orders/introduction)).
 *
 * ## When to call Confirm Or Decline Booking instead
 *
 * Confirm Booking doesn't check whether a slot or schedule is still available. For
 * these checks you can call *Confirm or Decline Booking*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/bookings/confirm-or-decline-booking) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/bookings/bookings-writer-v2/confirm-or-decline-booking)).
 *
 * ## Original status validation
 *
 * You can only confirm bookings with a status of `PENDING`, `CREATED`, or
 * `WAITING_LIST`.
 *
 * ## Double bookings
 *
 * Confirm Booking doesn't check whether a slot or schedule is still available.
 * You can specify
 *
 * ```json
 * {
 * "flowControlSettings": {
 * "checkAvailabilityValidation": true
 * },
 * "doubleBooked": true
 * }
 * ```
 * to forcefully set the booking's `doubleBooked` flag to `true`, regardless of
 * a potential double booking conflict. You must call with `Manage Bookings`
 * permissions to do so. For the default flow control settings
 * `{"checkAvailabilityValidation": false}`, the specified `doubleBooked` value
 * is ignored.
 *
 * ## Payment status
 *
 * Also updates the booking's `paymentStatus`, if you specify a new payment
 * status.
 *
 * ## Notify customers
 *
 * You can specify a `participantNotification.message` for the customer. To send
 * the message, you must also specify `participantNotification.notifyParticipants`
 * as `true`.
 * @param bookingId - ID of the booking to confirm.
 * @param revision - Revision number, which increments by 1 each time the booking is updated.
 * To prevent conflicting changes, the current revision must be passed when
 * updating the booking.
 * @public
 * @requiredField bookingId
 * @requiredField revision
 * @param options - An object representing the available options for canceling a booking.
 * @permissionId BOOKINGS.BOOKING_CONFIRM
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @fqn com.wixpress.bookings.bookings.v2.Bookings.ConfirmBooking
 */
export declare function confirmBooking(bookingId: string, revision: string | null, options?: ConfirmBookingOptions): Promise<ConfirmBookingResponse & ConfirmBookingResponseNonNullableFields>;
export interface ConfirmBookingOptions {
    /**
     * Information about whether to notify the customer about the confirmation and
     * the message to send.
     */
    participantNotification?: ParticipantNotification;
    /**
     * Whether to send an SMS reminder to the customer 24 hours before the
     * session starts. The phone number is taken from `contactDetails.phone`.
     */
    sendSmsReminder?: boolean | null;
    /** Payment status to set for the booking. */
    paymentStatus?: PaymentStatus;
    /** Whether this booking has a conflict with at least 1 other confirmed booking. */
    doubleBooked?: boolean | null;
    /**
     * Whether to ignore specific standard procedures of the Wix Bookings flow.
     * For example, whether to check availability when confirming a booking.
     */
    flowControlSettings?: ConfirmBookingFlowControlSettings;
}
/**
 * Updates the extended fields for a booking.
 *
 *
 * If you specify an extended field `namespace` that doesn't exist yet, it's
 * created.
 *
 * Learn more about [extended fields](https://dev.wix.com/docs/build-apps/develop-your-app/extensions/backend-extensions/about-backend-extensions#schema-plugin-extensions).
 * @public
 * @requiredField _id
 * @requiredField namespace
 * @requiredField options
 * @requiredField options.namespaceData
 * @param _id - ID of the booking for which to update extended fields.
 * @param namespace - [Namespace](https://dev.wix.com/docs/build-apps/develop-your-app/extensions/backend-extensions/schema-plugins/about-reading-and-writing-schema-plugin-fields#namespaces) of the app for which to update extended fields.
 * @param options - Options for updating the booking's extended fields.
 * @permissionId BOOKINGS.BOOKING_UPDATE_EXTENDED_FIELDS
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @fqn com.wixpress.bookings.bookings.v2.Bookings.UpdateExtendedFields
 */
export declare function updateExtendedFields(_id: string, namespace: string, options: UpdateExtendedFieldsOptions): Promise<UpdateExtendedFieldsResponse & UpdateExtendedFieldsResponseNonNullableFields>;
export interface UpdateExtendedFieldsOptions {
    /** Data to update. Structured according to the [schema](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields#json-schema-for-extended-fields) defined when the extended fields were configured. */
    namespaceData: Record<string, any> | null;
}
/**
 * Updates the booking status to `DECLINED` and updates the relevant session's
 * `participants.approvalStatus` to `DECLINED` without checking whether the relevant
 * slot or schedule is still available.
 *
 *
 * ## eCommerce checkout restriction
 *
 * Call this method only when using a custom checkout page. Don't
 * call it when using a *Wix eCommerce checkout*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/ecom/orders/setup) | [REST](https://dev.wix.com/docs/rest/business-solutions/e-commerce/checkout/introduction)).
 * In such cases, Wix automatically updates the booking status based on
 * the `paymentStatus` of the corresponding *Wix eCommerce order*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/ecom/checkout/setup) | [REST](https://dev.wix.com/docs/rest/business-solutions/e-commerce/orders/introduction)).
 *
 * ## When to call Confirm Or Decline Booking instead
 *
 * The method doesn't check whether a slot or schedule is still available. For
 * these checks you can call *Confirm or Decline Booking*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/bookings/confirm-or-decline-booking) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/bookings/bookings-writer-v2/confirm-or-decline-booking)).
 *
 * ## Original status validation
 *
 * You can only decline bookings with a `status` of `PENDING`, `CREATED`, or
 * `WAITING_LIST`.
 *
 * ## Payment status
 *
 * Also updates the booking's `paymentStatus`, if you specify a new payment
 * status.
 *
 * ## Notify customers
 *
 * You can specify a `participantNotification.message` for the customer. To send
 * the message, you must also specify `participantNotification.notifyParticipants`
 * as `true`.
 * @param bookingId - ID of the booking to decline.
 * @param revision - Revision number, which increments by 1 each time the booking is updated.
 *
 * To prevent conflicting changes, the current revision must be specified when
 * declining the booking.
 * @public
 * @requiredField bookingId
 * @requiredField revision
 * @param options - An object representing the available options for declining a booking.
 * @permissionId BOOKINGS.BOOKING_DECLINE
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @fqn com.wixpress.bookings.bookings.v2.Bookings.DeclineBooking
 */
export declare function declineBooking(bookingId: string, revision: string | null, options?: DeclineBookingOptions): Promise<DeclineBookingResponse & DeclineBookingResponseNonNullableFields>;
export interface DeclineBookingOptions {
    /**
     * Information about whether to notify the customer and
     * the message to send.
     */
    participantNotification?: ParticipantNotification;
    /** Payment status to set for the booking. */
    paymentStatus?: PaymentStatus;
    /** Whether this booking has a conflict with at least 1 other confirmed booking. */
    doubleBooked?: boolean | null;
    /**
     * Whether to ignore specific standard procedures of the Wix Bookings flow.
     * For example, whether to refund a declined booking.
     */
    flowControlSettings?: DeclineBookingFlowControlSettings;
}
/**
 * Updates the booking status to `CANCELED`.
 *
 *
 * ## Appointments
 *
 * For appointments, the corresponding event is removed from the Bookings
 * calendar.
 *
 * ## Class and course bookings
 *
 * For class or course bookings, the relevant participants are removed
 * from the class session or the course. However, the class session or course
 * remain on the business calendar.
 *
 * ## Notify customers
 *
 * You can specify a `participantNotification.message` for the customer. To send
 * the message, you must also specify `participantNotification.notifyParticipants`
 * as `true`.
 *
 * ## Admin overwrites
 *
 * There are small but important differences when you specify special
 * `flowControlSettings`:
 *
 * - `{"ignoreCancellationPolicy": true}`: The call succeeds even if the
 * service's `cancellationPolicy` doesn't allow it.
 * - `{"withRefund": true}`: The customer is refunded even if the service's
 * `refundPolicy` doesn't allow it.
 * - `{"waiveCancellationFee": true}`: The customer doesn't have to pay
 * the cancellation fee, even if the service's `cancellationPolicy` requires it.
 *
 * When using special `flowControlSettings`, ensure you have sufficient
 * permissions. If you encounter failed calls due to insufficient permissions,
 * consider the following options:
 *
 * - **App developers** can use a higher
 * [permission](https://dev.wix.com/docs/build-apps/develop-your-app/access/authorization/about-permissions),
 * such as `MANAGE BOOKINGS - ALL PERMISSIONS`.
 * - **Site developers** can utilize
 * [elevation](https://dev.wix.com/docs/develop-websites/articles/coding-with-velo/authorization/elevation).
 *
 * Granting additional permissions and using elevation permits method calls that
 * would typically fail due to authorization checks. Therefore, you should use
 * them intentionally and securely.
 * @param bookingId - ID of the booking to cancel.
 * @public
 * @requiredField bookingId
 * @requiredField options.revision
 * @param options - An object representing the available options for canceling a booking.
 * @permissionId BOOKINGS.BOOKING_CANCEL
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @applicableIdentity MEMBER
 * @fqn com.wixpress.bookings.bookings.v2.Bookings.CancelBooking
 */
export declare function cancelBooking(bookingId: string, options?: CancelBookingOptions): Promise<CancelBookingResponse & CancelBookingResponseNonNullableFields>;
export interface CancelBookingOptions {
    /**
     * Information about whether to notify the customer about the cancellation and
     * the message to send.
     */
    participantNotification?: ParticipantNotification;
    /**
     * Whether to ignore specific standard procedures of the Wix Bookings flow.
     * For example, whether to allow a cancellation even though the service's
     * policy doesn't allow it.
     */
    flowControlSettings?: CancelBookingFlowControlSettings;
    /**
     * Revision number, which increments by 1 each time the booking is updated.
     *
     * To prevent conflicting changes, the current revision must be specified when
     * managing the booking.
     */
    revision: string | null;
}
/**
 * Updates the number of participants for a class or course booking and changes
 * the `totalNumberOfParticipants` for the relevant sessions.
 *
 *
 * ## Appointment limitation
 *
 * You can't update the number of participants for appointment bookings.
 *
 * ## Participant information
 *
 * You must specify either `participantsChoices` or `totalParticipants`.
 * The call fails if the specified `participantsChoices` aren't among the
 * supported *service options and variants*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/service-options-and-variants/introduction) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/service-options-and-variants/introduction)).
 * @param bookingId - ID of the booking to update the number of participants for.
 * @public
 * @requiredField bookingId
 * @requiredField options.revision
 * @permissionId BOOKINGS.NUMBER_OF_PARTICIPANTS_UPDATE
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @fqn com.wixpress.bookings.bookings.v2.Bookings.UpdateNumberOfParticipants
 */
export declare function updateNumberOfParticipants(bookingId: string, options?: UpdateNumberOfParticipantsOptions): Promise<UpdateNumberOfParticipantsResponse & UpdateNumberOfParticipantsResponseNonNullableFields>;
export interface UpdateNumberOfParticipantsOptions extends UpdateNumberOfParticipantsOptionsParticipantsInfoOneOf {
    /**
     * Revision number, which increments by 1 each time the booking is updated.
     *
     * To prevent conflicting changes, the current revision must be specified
     * when updating the booking.
     */
    revision: string | null;
    /**
     * Total number of participants. Specify when all participants have booked the
     * same service variant.
     */
    totalParticipants?: number;
    /**
     * Information about the service choices the participants have booked. Specify
     * when not all participants have booked the same service variant.
     */
    participantsChoices?: ParticipantChoices;
}
/** @oneof */
export interface UpdateNumberOfParticipantsOptionsParticipantsInfoOneOf {
    /**
     * Total number of participants. Specify when all participants have booked the
     * same service variant.
     */
    totalParticipants?: number;
    /**
     * Information about the service choices the participants have booked. Specify
     * when not all participants have booked the same service variant.
     */
    participantsChoices?: ParticipantChoices;
}
/**
 * Creates a multi-service booking.
 *
 *
 * See Create Booking for more information.
 * @param bookings - Single-service bookings to combine in a multi-service booking.
 * @public
 * @documentationMaturity preview
 * @requiredField bookings
 * @requiredField bookings.additionalFields._id
 * @requiredField bookings.bookedEntity
 * @requiredField bookings.bookedEntity.item
 * @requiredField bookings.bookedEntity.item.slot
 * @requiredField bookings.bookedEntity.item.slot.endDate
 * @requiredField bookings.bookedEntity.item.slot.location.locationType
 * @requiredField bookings.bookedEntity.item.slot.scheduleId
 * @requiredField bookings.bookedEntity.item.slot.startDate
 * @permissionId MULTI_SERVICE_BOOKINGS.MULTI_SERVICE_BOOKING_CREATE
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @applicableIdentity VISITOR
 * @fqn com.wixpress.bookings.bookings.v2.MultiServiceBookings.CreateMultiServiceBooking
 */
export declare function createMultiServiceBooking(bookings: Booking[], options?: CreateMultiServiceBookingOptions): Promise<CreateMultiServiceBookingResponse & CreateMultiServiceBookingResponseNonNullableFields>;
export interface CreateMultiServiceBookingOptions {
    /**
     * Information about whether to notify the customer and
     * the message to send.
     */
    participantNotification?: ParticipantNotification;
    /**
     * Whether to send an SMS reminder to the customer 24 hours before the
     * session starts. The phone number is taken from `contactDetails.phone`.
     *
     * Default: `true`
     */
    sendSmsReminder?: boolean | null;
    /**
     * Whether to ignore specific standard procedures of the Wix Bookings flow.
     * For example, whether to check availability before updating the status.
     */
    flowControlSettings?: CreateBookingFlowControlSettings;
    /** Whether to return the created single-service bookings. */
    returnFullEntity?: boolean;
    /** Multi service booking type. */
    multiServiceBookingType?: MultiServiceBookingType;
}
/**
 * Reschedules a multi-service booking.
 *
 *
 * The call fails if at least 1 individual booking can't be rescheduled due
 * the service being unavailable or a rescheduling policy violation.
 *
 *
 * See Reschedule Booking for more information.
 * @param multiServiceBookingId - ID of the multi service booking to reschedule.
 * @param rescheduleBookingsInfo - Information about the single-service bookings to reschedule.
 * @public
 * @documentationMaturity preview
 * @requiredField multiServiceBookingId
 * @requiredField rescheduleBookingsInfo
 * @requiredField rescheduleBookingsInfo.bookingId
 * @requiredField rescheduleBookingsInfo.revision
 * @requiredField rescheduleBookingsInfo.slot
 * @permissionId MULTI_SERVICE_BOOKINGS.MULTI_SERVICE_BOOKING_RESCHEDULE
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @applicableIdentity MEMBER
 * @fqn com.wixpress.bookings.bookings.v2.MultiServiceBookings.RescheduleMultiServiceBooking
 */
export declare function rescheduleMultiServiceBooking(multiServiceBookingId: string | null, rescheduleBookingsInfo: RescheduleBookingInfo[], options?: RescheduleMultiServiceBookingOptions): Promise<RescheduleMultiServiceBookingResponse & RescheduleMultiServiceBookingResponseNonNullableFields>;
export interface RescheduleMultiServiceBookingOptions {
    /**
     * Information about whether to notify the customer and
     * the message to send.
     */
    participantNotification?: ParticipantNotification;
    /**
     * Information about whether specific procedures of the standard Wix Bookings
     * rescheduling flow are changed. For example, whether the availability of
     * the new slot is checked before rescheduling the booking or if you can
     * reschedule the booking even though the rescheduling policy doesn't allow it.
     */
    flowControlSettings?: RescheduleBookingFlowControlSettings;
    /** Whether to return the rescheduled bookings entities. */
    returnFullEntity?: boolean;
}
/**
 * Retrieves a multi-service booking's availability.
 *
 *
 * Use List Multi Service Availability Time Slots to check availability for a
 * `SEQUENTIAL_BOOKINGS` multi-service booking.
 * @param multiServiceBookingId - ID of the multi-service booking to retrieve.
 * @public
 * @documentationMaturity preview
 * @requiredField multiServiceBookingId
 * @permissionId MULTI_SERVICE_BOOKINGS.MULTI_SERVICE_BOOKING_GET_AVAILABILITY
 * @permissionScope Read Bookings - Public Data
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-PUBLIC
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Read Bookings - Including Participants
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-SENSITIVE
 * @permissionScope Read Bookings - all read permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.READ-BOOKINGS
 * @permissionScope Read Bookings Calendar Availability
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-CALENDAR
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @applicableIdentity VISITOR
 * @fqn com.wixpress.bookings.bookings.v2.MultiServiceBookings.GetMultiServiceBookingAvailability
 */
export declare function getMultiServiceBookingAvailability(multiServiceBookingId: string | null): Promise<GetMultiServiceBookingAvailabilityResponse & GetMultiServiceBookingAvailabilityResponseNonNullableFields>;
/**
 * Cancels a multi-service booking and thus all its individual bookings.
 * @param multiServiceBookingId - ID of the multi-service booking to cancel.
 * @public
 * @documentationMaturity preview
 * @requiredField multiServiceBookingId
 * @permissionId MULTI_SERVICE_BOOKINGS.MULTI_SERVICE_BOOKING_CANCEL
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @applicableIdentity MEMBER
 * @fqn com.wixpress.bookings.bookings.v2.MultiServiceBookings.CancelMultiServiceBooking
 */
export declare function cancelMultiServiceBooking(multiServiceBookingId: string | null, options?: CancelMultiServiceBookingOptions): Promise<CancelMultiServiceBookingResponse & CancelMultiServiceBookingResponseNonNullableFields>;
export interface CancelMultiServiceBookingOptions {
    /**
     * Information about whether to notify the customer and
     * the message to send.
     */
    participantNotification?: ParticipantNotification;
    /**
     * Information about whether specific procedures of the standard Wix Bookings
     * cancellation flow are changed. For example, whether you can cancel
     * a booking even though the cancellation policy doesn't allow it or whether
     * to issue a refund.
     */
    flowControlSettings?: CancelBookingFlowControlSettings;
    /** Whether to return the canceled single-service bookings. */
    returnFullEntity?: boolean;
}
/**
 * Updates the status of a multi-service booking to `PENDING`.
 *
 *
 * Also updates the status of each of individual bookings within the multi-service booking to `PENDING`.
 *
 * The call fails if the status for at least a single individual booking can't be updated.
 *
 * See Mark Booking as Pending for more information.
 * @param multiServiceBookingId - ID of the multi-service booking to mark as `PENDING`.
 * @public
 * @documentationMaturity preview
 * @requiredField multiServiceBookingId
 * @permissionId MULTI_SERVICE_BOOKINGS.MULTI_SERVICE_BOOKING_MARK_AS_PENDING
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @fqn com.wixpress.bookings.bookings.v2.MultiServiceBookings.MarkMultiServiceBookingAsPending
 */
export declare function markMultiServiceBookingAsPending(multiServiceBookingId: string | null, options?: MarkMultiServiceBookingAsPendingOptions): Promise<MarkMultiServiceBookingAsPendingResponse & MarkMultiServiceBookingAsPendingResponseNonNullableFields>;
export interface MarkMultiServiceBookingAsPendingOptions {
    /** Information about the single-service bookings to mark as `PENDING`. */
    markAsPendingBookingsInfo?: BookingInfo[];
    /**
     * Information about whether to notify the customer and
     * the message to send.
     */
    participantNotification?: ParticipantNotification;
    /**
     * Whether to send an SMS reminder to the customer 24 hours before the
     * session starts. The phone number is taken from `contactDetails.phone`.
     *
     * Default: `true`
     */
    sendSmsReminder?: boolean | null;
    /** Whether this booking has a conflict with at least 1 other confirmed booking. */
    doubleBooked?: boolean | null;
    /** Whether to return the single-service bookings that were marked as `PENDING`. */
    returnFullEntity?: boolean;
    /**
     * Information about whether specific procedures of the standard Wix Bookings
     * creation flow are changed. For example, whether the availability is checked
     * before updating the booking.
     */
    flowControlSettings?: MarkBookingAsPendingFlowControlSettings;
}
/**
 * Updates the status of a multi-service booking to `CONFIRMED`.
 *
 *
 * Also updates the status of each of individual bookings within the multi-service booking to `CONFIRMED`.
 *
 * The call fails if the status for at least a single individual booking can't be updated.
 *
 * See Confirm Booking for more information.
 * @param multiServiceBookingId - ID of the multi-service booking to confirm its related bookings.
 * @public
 * @documentationMaturity preview
 * @requiredField multiServiceBookingId
 * @permissionId MULTI_SERVICE_BOOKINGS.MULTI_SERVICE_BOOKING_CONFIRM
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @fqn com.wixpress.bookings.bookings.v2.MultiServiceBookings.ConfirmMultiServiceBooking
 */
export declare function confirmMultiServiceBooking(multiServiceBookingId: string | null, options?: ConfirmMultiServiceBookingOptions): Promise<ConfirmMultiServiceBookingResponse & ConfirmMultiServiceBookingResponseNonNullableFields>;
export interface ConfirmMultiServiceBookingOptions {
    /** Information about the single-service bookings to confirm. */
    confirmBookingsInfo?: BookingInfo[];
    /**
     * Information about whether to notify the customer and
     * the message to send.
     */
    participantNotification?: ParticipantNotification;
    /**
     * Whether to send an SMS reminder to the customer 24 hours before the
     * session starts. The phone number is taken from `contactDetails.phone`.
     *
     * Default: `true`
     */
    sendSmsReminder?: boolean | null;
    /** Whether this booking has a conflict with at least 1 other confirmed booking. */
    doubleBooked?: boolean | null;
    /** Whether to return the confirmed single-service bookings. */
    returnFullEntity?: boolean;
    /**
     * Information about whether specific procedures of the standard Wix Bookings
     * confirmation flow are changed. For example, whether the availability is
     * checked before confirming the booking.
     */
    flowControlSettings?: ConfirmBookingFlowControlSettings;
}
/**
 * Updates the status of a multi-service booking to `DECLINED`.
 *
 *
 * Also updates the status of each of individual bookings within the multi-service booking to `DECLINED`.
 *
 * The call fails if the status for at least a single individual booking can't be updated.
 *
 * See Decline Booking for more information.
 * @param multiServiceBookingId - ID of the multi service booking to decline.
 * @public
 * @documentationMaturity preview
 * @requiredField multiServiceBookingId
 * @permissionId MULTI_SERVICE_BOOKINGS.MULTI_SERVICE_BOOKING_DECLINE
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @fqn com.wixpress.bookings.bookings.v2.MultiServiceBookings.DeclineMultiServiceBooking
 */
export declare function declineMultiServiceBooking(multiServiceBookingId: string | null, options?: DeclineMultiServiceBookingOptions): Promise<DeclineMultiServiceBookingResponse & DeclineMultiServiceBookingResponseNonNullableFields>;
export interface DeclineMultiServiceBookingOptions {
    /** Information about the single-service bookings to decline. */
    declineBookingsInfo?: BookingInfo[];
    /**
     * Information about whether to notify the customer and
     * the message to send.
     */
    participantNotification?: ParticipantNotification;
    /** Whether this booking has a conflict with at least 1 other confirmed booking. */
    doubleBooked?: boolean | null;
    /** Whether to return the declined single-service bookings. */
    returnFullEntity?: boolean;
    /**
     * Information about whether specific procedures of the standard Wix Bookings
     * declining flow are changed. For example, whether to issue a refund.
     */
    flowControlSettings?: DeclineBookingFlowControlSettings;
}
/**
 * Retrieves the allowed actions for a list of multi-service bookings.
 * @param multiServiceBookingIds - IDs of the multi-service bookings to retrieve allowed actions for.
 * @public
 * @documentationMaturity preview
 * @requiredField multiServiceBookingIds
 * @permissionId MULTI_SERVICE_BOOKINGS.MULTI_SERVICE_BOOKING_GET_ALLOWED_ACTIONS
 * @permissionScope Read Bookings - Public Data
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-PUBLIC
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Read Bookings - Including Participants
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-SENSITIVE
 * @permissionScope Read Bookings - all read permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.READ-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @applicableIdentity VISITOR
 * @fqn com.wixpress.bookings.bookings.v2.MultiServiceBookings.BulkGetMultiServiceBookingAllowedActions
 */
export declare function bulkGetMultiServiceBookingAllowedActions(multiServiceBookingIds: string[] | null): Promise<BulkGetMultiServiceBookingAllowedActionsResponse & BulkGetMultiServiceBookingAllowedActionsResponseNonNullableFields>;
/**
 * Retrieves all single-service bookings belonging to a multi-service booking.
 *
 *
 * If you call as an [identity](https://dev.wix.com/docs/build-apps/develop-your-app/access/about-identities)
 * who has permissions to read only part of the bookings,
 * only the permitted bookings are retrieved. The returned total number of
 * bookings includes also the bookings for which you don't have permissions.
 * @param multiServiceBookingId - ID of the multi-service booking.
 * @public
 * @documentationMaturity preview
 * @requiredField multiServiceBookingId
 * @permissionId MULTI_SERVICE_BOOKINGS.MULTI_SERVICE_BOOKING_READ
 * @permissionScope Read Bookings - Public Data
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-PUBLIC
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Read Bookings - Including Participants
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-SENSITIVE
 * @permissionScope Read Bookings - all read permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.READ-BOOKINGS
 * @permissionScope Read Bookings Calendar Availability
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-CALENDAR
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @returns Retrieved multi-service booking.
 * @fqn com.wixpress.bookings.bookings.v2.MultiServiceBookings.GetMultiServiceBooking
 */
export declare function getMultiServiceBooking(multiServiceBookingId: string | null): Promise<MultiServiceBooking & MultiServiceBookingNonNullableFields>;
/**
 * Adds a list of single-service bookings to a multi-service booking.
 *
 *
 * The call fails, if at least 1 of the specified booking is already part of a
 * multi-service booking.
 * @param multiServiceBookingId - ID of the multi-service booking.
 * @public
 * @documentationMaturity preview
 * @requiredField multiServiceBookingId
 * @requiredField options.bookings
 * @requiredField options.bookings.bookingId
 * @requiredField options.bookings.revision
 * @permissionId MULTI_SERVICE_BOOKINGS.MULTI_SERVICE_BOOKING_ADD_BOOKINGS
 * @fqn com.wixpress.bookings.bookings.v2.MultiServiceBookings.AddBookingsToMultiServiceBooking
 */
export declare function addBookingsToMultiServiceBooking(multiServiceBookingId: string | null, options?: AddBookingsToMultiServiceBookingOptions): Promise<AddBookingsToMultiServiceBookingResponse & AddBookingsToMultiServiceBookingResponseNonNullableFields>;
export interface AddBookingsToMultiServiceBookingOptions {
    /**
     * List of single-service booking IDs and their revision.
     * @maxSize 8
     */
    bookings: BookingIdAndRevision[];
    /** Whether to return the single-service bookings that were added to the multi-service booking. */
    returnFullEntity?: boolean;
}
/**
 * Removes single-service bookings from a multi-service booking and returns the
 * removed bookings.
 *
 *
 * If you specify an empty `bookings` array, all single-service bookings for which
 * the call's [identity](https://dev.wix.com/docs/build-apps/develop-your-app/access/about-identities)
 * has read permissions are removed from the multi-service booking.
 *
 * If the call would create a multi-service booking including only 1 single-service
 * booking, the multi-service booking is also deleted.
 * @param multiServiceBookingId - ID of the multi-service booking.
 * @public
 * @documentationMaturity preview
 * @requiredField multiServiceBookingId
 * @permissionId MULTI_SERVICE_BOOKINGS.MULTI_SERVICE_BOOKING_REMOVE_BOOKINGS
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @fqn com.wixpress.bookings.bookings.v2.MultiServiceBookings.RemoveBookingsFromMultiServiceBooking
 */
export declare function removeBookingsFromMultiServiceBooking(multiServiceBookingId: string | null, options?: RemoveBookingsFromMultiServiceBookingOptions): Promise<RemoveBookingsFromMultiServiceBookingResponse & RemoveBookingsFromMultiServiceBookingResponseNonNullableFields>;
export interface RemoveBookingsFromMultiServiceBookingOptions {
    /**
     * List of single-service booking IDs and their revision.
     * @maxSize 8
     */
    bookings?: BookingIdAndRevision[];
    /** Whether to return the single-service bookings. */
    returnFullEntity?: boolean;
}
export {};
