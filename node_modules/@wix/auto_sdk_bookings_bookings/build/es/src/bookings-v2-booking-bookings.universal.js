import { transformError as sdkTransformError } from '@wix/sdk-runtime/transform-error';
import { renameKeysFromSDKRequestToRESTRequest, renameKeysFromRESTResponseToSDKResponse, } from '@wix/sdk-runtime/rename-all-nested-keys';
import * as ambassadorWixBookingsV2Booking from './bookings-v2-booking-bookings.http.js';
/**
 * A multi-service booking is considered available if all individual bookings are available as returned from List Multi Service Availability Time Slots.
 * Currently, `SEPARATE_BOOKINGS` and `PARALLEL_BOOKINGS` are not supported.
 * Multi-service booking is available if each of its bookings is available separately.
 * For `SEQUENTIAL_BOOKINGS`, see `List Multi Service Availability Time Slots` documentation.
 */
export var MultiServiceBookingType;
(function (MultiServiceBookingType) {
    MultiServiceBookingType["SEQUENTIAL_BOOKINGS"] = "SEQUENTIAL_BOOKINGS";
    MultiServiceBookingType["SEPARATE_BOOKINGS"] = "SEPARATE_BOOKINGS";
    MultiServiceBookingType["PARALLEL_BOOKINGS"] = "PARALLEL_BOOKINGS";
})(MultiServiceBookingType || (MultiServiceBookingType = {}));
export var LocationType;
(function (LocationType) {
    LocationType["UNDEFINED"] = "UNDEFINED";
    LocationType["OWNER_BUSINESS"] = "OWNER_BUSINESS";
    LocationType["OWNER_CUSTOM"] = "OWNER_CUSTOM";
    LocationType["CUSTOM"] = "CUSTOM";
})(LocationType || (LocationType = {}));
export var ValueType;
(function (ValueType) {
    /** Short text. This is the default value type. */
    ValueType["SHORT_TEXT"] = "SHORT_TEXT";
    /** Long text. */
    ValueType["LONG_TEXT"] = "LONG_TEXT";
    /** A text that represents the check box value. If selected the value is `true`, otherwise `false`. */
    ValueType["CHECK_BOX"] = "CHECK_BOX";
})(ValueType || (ValueType = {}));
/** Booking status. */
export var BookingStatus;
(function (BookingStatus) {
    /**
     * The booking was created, but the customer hasn't completed the related
     * eCommerce order yet.
     */
    BookingStatus["CREATED"] = "CREATED";
    /**
     * The merchant has confirmed the booking and it appears in the
     * business calendar. Merchants can set up their *services*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/services/setup) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/services-v2/introduction))
     * to automatically confirm all `PENDING` bookings.
     */
    BookingStatus["CONFIRMED"] = "CONFIRMED";
    /**
     * The customer has canceled the booking. Depending on the relevant service's
     * _policy snapshot_
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/booking-policy-snapshots/introduction) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/policies/booking-policy-snapshots/introduction))
     * they may have to pay a _cancellation fee_
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/booking-fees/introduction) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/pricing/booking-fees/introduction)).
     */
    BookingStatus["CANCELED"] = "CANCELED";
    /**
     * The merchant must manually confirm the booking before it appears
     * in the business calendar.
     */
    BookingStatus["PENDING"] = "PENDING";
    /** The merchant has declined the booking before the customer was charged. */
    BookingStatus["DECLINED"] = "DECLINED";
    /**
     * The booking is on a waitlist.
     * Currently, you can't call Register to Waitlist
     * ([REST](https://dev.wix.com/docs/rest/business-solutions/bookings/bookings/waitlist/register-to-waitlist))
     * for course or appointment bookings, even though this is supported in live sites.
     * You can call Register to Waitlist only for class session bookings.
     */
    BookingStatus["WAITING_LIST"] = "WAITING_LIST";
})(BookingStatus || (BookingStatus = {}));
/**
 * Payment status.
 * Automatically updated when using eCommerce checkout APIs.
 */
export var PaymentStatus;
(function (PaymentStatus) {
    /** Undefined payment status. */
    PaymentStatus["UNDEFINED"] = "UNDEFINED";
    /** The booking isn't paid. */
    PaymentStatus["NOT_PAID"] = "NOT_PAID";
    /** The booking is fully paid. */
    PaymentStatus["PAID"] = "PAID";
    /** The booking is partially paid. */
    PaymentStatus["PARTIALLY_PAID"] = "PARTIALLY_PAID";
    /** The booking is refunded. */
    PaymentStatus["REFUNDED"] = "REFUNDED";
    /** The booking is free of charge. */
    PaymentStatus["EXEMPT"] = "EXEMPT";
})(PaymentStatus || (PaymentStatus = {}));
/**
 * Selected payment option.
 *
 * One of the payment options offered by the service.
 * This field is set when the user selects an option during booking.
 * If left undefined, the payment option is resolved by the service configuration on checkout.
 */
export var SelectedPaymentOption;
(function (SelectedPaymentOption) {
    /** Undefined payment option. */
    SelectedPaymentOption["UNDEFINED"] = "UNDEFINED";
    /** Offline payment. */
    SelectedPaymentOption["OFFLINE"] = "OFFLINE";
    /** Online payment. */
    SelectedPaymentOption["ONLINE"] = "ONLINE";
    /** Payment using a Wix Pricing Plan. */
    SelectedPaymentOption["MEMBERSHIP"] = "MEMBERSHIP";
    /**
     * Customers can pay only in person with a Wix Pricing Plan, while the Wix user
     * must manually redeem the pricing plan in the dashboard.
     */
    SelectedPaymentOption["MEMBERSHIP_OFFLINE"] = "MEMBERSHIP_OFFLINE";
})(SelectedPaymentOption || (SelectedPaymentOption = {}));
export var Platform;
(function (Platform) {
    Platform["UNDEFINED_PLATFORM"] = "UNDEFINED_PLATFORM";
    Platform["WEB"] = "WEB";
    Platform["MOBILE_APP"] = "MOBILE_APP";
})(Platform || (Platform = {}));
export var Actor;
(function (Actor) {
    Actor["UNDEFINED_ACTOR"] = "UNDEFINED_ACTOR";
    Actor["BUSINESS"] = "BUSINESS";
    Actor["CUSTOMER"] = "CUSTOMER";
})(Actor || (Actor = {}));
export var IdentificationDataIdentityType;
(function (IdentificationDataIdentityType) {
    IdentificationDataIdentityType["UNKNOWN"] = "UNKNOWN";
    IdentificationDataIdentityType["ANONYMOUS_VISITOR"] = "ANONYMOUS_VISITOR";
    IdentificationDataIdentityType["MEMBER"] = "MEMBER";
    IdentificationDataIdentityType["WIX_USER"] = "WIX_USER";
    IdentificationDataIdentityType["APP"] = "APP";
})(IdentificationDataIdentityType || (IdentificationDataIdentityType = {}));
export var WebhookIdentityType;
(function (WebhookIdentityType) {
    WebhookIdentityType["UNKNOWN"] = "UNKNOWN";
    WebhookIdentityType["ANONYMOUS_VISITOR"] = "ANONYMOUS_VISITOR";
    WebhookIdentityType["MEMBER"] = "MEMBER";
    WebhookIdentityType["WIX_USER"] = "WIX_USER";
    WebhookIdentityType["APP"] = "APP";
})(WebhookIdentityType || (WebhookIdentityType = {}));
export var LocationLocationType;
(function (LocationLocationType) {
    /** Undefined location type. */
    LocationLocationType["UNDEFINED"] = "UNDEFINED";
    /** The business address as set in the siteâ€™s general settings. */
    LocationLocationType["OWNER_BUSINESS"] = "OWNER_BUSINESS";
    /** The address set when creating the service. */
    LocationLocationType["OWNER_CUSTOM"] = "OWNER_CUSTOM";
    /** The address set for the individual session. */
    LocationLocationType["CUSTOM"] = "CUSTOM";
})(LocationLocationType || (LocationLocationType = {}));
export var IdentityType;
(function (IdentityType) {
    IdentityType["UNKNOWN"] = "UNKNOWN";
    IdentityType["ANONYMOUS_VISITOR"] = "ANONYMOUS_VISITOR";
    IdentityType["MEMBER"] = "MEMBER";
    IdentityType["WIX_USER"] = "WIX_USER";
    IdentityType["APP"] = "APP";
})(IdentityType || (IdentityType = {}));
export var SortOrder;
(function (SortOrder) {
    SortOrder["ASC"] = "ASC";
    SortOrder["DESC"] = "DESC";
})(SortOrder || (SortOrder = {}));
/**
 * Updates the booking `status` to `CONFIRMED`, `PENDING`, or `DECLINED` based
 * on the `paymentStatus` you provide, double booking conflicts, and whether
 * the service requires business approval.
 *
 * ## eCommerce checkout restriction
 *
 * Call this method only when using a custom checkout page. Don't
 * call it when using a *Wix eCommerce checkout*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/ecom/orders/setup) | [REST](https://dev.wix.com/docs/rest/business-solutions/e-commerce/checkout/introduction)).
 * In such cases, Wix automatically updates the booking status based on
 * the `paymentStatus` of the corresponding *Wix eCommerce order*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/ecom/checkout/setup) | [REST](https://dev.wix.com/docs/rest/business-solutions/e-commerce/orders/introduction)).
 *
 * ## New booking status
 *
 * The booking `status` is set to `DECLINED` if both of the following conditions
 * are met:
 * + You provide `UNDEFINED`, `NOT_PAID`, `REFUNDED`, or `EXEMPT` as payment status.
 * + There is a double booking conflict.
 *
 * If only one or none of these conditions is met, `status` is set to `PENDING`
 * or `CONFIRMED` depending on whether the service requires business approval.
 *
 * ## Double bookings
 *
 * If there is a double booking conflict, but the booking has already been at least
 * partially paid, the method still marks the booking as `PENDING` or `CONFIRMED`.
 * Then, it also sets `doubleBooked` to `true`.
 *
 * ## Admin overwrites
 *
 * There are small but important differences in confirmation behavior if the
 * booking was created with special `flowControlSettings`:
 * + If the booking's `flowControlSettings.skipAvailabilityValidation` was set to
 * `true`, the booking is never declined regardless of double booking conflicts.
 * Instead, it's marked `CONFIRMED` or `PENDING`, depending on whether the
 * service requires business approval.
 * + If the booking's `flowControlSettings.skipBusinessConfirmation` was set to
 * `true`, the booking skips `PENDING` status and is marked `CONFIRMED`
 * immediately.
 * @param bookingId - ID of the booking to confirm or decline.
 * @public
 * @requiredField bookingId
 * @permissionId BOOKINGS.BOOKING_CONFIRM_OR_DECLINE
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @fqn com.wixpress.bookings.confirmator.v2.Confirmator.ConfirmOrDeclineBooking
 */
export async function confirmOrDeclineBooking(bookingId, options) {
    // @ts-ignore
    const { httpClient, sideEffects } = arguments[2];
    const payload = renameKeysFromSDKRequestToRESTRequest({
        bookingId: bookingId,
        paymentStatus: options?.paymentStatus,
    });
    const reqOpts = ambassadorWixBookingsV2Booking.confirmOrDeclineBooking(payload);
    sideEffects?.onSiteCall?.();
    try {
        const result = await httpClient.request(reqOpts);
        sideEffects?.onSuccess?.(result);
        return renameKeysFromRESTResponseToSDKResponse(result.data);
    }
    catch (err) {
        const transformedError = sdkTransformError(err, {
            spreadPathsToArguments: {},
            explicitPathsToArguments: {
                bookingId: '$[0]',
                paymentStatus: '$[1].paymentStatus',
            },
            singleArgumentUnchanged: false,
        }, ['bookingId', 'options']);
        sideEffects?.onError?.(err);
        throw transformedError;
    }
}
/**
 * Confirms or declines up to 300 bookings.
 *
 *
 * See *Confirm Or Decline Booking*
 * ([SDK](https://dev.wix.com/docs/velo/api-reference/wix-bookings-v2/bookings/confirm-or-decline-booking) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/bookings/bookings-writer-v2/confirm-or-decline-booking))
 * for details about when a booking is confirmed or declined.
 * @param details - Bookings to confirm or decline.
 * @public
 * @documentationMaturity preview
 * @requiredField details
 * @requiredField details.bookingId
 * @permissionId BOOKINGS.BOOKING_CONFIRM_OR_DECLINE
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @fqn com.wixpress.bookings.confirmator.v2.Confirmator.BulkConfirmOrDeclineBooking
 */
export async function bulkConfirmOrDeclineBooking(details, options) {
    // @ts-ignore
    const { httpClient, sideEffects } = arguments[2];
    const payload = renameKeysFromSDKRequestToRESTRequest({
        details: details,
        returnEntity: options?.returnEntity,
    });
    const reqOpts = ambassadorWixBookingsV2Booking.bulkConfirmOrDeclineBooking(payload);
    sideEffects?.onSiteCall?.();
    try {
        const result = await httpClient.request(reqOpts);
        sideEffects?.onSuccess?.(result);
        return renameKeysFromRESTResponseToSDKResponse(result.data);
    }
    catch (err) {
        const transformedError = sdkTransformError(err, {
            spreadPathsToArguments: {},
            explicitPathsToArguments: {
                details: '$[0]',
                returnEntity: '$[1].returnEntity',
            },
            singleArgumentUnchanged: false,
        }, ['details', 'options']);
        sideEffects?.onError?.(err);
        throw transformedError;
    }
}
/**
 * Creates a booking.
 *
 *
 * ## Appointment booking
 *
 * For appointment-based services, specify the relevant `slot` in
 * `bookedEntity.slot`. We recommend specifying the complete
 * `availabilityEntries.slot` returned in *Query Availability*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/availability-calendar/query-availability) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/time-slots/availability-calendar/query-availability))
 * in your call's request to avoid failed calls due to unavailability.
 *
 * ## Class session booking
 *
 * For class services, specify the relevant *event ID*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/calendar/events/introduction) | [REST](https://dev.wix.com/docs/rest/business-management/calendar/events-v3/introduction))
 * as `bookedEntity.slot.eventId`.
 * We recommend retrieving the event ID from *Query Availability's*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/availability-calendar/query-availability) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/time-slots/availability-calendar/query-availability))
 * `availabilityEntries.slot.eventId` to avoid failed calls due to unavailability.
 * Specifying an event ID leads to automatic calculations of `slot.startDate`, `slot.endDate`,
 * `slot.timezone`, `slot.resource`, and `slot.location`. All manually specified
 * values are overridden.
 *
 * ## Course booking
 *
 * For course services, specify the course's schedule ID in `bookedEntity.schedule.scheduleId`.
 * We recommend following [this sample flow](https://dev.wix.com/docs/rest/business-solutions/bookings/sample-booking-flows#book-a-course)
 * to minimize failed calls due to unavailability.
 *
 * ## Related resources
 *
 * Specifying a `resource` triggers an availability check, resulting in a failed
 * call if the resource is unavailable. Omitting a resource allows Wix Bookings
 * to assign a resource belonging to the relevant type randomly when the merchant
 * confirms the booking.
 *
 * ## Participant information
 *
 * You must specify either `participantsChoices` or `totalParticipants`.
 * The call fails if the specified `participantsChoices` aren't among the supported
 * _service options and variants_
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/service-options-and-variants/introduction) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/service-options-and-variants/introduction)).
 *
 * ## Notify customers
 *
 * You can specify a `participantNotification.message` for the customer that's send
 * immediately. Ensure `participantNotification.notifyParticipants` is set to `true`
 * to send the message.
 *
 * If you specify `{"sendSmsReminder": true}`, the customer receives an SMS 24 hours
 * before the session starts. The phone number is taken from `contactDetails.phone`.
 *
 * ## Booking status
 *
 * Bookings default to the `CREATED` status, not affecting the business calendar
 * or resource availability. You can specify a different status when the calling
 * [identity](https://dev.wix.com/docs/build-apps/develop-your-app/access/about-identities)
 * has `Manage Bookings` permissions.
 *
 * ## Payment options
 *
 * The specified `selectedPaymentOption` indicates how the customer intends to
 * pay, allowing for later changes to a different method supported by the service.
 *
 * ## Payment status
 *
 * A booking is initially created with `{"paymentStatus": "UNDEFINED"}` regardless
 * of the payment status specified in Create Booking. If a customer uses an
 * _eCommerce checkout_
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/ecom/orders/setup) | [REST](https://dev.wix.com/docs/rest/business-solutions/e-commerce/checkout/introduction)),
 * Wix Bookings automatically syncs the booking's payment status from
 * the corresponding *eCommerce order*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/ecom/checkout/setup) | [REST](https://dev.wix.com/docs/rest/business-solutions/e-commerce/orders/introduction)).
 *
 * If a booking doesn't have a corresponding eCommerce order, for example, since
 * the customer didn't use the eCommerce checkout, you can update the booking's
 * payment status with *Confirm Or Decline Booking*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/bookings/confirm-or-decline-booking) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/bookings/bookings-writer-v2/confirm-or-decline-booking)).
 *
 * ## Booking form data
 *
 * When customers sign up for a service, they must fill out the booking form.
 * To create a booking with a completed booking form, specify the relevant data in
 * `formSubmission`. Ensure the values of the corresponding fields in
 * `booking.contactDetails` and `formSubmission` are identical. If these values
 * don't match, Create Booking fails. Therefore, we recommend specifying
 * only `booking.contactDetails.contactId` when providing `formSubmission`.
 *
 * ## Admin overwrites
 *
 * There are small but important differences when you specify special
 * `flowControlSettings`:
 *
 * - `{"skipAvailabilityValidation": true}`: The call succeeds
 * regardless of availability. If you don't specify any resource, the call
 * succeeds even if no resource of the relevant type is available.
 * - `{"skipBusinessConfirmation": true}`: Automatically confirms `PENDING`
 * bookings that require manual confirmation.
 * - `{"skipSelectedPaymentOptionValidation": true}`: Allows customers to pay
 * with payment methods that aren't supported for the service.
 *
 * When using special `flowControlSettings`, ensure you have sufficient
 * permissions. If you encounter failed calls due to insufficient permissions,
 * consider the following options:
 *
 * - **App developers** can use a higher
 * [permission](https://dev.wix.com/docs/build-apps/develop-your-app/access/authorization/about-permissions),
 * such as `MANAGE BOOKINGS - ALL PERMISSIONS`.
 * - **Site developers** can utilize
 * [elevation](https://dev.wix.com/docs/develop-websites/articles/coding-with-velo/authorization/elevation).
 *
 * Granting additional permissions and using elevation permits method calls that
 * would typically fail due to authorization checks. Therefore, you should use
 * them intentionally and securely.
 * @param booking - The booking to create.
 * @public
 * @requiredField booking
 * @requiredField booking.additionalFields._id
 * @requiredField booking.bookedEntity
 * @requiredField booking.bookedEntity.item
 * @permissionId BOOKINGS.BOOKING_CREATE
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @applicableIdentity VISITOR
 * @fqn com.wixpress.bookings.bookings.v2.Bookings.CreateBooking
 */
export async function createBooking(booking, options) {
    // @ts-ignore
    const { httpClient, sideEffects } = arguments[2];
    const payload = renameKeysFromSDKRequestToRESTRequest({
        booking: booking,
        participantNotification: options?.participantNotification,
        sendSmsReminder: options?.sendSmsReminder,
        flowControlSettings: options?.flowControlSettings,
    });
    const reqOpts = ambassadorWixBookingsV2Booking.createBooking(payload);
    sideEffects?.onSiteCall?.();
    try {
        const result = await httpClient.request(reqOpts);
        sideEffects?.onSuccess?.(result);
        return renameKeysFromRESTResponseToSDKResponse(result.data);
    }
    catch (err) {
        const transformedError = sdkTransformError(err, {
            spreadPathsToArguments: {},
            explicitPathsToArguments: {
                booking: '$[0]',
                participantNotification: '$[1].participantNotification',
                sendSmsReminder: '$[1].sendSmsReminder',
                flowControlSettings: '$[1].flowControlSettings',
            },
            singleArgumentUnchanged: false,
        }, ['booking', 'options']);
        sideEffects?.onError?.(err);
        throw transformedError;
    }
}
/**
 * Creates up to 8 bookings.
 *
 *
 * See *Create Booking*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/bookings/create-booking) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/bookings/bookings-writer-v2/create-booking))
 * for more information.
 *
 * If any of the specified bookings is missing a required field the entire call
 * fails.
 *
 * If you specify 1 or more unavailable bookings, the call succeeds
 * while the unavailable bookings aren't created. Instead, they're counted as
 * failures in the returned `bulkActionMetadata`.
 * @param createBookingsInfo - Bookings to create.
 *
 * Max: 8 bookings
 * @public
 * @requiredField createBookingsInfo
 * @requiredField createBookingsInfo.booking
 * @requiredField createBookingsInfo.booking.additionalFields._id
 * @requiredField createBookingsInfo.booking.bookedEntity
 * @requiredField createBookingsInfo.booking.bookedEntity.item
 * @permissionId BOOKINGS.BOOKING_CREATE
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @applicableIdentity VISITOR
 * @fqn com.wixpress.bookings.bookings.v2.Bookings.BulkCreateBooking
 */
export async function bulkCreateBooking(createBookingsInfo, options) {
    // @ts-ignore
    const { httpClient, sideEffects } = arguments[2];
    const payload = renameKeysFromSDKRequestToRESTRequest({
        createBookingsInfo: createBookingsInfo,
        returnFullEntity: options?.returnFullEntity,
    });
    const reqOpts = ambassadorWixBookingsV2Booking.bulkCreateBooking(payload);
    sideEffects?.onSiteCall?.();
    try {
        const result = await httpClient.request(reqOpts);
        sideEffects?.onSuccess?.(result);
        return renameKeysFromRESTResponseToSDKResponse(result.data);
    }
    catch (err) {
        const transformedError = sdkTransformError(err, {
            spreadPathsToArguments: {},
            explicitPathsToArguments: {
                createBookingsInfo: '$[0]',
                returnFullEntity: '$[1].returnFullEntity',
            },
            singleArgumentUnchanged: false,
        }, ['createBookingsInfo', 'options']);
        sideEffects?.onError?.(err);
        throw transformedError;
    }
}
/**
 * Reschedules an appointment booking to a different slot or a class booking to
 * a different session.
 *
 *
 * ## Course booking limitation
 *
 * You can't reschedule course bookings.
 *
 * ## Appointment sessions
 *
 * For appointments, the old session is removed from the business calendar
 * while a new session is added. We recommend calling *Query Availability*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/availability-calendar/query-availability) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/time-slots/availability-calendar/query-availability))
 * first and specifying the entire retrieved `slot`.
 *
 * ## Class sessions
 *
 * For classes, the new session must be an existing session belonging to the
 * same class. We recommend retrieving `availabilityEntries.slot.eventId`
 * from *Query Availability*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/availability-calendar/query-availability) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/time-slots/availability-calendar/query-availability))
 * to avoid failed Reschedule Booking calls due to unavailability. Specify
 * only `slot.eventId` instead of the entire `slot` object.
 *
 * ## Notify customers
 *
 * You can specify a `participantNotification.message` for the customer. To send
 * the message, you must also specify `participantNotification.notifyParticipants`
 * as `true`.
 *
 * ## Admin overwrites
 *
 * There are small but important differences when you specify special
 * `flowControlSettings`:
 *
 * - `{"ignoreReschedulePolicy": true}`: The call succeeds even if the
 * service's `reschedulePolicy` doesn't allow it.
 * - `{"skipAvailabilityValidation": true}`: The call succeeds even if
 * the specified session, slot, or resource isn't available. If you don't
 * specify any resource, the call succeeds even if no resource of the relevant
 * type is available.
 * - `{"skipBusinessConfirmation": true}`: Any `PENDING` booking is
 * automatically confirmed even if the services requires the merchants's
 * manual confirmation.
 *
 * When using special `flowControlSettings`, ensure you have sufficient
 * permissions. If you encounter failed calls due to insufficient permissions,
 * consider the following options:
 *
 * - **App developers** can use a higher
 * [permission](https://dev.wix.com/docs/build-apps/develop-your-app/access/authorization/about-permissions),
 * such as `MANAGE BOOKINGS - ALL PERMISSIONS`.
 * - **Site developers** can utilize
 * [elevation](https://dev.wix.com/docs/develop-websites/articles/coding-with-velo/authorization/elevation).
 *
 * Granting additional permissions and using elevation permits method calls that
 * would typically fail due to authorization checks. Therefore, you should use
 * them intentionally and securely.
 * @param bookingId - ID of the booking to reschedule.
 * @param slot - New slot of the booking.
 * @public
 * @requiredField bookingId
 * @requiredField options.revision
 * @requiredField slot
 * @param options - An object representing the available options for rescheduling a booking.
 * @permissionId BOOKINGS.BOOKING_RESCHEDULE
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @applicableIdentity MEMBER
 * @fqn com.wixpress.bookings.bookings.v2.Bookings.RescheduleBooking
 */
export async function rescheduleBooking(bookingId, slot, options) {
    // @ts-ignore
    const { httpClient, sideEffects } = arguments[3];
    const payload = renameKeysFromSDKRequestToRESTRequest({
        bookingId: bookingId,
        slot: slot,
        revision: options?.revision,
        participantNotification: options?.participantNotification,
        flowControlSettings: options?.flowControlSettings,
        totalParticipants: options?.totalParticipants,
        participantsChoices: options?.participantsChoices,
    });
    const reqOpts = ambassadorWixBookingsV2Booking.rescheduleBooking(payload);
    sideEffects?.onSiteCall?.();
    try {
        const result = await httpClient.request(reqOpts);
        sideEffects?.onSuccess?.(result);
        return renameKeysFromRESTResponseToSDKResponse(result.data);
    }
    catch (err) {
        const transformedError = sdkTransformError(err, {
            spreadPathsToArguments: {},
            explicitPathsToArguments: {
                bookingId: '$[0]',
                slot: '$[1]',
                revision: '$[2].revision',
                participantNotification: '$[2].participantNotification',
                flowControlSettings: '$[2].flowControlSettings',
                totalParticipants: '$[2].totalParticipants',
                participantsChoices: '$[2].participantsChoices',
            },
            singleArgumentUnchanged: false,
        }, ['bookingId', 'slot', 'options']);
        sideEffects?.onError?.(err);
        throw transformedError;
    }
}
/**
 * Updates the booking status to `CONFIRMED` and updates the relevant session's
 * `participants.approvalStatus` to `APPROVED` without checking whether the relevant
 * slot or schedule is still available.
 *
 * ## eCommerce checkout restriction
 *
 * Call this method only when using a custom checkout page. Don't
 * call it when using a *Wix eCommerce checkout*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/ecom/orders/setup) | [REST](https://dev.wix.com/docs/rest/business-solutions/e-commerce/checkout/introduction)).
 * In such cases, Wix automatically updates the booking status based on
 * the `paymentStatus` of the corresponding *Wix eCommerce order*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/ecom/checkout/setup) | [REST](https://dev.wix.com/docs/rest/business-solutions/e-commerce/orders/introduction)).
 *
 * ## When to call Confirm Or Decline Booking instead
 *
 * Confirm Booking doesn't check whether a slot or schedule is still available. For
 * these checks you can call *Confirm or Decline Booking*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/bookings/confirm-or-decline-booking) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/bookings/bookings-writer-v2/confirm-or-decline-booking)).
 *
 * ## Original status validation
 *
 * You can only confirm bookings with a status of `PENDING`, `CREATED`, or
 * `WAITING_LIST`.
 *
 * ## Double bookings
 *
 * Confirm Booking doesn't check whether a slot or schedule is still available.
 * You can specify
 *
 * ```json
 * {
 * "flowControlSettings": {
 * "checkAvailabilityValidation": true
 * },
 * "doubleBooked": true
 * }
 * ```
 * to forcefully set the booking's `doubleBooked` flag to `true`, regardless of
 * a potential double booking conflict. You must call with `Manage Bookings`
 * permissions to do so. For the default flow control settings
 * `{"checkAvailabilityValidation": false}`, the specified `doubleBooked` value
 * is ignored.
 *
 * ## Payment status
 *
 * Also updates the booking's `paymentStatus`, if you specify a new payment
 * status.
 *
 * ## Notify customers
 *
 * You can specify a `participantNotification.message` for the customer. To send
 * the message, you must also specify `participantNotification.notifyParticipants`
 * as `true`.
 * @param bookingId - ID of the booking to confirm.
 * @param revision - Revision number, which increments by 1 each time the booking is updated.
 * To prevent conflicting changes, the current revision must be passed when
 * updating the booking.
 * @public
 * @requiredField bookingId
 * @requiredField revision
 * @param options - An object representing the available options for canceling a booking.
 * @permissionId BOOKINGS.BOOKING_CONFIRM
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @fqn com.wixpress.bookings.bookings.v2.Bookings.ConfirmBooking
 */
export async function confirmBooking(bookingId, revision, options) {
    // @ts-ignore
    const { httpClient, sideEffects } = arguments[3];
    const payload = renameKeysFromSDKRequestToRESTRequest({
        bookingId: bookingId,
        revision: revision,
        participantNotification: options?.participantNotification,
        sendSmsReminder: options?.sendSmsReminder,
        paymentStatus: options?.paymentStatus,
        doubleBooked: options?.doubleBooked,
        flowControlSettings: options?.flowControlSettings,
    });
    const reqOpts = ambassadorWixBookingsV2Booking.bookingsConfirmBooking(payload);
    sideEffects?.onSiteCall?.();
    try {
        const result = await httpClient.request(reqOpts);
        sideEffects?.onSuccess?.(result);
        return renameKeysFromRESTResponseToSDKResponse(result.data);
    }
    catch (err) {
        const transformedError = sdkTransformError(err, {
            spreadPathsToArguments: {},
            explicitPathsToArguments: {
                bookingId: '$[0]',
                revision: '$[1]',
                participantNotification: '$[2].participantNotification',
                sendSmsReminder: '$[2].sendSmsReminder',
                paymentStatus: '$[2].paymentStatus',
                doubleBooked: '$[2].doubleBooked',
                flowControlSettings: '$[2].flowControlSettings',
            },
            singleArgumentUnchanged: false,
        }, ['bookingId', 'revision', 'options']);
        sideEffects?.onError?.(err);
        throw transformedError;
    }
}
/**
 * Updates the extended fields for a booking.
 *
 *
 * If you specify an extended field `namespace` that doesn't exist yet, it's
 * created.
 *
 * Learn more about [extended fields](https://dev.wix.com/docs/build-apps/develop-your-app/extensions/backend-extensions/about-backend-extensions#schema-plugin-extensions).
 * @public
 * @requiredField _id
 * @requiredField namespace
 * @requiredField options
 * @requiredField options.namespaceData
 * @param _id - ID of the booking for which to update extended fields.
 * @param namespace - [Namespace](https://dev.wix.com/docs/build-apps/develop-your-app/extensions/backend-extensions/schema-plugins/about-reading-and-writing-schema-plugin-fields#namespaces) of the app for which to update extended fields.
 * @param options - Options for updating the booking's extended fields.
 * @permissionId BOOKINGS.BOOKING_UPDATE_EXTENDED_FIELDS
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @fqn com.wixpress.bookings.bookings.v2.Bookings.UpdateExtendedFields
 */
export async function updateExtendedFields(_id, namespace, options) {
    // @ts-ignore
    const { httpClient, sideEffects } = arguments[3];
    const payload = renameKeysFromSDKRequestToRESTRequest({
        id: _id,
        namespace: namespace,
        namespaceData: options?.namespaceData,
    });
    const reqOpts = ambassadorWixBookingsV2Booking.updateExtendedFields(payload);
    sideEffects?.onSiteCall?.();
    try {
        const result = await httpClient.request(reqOpts);
        sideEffects?.onSuccess?.(result);
        return renameKeysFromRESTResponseToSDKResponse(result.data);
    }
    catch (err) {
        const transformedError = sdkTransformError(err, {
            spreadPathsToArguments: {},
            explicitPathsToArguments: {
                id: '$[0]',
                namespace: '$[1]',
                namespaceData: '$[2].namespaceData',
            },
            singleArgumentUnchanged: false,
        }, ['_id', 'namespace', 'options']);
        sideEffects?.onError?.(err);
        throw transformedError;
    }
}
/**
 * Updates the booking status to `DECLINED` and updates the relevant session's
 * `participants.approvalStatus` to `DECLINED` without checking whether the relevant
 * slot or schedule is still available.
 *
 *
 * ## eCommerce checkout restriction
 *
 * Call this method only when using a custom checkout page. Don't
 * call it when using a *Wix eCommerce checkout*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/ecom/orders/setup) | [REST](https://dev.wix.com/docs/rest/business-solutions/e-commerce/checkout/introduction)).
 * In such cases, Wix automatically updates the booking status based on
 * the `paymentStatus` of the corresponding *Wix eCommerce order*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/ecom/checkout/setup) | [REST](https://dev.wix.com/docs/rest/business-solutions/e-commerce/orders/introduction)).
 *
 * ## When to call Confirm Or Decline Booking instead
 *
 * The method doesn't check whether a slot or schedule is still available. For
 * these checks you can call *Confirm or Decline Booking*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/bookings/confirm-or-decline-booking) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/bookings/bookings-writer-v2/confirm-or-decline-booking)).
 *
 * ## Original status validation
 *
 * You can only decline bookings with a `status` of `PENDING`, `CREATED`, or
 * `WAITING_LIST`.
 *
 * ## Payment status
 *
 * Also updates the booking's `paymentStatus`, if you specify a new payment
 * status.
 *
 * ## Notify customers
 *
 * You can specify a `participantNotification.message` for the customer. To send
 * the message, you must also specify `participantNotification.notifyParticipants`
 * as `true`.
 * @param bookingId - ID of the booking to decline.
 * @param revision - Revision number, which increments by 1 each time the booking is updated.
 *
 * To prevent conflicting changes, the current revision must be specified when
 * declining the booking.
 * @public
 * @requiredField bookingId
 * @requiredField revision
 * @param options - An object representing the available options for declining a booking.
 * @permissionId BOOKINGS.BOOKING_DECLINE
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @fqn com.wixpress.bookings.bookings.v2.Bookings.DeclineBooking
 */
export async function declineBooking(bookingId, revision, options) {
    // @ts-ignore
    const { httpClient, sideEffects } = arguments[3];
    const payload = renameKeysFromSDKRequestToRESTRequest({
        bookingId: bookingId,
        revision: revision,
        participantNotification: options?.participantNotification,
        paymentStatus: options?.paymentStatus,
        doubleBooked: options?.doubleBooked,
        flowControlSettings: options?.flowControlSettings,
    });
    const reqOpts = ambassadorWixBookingsV2Booking.bookingsDeclineBooking(payload);
    sideEffects?.onSiteCall?.();
    try {
        const result = await httpClient.request(reqOpts);
        sideEffects?.onSuccess?.(result);
        return renameKeysFromRESTResponseToSDKResponse(result.data);
    }
    catch (err) {
        const transformedError = sdkTransformError(err, {
            spreadPathsToArguments: {},
            explicitPathsToArguments: {
                bookingId: '$[0]',
                revision: '$[1]',
                participantNotification: '$[2].participantNotification',
                paymentStatus: '$[2].paymentStatus',
                doubleBooked: '$[2].doubleBooked',
                flowControlSettings: '$[2].flowControlSettings',
            },
            singleArgumentUnchanged: false,
        }, ['bookingId', 'revision', 'options']);
        sideEffects?.onError?.(err);
        throw transformedError;
    }
}
/**
 * Updates the booking status to `CANCELED`.
 *
 *
 * ## Appointments
 *
 * For appointments, the corresponding event is removed from the Bookings
 * calendar.
 *
 * ## Class and course bookings
 *
 * For class or course bookings, the relevant participants are removed
 * from the class session or the course. However, the class session or course
 * remain on the business calendar.
 *
 * ## Notify customers
 *
 * You can specify a `participantNotification.message` for the customer. To send
 * the message, you must also specify `participantNotification.notifyParticipants`
 * as `true`.
 *
 * ## Admin overwrites
 *
 * There are small but important differences when you specify special
 * `flowControlSettings`:
 *
 * - `{"ignoreCancellationPolicy": true}`: The call succeeds even if the
 * service's `cancellationPolicy` doesn't allow it.
 * - `{"withRefund": true}`: The customer is refunded even if the service's
 * `refundPolicy` doesn't allow it.
 * - `{"waiveCancellationFee": true}`: The customer doesn't have to pay
 * the cancellation fee, even if the service's `cancellationPolicy` requires it.
 *
 * When using special `flowControlSettings`, ensure you have sufficient
 * permissions. If you encounter failed calls due to insufficient permissions,
 * consider the following options:
 *
 * - **App developers** can use a higher
 * [permission](https://dev.wix.com/docs/build-apps/develop-your-app/access/authorization/about-permissions),
 * such as `MANAGE BOOKINGS - ALL PERMISSIONS`.
 * - **Site developers** can utilize
 * [elevation](https://dev.wix.com/docs/develop-websites/articles/coding-with-velo/authorization/elevation).
 *
 * Granting additional permissions and using elevation permits method calls that
 * would typically fail due to authorization checks. Therefore, you should use
 * them intentionally and securely.
 * @param bookingId - ID of the booking to cancel.
 * @public
 * @requiredField bookingId
 * @requiredField options.revision
 * @param options - An object representing the available options for canceling a booking.
 * @permissionId BOOKINGS.BOOKING_CANCEL
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @applicableIdentity MEMBER
 * @fqn com.wixpress.bookings.bookings.v2.Bookings.CancelBooking
 */
export async function cancelBooking(bookingId, options) {
    // @ts-ignore
    const { httpClient, sideEffects } = arguments[2];
    const payload = renameKeysFromSDKRequestToRESTRequest({
        bookingId: bookingId,
        participantNotification: options?.participantNotification,
        flowControlSettings: options?.flowControlSettings,
        revision: options?.revision,
    });
    const reqOpts = ambassadorWixBookingsV2Booking.bookingsCancelBooking(payload);
    sideEffects?.onSiteCall?.();
    try {
        const result = await httpClient.request(reqOpts);
        sideEffects?.onSuccess?.(result);
        return renameKeysFromRESTResponseToSDKResponse(result.data);
    }
    catch (err) {
        const transformedError = sdkTransformError(err, {
            spreadPathsToArguments: {},
            explicitPathsToArguments: {
                bookingId: '$[0]',
                participantNotification: '$[1].participantNotification',
                flowControlSettings: '$[1].flowControlSettings',
                revision: '$[1].revision',
            },
            singleArgumentUnchanged: false,
        }, ['bookingId', 'options']);
        sideEffects?.onError?.(err);
        throw transformedError;
    }
}
/**
 * Updates the number of participants for a class or course booking and changes
 * the `totalNumberOfParticipants` for the relevant sessions.
 *
 *
 * ## Appointment limitation
 *
 * You can't update the number of participants for appointment bookings.
 *
 * ## Participant information
 *
 * You must specify either `participantsChoices` or `totalParticipants`.
 * The call fails if the specified `participantsChoices` aren't among the
 * supported *service options and variants*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/service-options-and-variants/introduction) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/service-options-and-variants/introduction)).
 * @param bookingId - ID of the booking to update the number of participants for.
 * @public
 * @requiredField bookingId
 * @requiredField options.revision
 * @permissionId BOOKINGS.NUMBER_OF_PARTICIPANTS_UPDATE
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @fqn com.wixpress.bookings.bookings.v2.Bookings.UpdateNumberOfParticipants
 */
export async function updateNumberOfParticipants(bookingId, options) {
    // @ts-ignore
    const { httpClient, sideEffects } = arguments[2];
    const payload = renameKeysFromSDKRequestToRESTRequest({
        bookingId: bookingId,
        revision: options?.revision,
        totalParticipants: options?.totalParticipants,
        participantsChoices: options?.participantsChoices,
    });
    const reqOpts = ambassadorWixBookingsV2Booking.bookingsUpdateNumberOfParticipants(payload);
    sideEffects?.onSiteCall?.();
    try {
        const result = await httpClient.request(reqOpts);
        sideEffects?.onSuccess?.(result);
        return renameKeysFromRESTResponseToSDKResponse(result.data);
    }
    catch (err) {
        const transformedError = sdkTransformError(err, {
            spreadPathsToArguments: {},
            explicitPathsToArguments: {
                bookingId: '$[0]',
                revision: '$[1].revision',
                totalParticipants: '$[1].totalParticipants',
                participantsChoices: '$[1].participantsChoices',
            },
            singleArgumentUnchanged: false,
        }, ['bookingId', 'options']);
        sideEffects?.onError?.(err);
        throw transformedError;
    }
}
/**
 * Creates a multi-service booking.
 *
 *
 * See Create Booking for more information.
 * @param bookings - Single-service bookings to combine in a multi-service booking.
 * @public
 * @documentationMaturity preview
 * @requiredField bookings
 * @requiredField bookings.additionalFields._id
 * @requiredField bookings.bookedEntity
 * @requiredField bookings.bookedEntity.item
 * @requiredField bookings.bookedEntity.item.slot
 * @requiredField bookings.bookedEntity.item.slot.endDate
 * @requiredField bookings.bookedEntity.item.slot.location.locationType
 * @requiredField bookings.bookedEntity.item.slot.scheduleId
 * @requiredField bookings.bookedEntity.item.slot.startDate
 * @permissionId MULTI_SERVICE_BOOKINGS.MULTI_SERVICE_BOOKING_CREATE
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @applicableIdentity VISITOR
 * @fqn com.wixpress.bookings.bookings.v2.MultiServiceBookings.CreateMultiServiceBooking
 */
export async function createMultiServiceBooking(bookings, options) {
    // @ts-ignore
    const { httpClient, sideEffects } = arguments[2];
    const payload = renameKeysFromSDKRequestToRESTRequest({
        bookings: bookings,
        participantNotification: options?.participantNotification,
        sendSmsReminder: options?.sendSmsReminder,
        flowControlSettings: options?.flowControlSettings,
        returnFullEntity: options?.returnFullEntity,
        multiServiceBookingType: options?.multiServiceBookingType,
    });
    const reqOpts = ambassadorWixBookingsV2Booking.createMultiServiceBooking(payload);
    sideEffects?.onSiteCall?.();
    try {
        const result = await httpClient.request(reqOpts);
        sideEffects?.onSuccess?.(result);
        return renameKeysFromRESTResponseToSDKResponse(result.data);
    }
    catch (err) {
        const transformedError = sdkTransformError(err, {
            spreadPathsToArguments: {},
            explicitPathsToArguments: {
                bookings: '$[0]',
                participantNotification: '$[1].participantNotification',
                sendSmsReminder: '$[1].sendSmsReminder',
                flowControlSettings: '$[1].flowControlSettings',
                returnFullEntity: '$[1].returnFullEntity',
                multiServiceBookingType: '$[1].multiServiceBookingType',
            },
            singleArgumentUnchanged: false,
        }, ['bookings', 'options']);
        sideEffects?.onError?.(err);
        throw transformedError;
    }
}
/**
 * Reschedules a multi-service booking.
 *
 *
 * The call fails if at least 1 individual booking can't be rescheduled due
 * the service being unavailable or a rescheduling policy violation.
 *
 *
 * See Reschedule Booking for more information.
 * @param multiServiceBookingId - ID of the multi service booking to reschedule.
 * @param rescheduleBookingsInfo - Information about the single-service bookings to reschedule.
 * @public
 * @documentationMaturity preview
 * @requiredField multiServiceBookingId
 * @requiredField rescheduleBookingsInfo
 * @requiredField rescheduleBookingsInfo.bookingId
 * @requiredField rescheduleBookingsInfo.revision
 * @requiredField rescheduleBookingsInfo.slot
 * @permissionId MULTI_SERVICE_BOOKINGS.MULTI_SERVICE_BOOKING_RESCHEDULE
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @applicableIdentity MEMBER
 * @fqn com.wixpress.bookings.bookings.v2.MultiServiceBookings.RescheduleMultiServiceBooking
 */
export async function rescheduleMultiServiceBooking(multiServiceBookingId, rescheduleBookingsInfo, options) {
    // @ts-ignore
    const { httpClient, sideEffects } = arguments[3];
    const payload = renameKeysFromSDKRequestToRESTRequest({
        multiServiceBookingId: multiServiceBookingId,
        rescheduleBookingsInfo: rescheduleBookingsInfo,
        participantNotification: options?.participantNotification,
        flowControlSettings: options?.flowControlSettings,
        returnFullEntity: options?.returnFullEntity,
    });
    const reqOpts = ambassadorWixBookingsV2Booking.rescheduleMultiServiceBooking(payload);
    sideEffects?.onSiteCall?.();
    try {
        const result = await httpClient.request(reqOpts);
        sideEffects?.onSuccess?.(result);
        return renameKeysFromRESTResponseToSDKResponse(result.data);
    }
    catch (err) {
        const transformedError = sdkTransformError(err, {
            spreadPathsToArguments: {},
            explicitPathsToArguments: {
                multiServiceBookingId: '$[0]',
                rescheduleBookingsInfo: '$[1]',
                participantNotification: '$[2].participantNotification',
                flowControlSettings: '$[2].flowControlSettings',
                returnFullEntity: '$[2].returnFullEntity',
            },
            singleArgumentUnchanged: false,
        }, ['multiServiceBookingId', 'rescheduleBookingsInfo', 'options']);
        sideEffects?.onError?.(err);
        throw transformedError;
    }
}
/**
 * Retrieves a multi-service booking's availability.
 *
 *
 * Use List Multi Service Availability Time Slots to check availability for a
 * `SEQUENTIAL_BOOKINGS` multi-service booking.
 * @param multiServiceBookingId - ID of the multi-service booking to retrieve.
 * @public
 * @documentationMaturity preview
 * @requiredField multiServiceBookingId
 * @permissionId MULTI_SERVICE_BOOKINGS.MULTI_SERVICE_BOOKING_GET_AVAILABILITY
 * @permissionScope Read Bookings - Public Data
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-PUBLIC
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Read Bookings - Including Participants
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-SENSITIVE
 * @permissionScope Read Bookings - all read permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.READ-BOOKINGS
 * @permissionScope Read Bookings Calendar Availability
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-CALENDAR
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @applicableIdentity VISITOR
 * @fqn com.wixpress.bookings.bookings.v2.MultiServiceBookings.GetMultiServiceBookingAvailability
 */
export async function getMultiServiceBookingAvailability(multiServiceBookingId) {
    // @ts-ignore
    const { httpClient, sideEffects } = arguments[1];
    const payload = renameKeysFromSDKRequestToRESTRequest({
        multiServiceBookingId: multiServiceBookingId,
    });
    const reqOpts = ambassadorWixBookingsV2Booking.getMultiServiceBookingAvailability(payload);
    sideEffects?.onSiteCall?.();
    try {
        const result = await httpClient.request(reqOpts);
        sideEffects?.onSuccess?.(result);
        return renameKeysFromRESTResponseToSDKResponse(result.data);
    }
    catch (err) {
        const transformedError = sdkTransformError(err, {
            spreadPathsToArguments: {},
            explicitPathsToArguments: { multiServiceBookingId: '$[0]' },
            singleArgumentUnchanged: false,
        }, ['multiServiceBookingId']);
        sideEffects?.onError?.(err);
        throw transformedError;
    }
}
/**
 * Cancels a multi-service booking and thus all its individual bookings.
 * @param multiServiceBookingId - ID of the multi-service booking to cancel.
 * @public
 * @documentationMaturity preview
 * @requiredField multiServiceBookingId
 * @permissionId MULTI_SERVICE_BOOKINGS.MULTI_SERVICE_BOOKING_CANCEL
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @applicableIdentity MEMBER
 * @fqn com.wixpress.bookings.bookings.v2.MultiServiceBookings.CancelMultiServiceBooking
 */
export async function cancelMultiServiceBooking(multiServiceBookingId, options) {
    // @ts-ignore
    const { httpClient, sideEffects } = arguments[2];
    const payload = renameKeysFromSDKRequestToRESTRequest({
        multiServiceBookingId: multiServiceBookingId,
        participantNotification: options?.participantNotification,
        flowControlSettings: options?.flowControlSettings,
        returnFullEntity: options?.returnFullEntity,
    });
    const reqOpts = ambassadorWixBookingsV2Booking.cancelMultiServiceBooking(payload);
    sideEffects?.onSiteCall?.();
    try {
        const result = await httpClient.request(reqOpts);
        sideEffects?.onSuccess?.(result);
        return renameKeysFromRESTResponseToSDKResponse(result.data);
    }
    catch (err) {
        const transformedError = sdkTransformError(err, {
            spreadPathsToArguments: {},
            explicitPathsToArguments: {
                multiServiceBookingId: '$[0]',
                participantNotification: '$[1].participantNotification',
                flowControlSettings: '$[1].flowControlSettings',
                returnFullEntity: '$[1].returnFullEntity',
            },
            singleArgumentUnchanged: false,
        }, ['multiServiceBookingId', 'options']);
        sideEffects?.onError?.(err);
        throw transformedError;
    }
}
/**
 * Updates the status of a multi-service booking to `PENDING`.
 *
 *
 * Also updates the status of each of individual bookings within the multi-service booking to `PENDING`.
 *
 * The call fails if the status for at least a single individual booking can't be updated.
 *
 * See Mark Booking as Pending for more information.
 * @param multiServiceBookingId - ID of the multi-service booking to mark as `PENDING`.
 * @public
 * @documentationMaturity preview
 * @requiredField multiServiceBookingId
 * @permissionId MULTI_SERVICE_BOOKINGS.MULTI_SERVICE_BOOKING_MARK_AS_PENDING
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @fqn com.wixpress.bookings.bookings.v2.MultiServiceBookings.MarkMultiServiceBookingAsPending
 */
export async function markMultiServiceBookingAsPending(multiServiceBookingId, options) {
    // @ts-ignore
    const { httpClient, sideEffects } = arguments[2];
    const payload = renameKeysFromSDKRequestToRESTRequest({
        multiServiceBookingId: multiServiceBookingId,
        markAsPendingBookingsInfo: options?.markAsPendingBookingsInfo,
        participantNotification: options?.participantNotification,
        sendSmsReminder: options?.sendSmsReminder,
        doubleBooked: options?.doubleBooked,
        returnFullEntity: options?.returnFullEntity,
        flowControlSettings: options?.flowControlSettings,
    });
    const reqOpts = ambassadorWixBookingsV2Booking.markMultiServiceBookingAsPending(payload);
    sideEffects?.onSiteCall?.();
    try {
        const result = await httpClient.request(reqOpts);
        sideEffects?.onSuccess?.(result);
        return renameKeysFromRESTResponseToSDKResponse(result.data);
    }
    catch (err) {
        const transformedError = sdkTransformError(err, {
            spreadPathsToArguments: {},
            explicitPathsToArguments: {
                multiServiceBookingId: '$[0]',
                markAsPendingBookingsInfo: '$[1].markAsPendingBookingsInfo',
                participantNotification: '$[1].participantNotification',
                sendSmsReminder: '$[1].sendSmsReminder',
                doubleBooked: '$[1].doubleBooked',
                returnFullEntity: '$[1].returnFullEntity',
                flowControlSettings: '$[1].flowControlSettings',
            },
            singleArgumentUnchanged: false,
        }, ['multiServiceBookingId', 'options']);
        sideEffects?.onError?.(err);
        throw transformedError;
    }
}
/**
 * Updates the status of a multi-service booking to `CONFIRMED`.
 *
 *
 * Also updates the status of each of individual bookings within the multi-service booking to `CONFIRMED`.
 *
 * The call fails if the status for at least a single individual booking can't be updated.
 *
 * See Confirm Booking for more information.
 * @param multiServiceBookingId - ID of the multi-service booking to confirm its related bookings.
 * @public
 * @documentationMaturity preview
 * @requiredField multiServiceBookingId
 * @permissionId MULTI_SERVICE_BOOKINGS.MULTI_SERVICE_BOOKING_CONFIRM
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @fqn com.wixpress.bookings.bookings.v2.MultiServiceBookings.ConfirmMultiServiceBooking
 */
export async function confirmMultiServiceBooking(multiServiceBookingId, options) {
    // @ts-ignore
    const { httpClient, sideEffects } = arguments[2];
    const payload = renameKeysFromSDKRequestToRESTRequest({
        multiServiceBookingId: multiServiceBookingId,
        confirmBookingsInfo: options?.confirmBookingsInfo,
        participantNotification: options?.participantNotification,
        sendSmsReminder: options?.sendSmsReminder,
        doubleBooked: options?.doubleBooked,
        returnFullEntity: options?.returnFullEntity,
        flowControlSettings: options?.flowControlSettings,
    });
    const reqOpts = ambassadorWixBookingsV2Booking.confirmMultiServiceBooking(payload);
    sideEffects?.onSiteCall?.();
    try {
        const result = await httpClient.request(reqOpts);
        sideEffects?.onSuccess?.(result);
        return renameKeysFromRESTResponseToSDKResponse(result.data);
    }
    catch (err) {
        const transformedError = sdkTransformError(err, {
            spreadPathsToArguments: {},
            explicitPathsToArguments: {
                multiServiceBookingId: '$[0]',
                confirmBookingsInfo: '$[1].confirmBookingsInfo',
                participantNotification: '$[1].participantNotification',
                sendSmsReminder: '$[1].sendSmsReminder',
                doubleBooked: '$[1].doubleBooked',
                returnFullEntity: '$[1].returnFullEntity',
                flowControlSettings: '$[1].flowControlSettings',
            },
            singleArgumentUnchanged: false,
        }, ['multiServiceBookingId', 'options']);
        sideEffects?.onError?.(err);
        throw transformedError;
    }
}
/**
 * Updates the status of a multi-service booking to `DECLINED`.
 *
 *
 * Also updates the status of each of individual bookings within the multi-service booking to `DECLINED`.
 *
 * The call fails if the status for at least a single individual booking can't be updated.
 *
 * See Decline Booking for more information.
 * @param multiServiceBookingId - ID of the multi service booking to decline.
 * @public
 * @documentationMaturity preview
 * @requiredField multiServiceBookingId
 * @permissionId MULTI_SERVICE_BOOKINGS.MULTI_SERVICE_BOOKING_DECLINE
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @fqn com.wixpress.bookings.bookings.v2.MultiServiceBookings.DeclineMultiServiceBooking
 */
export async function declineMultiServiceBooking(multiServiceBookingId, options) {
    // @ts-ignore
    const { httpClient, sideEffects } = arguments[2];
    const payload = renameKeysFromSDKRequestToRESTRequest({
        multiServiceBookingId: multiServiceBookingId,
        declineBookingsInfo: options?.declineBookingsInfo,
        participantNotification: options?.participantNotification,
        doubleBooked: options?.doubleBooked,
        returnFullEntity: options?.returnFullEntity,
        flowControlSettings: options?.flowControlSettings,
    });
    const reqOpts = ambassadorWixBookingsV2Booking.declineMultiServiceBooking(payload);
    sideEffects?.onSiteCall?.();
    try {
        const result = await httpClient.request(reqOpts);
        sideEffects?.onSuccess?.(result);
        return renameKeysFromRESTResponseToSDKResponse(result.data);
    }
    catch (err) {
        const transformedError = sdkTransformError(err, {
            spreadPathsToArguments: {},
            explicitPathsToArguments: {
                multiServiceBookingId: '$[0]',
                declineBookingsInfo: '$[1].declineBookingsInfo',
                participantNotification: '$[1].participantNotification',
                doubleBooked: '$[1].doubleBooked',
                returnFullEntity: '$[1].returnFullEntity',
                flowControlSettings: '$[1].flowControlSettings',
            },
            singleArgumentUnchanged: false,
        }, ['multiServiceBookingId', 'options']);
        sideEffects?.onError?.(err);
        throw transformedError;
    }
}
/**
 * Retrieves the allowed actions for a list of multi-service bookings.
 * @param multiServiceBookingIds - IDs of the multi-service bookings to retrieve allowed actions for.
 * @public
 * @documentationMaturity preview
 * @requiredField multiServiceBookingIds
 * @permissionId MULTI_SERVICE_BOOKINGS.MULTI_SERVICE_BOOKING_GET_ALLOWED_ACTIONS
 * @permissionScope Read Bookings - Public Data
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-PUBLIC
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Read Bookings - Including Participants
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-SENSITIVE
 * @permissionScope Read Bookings - all read permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.READ-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @applicableIdentity VISITOR
 * @fqn com.wixpress.bookings.bookings.v2.MultiServiceBookings.BulkGetMultiServiceBookingAllowedActions
 */
export async function bulkGetMultiServiceBookingAllowedActions(multiServiceBookingIds) {
    // @ts-ignore
    const { httpClient, sideEffects } = arguments[1];
    const payload = renameKeysFromSDKRequestToRESTRequest({
        multiServiceBookingIds: multiServiceBookingIds,
    });
    const reqOpts = ambassadorWixBookingsV2Booking.bulkGetMultiServiceBookingAllowedActions(payload);
    sideEffects?.onSiteCall?.();
    try {
        const result = await httpClient.request(reqOpts);
        sideEffects?.onSuccess?.(result);
        return renameKeysFromRESTResponseToSDKResponse(result.data);
    }
    catch (err) {
        const transformedError = sdkTransformError(err, {
            spreadPathsToArguments: {},
            explicitPathsToArguments: { multiServiceBookingIds: '$[0]' },
            singleArgumentUnchanged: false,
        }, ['multiServiceBookingIds']);
        sideEffects?.onError?.(err);
        throw transformedError;
    }
}
/**
 * Retrieves all single-service bookings belonging to a multi-service booking.
 *
 *
 * If you call as an [identity](https://dev.wix.com/docs/build-apps/develop-your-app/access/about-identities)
 * who has permissions to read only part of the bookings,
 * only the permitted bookings are retrieved. The returned total number of
 * bookings includes also the bookings for which you don't have permissions.
 * @param multiServiceBookingId - ID of the multi-service booking.
 * @public
 * @documentationMaturity preview
 * @requiredField multiServiceBookingId
 * @permissionId MULTI_SERVICE_BOOKINGS.MULTI_SERVICE_BOOKING_READ
 * @permissionScope Read Bookings - Public Data
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-PUBLIC
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Read Bookings - Including Participants
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-SENSITIVE
 * @permissionScope Read Bookings - all read permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.READ-BOOKINGS
 * @permissionScope Read Bookings Calendar Availability
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-CALENDAR
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @returns Retrieved multi-service booking.
 * @fqn com.wixpress.bookings.bookings.v2.MultiServiceBookings.GetMultiServiceBooking
 */
export async function getMultiServiceBooking(multiServiceBookingId) {
    // @ts-ignore
    const { httpClient, sideEffects } = arguments[1];
    const payload = renameKeysFromSDKRequestToRESTRequest({
        multiServiceBookingId: multiServiceBookingId,
    });
    const reqOpts = ambassadorWixBookingsV2Booking.getMultiServiceBooking(payload);
    sideEffects?.onSiteCall?.();
    try {
        const result = await httpClient.request(reqOpts);
        sideEffects?.onSuccess?.(result);
        return renameKeysFromRESTResponseToSDKResponse(result.data)
            ?.multiServiceBooking;
    }
    catch (err) {
        const transformedError = sdkTransformError(err, {
            spreadPathsToArguments: {},
            explicitPathsToArguments: { multiServiceBookingId: '$[0]' },
            singleArgumentUnchanged: false,
        }, ['multiServiceBookingId']);
        sideEffects?.onError?.(err);
        throw transformedError;
    }
}
/**
 * Adds a list of single-service bookings to a multi-service booking.
 *
 *
 * The call fails, if at least 1 of the specified booking is already part of a
 * multi-service booking.
 * @param multiServiceBookingId - ID of the multi-service booking.
 * @public
 * @documentationMaturity preview
 * @requiredField multiServiceBookingId
 * @requiredField options.bookings
 * @requiredField options.bookings.bookingId
 * @requiredField options.bookings.revision
 * @permissionId MULTI_SERVICE_BOOKINGS.MULTI_SERVICE_BOOKING_ADD_BOOKINGS
 * @fqn com.wixpress.bookings.bookings.v2.MultiServiceBookings.AddBookingsToMultiServiceBooking
 */
export async function addBookingsToMultiServiceBooking(multiServiceBookingId, options) {
    // @ts-ignore
    const { httpClient, sideEffects } = arguments[2];
    const payload = renameKeysFromSDKRequestToRESTRequest({
        multiServiceBookingId: multiServiceBookingId,
        bookings: options?.bookings,
        returnFullEntity: options?.returnFullEntity,
    });
    const reqOpts = ambassadorWixBookingsV2Booking.addBookingsToMultiServiceBooking(payload);
    sideEffects?.onSiteCall?.();
    try {
        const result = await httpClient.request(reqOpts);
        sideEffects?.onSuccess?.(result);
        return renameKeysFromRESTResponseToSDKResponse(result.data);
    }
    catch (err) {
        const transformedError = sdkTransformError(err, {
            spreadPathsToArguments: {},
            explicitPathsToArguments: {
                multiServiceBookingId: '$[0]',
                bookings: '$[1].bookings',
                returnFullEntity: '$[1].returnFullEntity',
            },
            singleArgumentUnchanged: false,
        }, ['multiServiceBookingId', 'options']);
        sideEffects?.onError?.(err);
        throw transformedError;
    }
}
/**
 * Removes single-service bookings from a multi-service booking and returns the
 * removed bookings.
 *
 *
 * If you specify an empty `bookings` array, all single-service bookings for which
 * the call's [identity](https://dev.wix.com/docs/build-apps/develop-your-app/access/about-identities)
 * has read permissions are removed from the multi-service booking.
 *
 * If the call would create a multi-service booking including only 1 single-service
 * booking, the multi-service booking is also deleted.
 * @param multiServiceBookingId - ID of the multi-service booking.
 * @public
 * @documentationMaturity preview
 * @requiredField multiServiceBookingId
 * @permissionId MULTI_SERVICE_BOOKINGS.MULTI_SERVICE_BOOKING_REMOVE_BOOKINGS
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @fqn com.wixpress.bookings.bookings.v2.MultiServiceBookings.RemoveBookingsFromMultiServiceBooking
 */
export async function removeBookingsFromMultiServiceBooking(multiServiceBookingId, options) {
    // @ts-ignore
    const { httpClient, sideEffects } = arguments[2];
    const payload = renameKeysFromSDKRequestToRESTRequest({
        multiServiceBookingId: multiServiceBookingId,
        bookings: options?.bookings,
        returnFullEntity: options?.returnFullEntity,
    });
    const reqOpts = ambassadorWixBookingsV2Booking.removeBookingsFromMultiServiceBooking(payload);
    sideEffects?.onSiteCall?.();
    try {
        const result = await httpClient.request(reqOpts);
        sideEffects?.onSuccess?.(result);
        return renameKeysFromRESTResponseToSDKResponse(result.data);
    }
    catch (err) {
        const transformedError = sdkTransformError(err, {
            spreadPathsToArguments: {},
            explicitPathsToArguments: {
                multiServiceBookingId: '$[0]',
                bookings: '$[1].bookings',
                returnFullEntity: '$[1].returnFullEntity',
            },
            singleArgumentUnchanged: false,
        }, ['multiServiceBookingId', 'options']);
        sideEffects?.onError?.(err);
        throw transformedError;
    }
}
//# sourceMappingURL=bookings-v2-booking-bookings.universal.js.map