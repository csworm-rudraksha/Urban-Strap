/**
 * The `serviceOptionsAndVariants` object links a *service*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/services/introduction) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/services-v2/introduction))
 * to its variants.
 * You can use it to offer customers different prices for a service,
 * depending on which choices they book.
 */
export interface ServiceOptionsAndVariants {
    /**
     * ID of the `serviceOptionsAndVariants` object.
     * @format GUID
     * @readonly
     */
    _id?: string | null;
    /**
     * ID of the service related to these options and variants.
     * @format GUID
     * @immutable
     */
    serviceId?: string | null;
    /** Service options. Note that currently only a single option is supported per service. */
    options?: ServiceOptions;
    /** Information about the service's variants. */
    variants?: ServiceVariants;
    /**
     * Price of the cheapest service variant.
     * @readonly
     */
    minPrice?: Money;
    /**
     * Price of the most expensive service variant.
     * @readonly
     */
    maxPrice?: Money;
    /**
     * Revision number, which increments by 1 each time the `serviceOptionsAndVariants` object is updated.
     * To prevent conflicting changes,
     * the current revision must be passed when updating and deleting the `serviceOptionsAndVariants` object.
     *
     * Ignored when creating a `serviceOptionsAndVariants` object.
     * @immutable
     */
    revision?: string | null;
    /** Extensions enabling users to save custom data related to service options and variants. */
    extendedFields?: ExtendedFields;
}
export interface ServiceOption extends ServiceOptionOptionSpecificDataOneOf {
    /** Details about the custom option. Available only for `CUSTOM` options. */
    customData?: CustomServiceOption;
    durationData?: DurationServiceOption;
    /**
     * ID of the service option.
     * @format GUID
     */
    _id?: string;
    /** Type of the service option. */
    type?: ServiceOptionType;
}
/** @oneof */
export interface ServiceOptionOptionSpecificDataOneOf {
    /** Details about the custom option. Available only for `CUSTOM` options. */
    customData?: CustomServiceOption;
    durationData?: DurationServiceOption;
}
export declare enum ServiceOptionType {
    /** There is no information about the option type. */
    UNKNOWN = "UNKNOWN",
    /**
     * The service option is based on a custom parameter. For example, age group,
     * booked equipment, or appointment timing.
     */
    CUSTOM = "CUSTOM",
    /**
     * It's a *staff member*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/staff-members/introduction) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/staff-members/introduction))
     * based option.
     */
    STAFF_MEMBER = "STAFF_MEMBER",
    /** It's a duration-based option. */
    DURATION = "DURATION"
}
export interface CustomServiceOption {
    /**
     * Name of the service option. For example, `Age group`, `Location`, `Equipment`,
     * or `Time`.
     * @maxLength 255
     */
    name?: string;
    /**
     * Available choices for the service option. For example, `child`, `student`,
     * `adult`, and `senior` for a service option named `Age group`. Each value must
     * be unique. The value's case is ignored, meaning `Child` and `child` are
     * considered to be identical. Currently, only a single choice is supported
     * because a service can have only a single option.
     *
     * Max: 1 choice
     * @maxSize 100
     * @maxLength 255
     */
    choices?: string[];
}
export interface DurationServiceOption {
    /**
     * Optional name of the duration option. For example, `Short Class`, or
     * `Extended Class`.
     * @maxLength 255
     */
    name?: string | null;
}
export interface ServiceVariant {
    /**
     * Choices for the service option. Currently, only a single choice is supported
     * because a service can have only a single option.
     *
     * Max: 1 choice
     * @minSize 1
     * @maxSize 1
     */
    choices?: ServiceChoice[];
    /** Information about the service variant's price. */
    price?: Money;
}
export interface ServiceChoice extends ServiceChoiceChoiceOneOf {
    /**
     * Name of the custom choice.
     * @maxLength 255
     */
    custom?: string;
    /**
     * ID of the *staff member*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/staff-members/introduction) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/staff-members/introduction))
     * providing the service.
     * @format GUID
     */
    staffMemberId?: string;
    /** Information about the option's duration. */
    duration?: Duration;
    /**
     * ID of the service option.
     * @format GUID
     */
    optionId?: string;
}
/** @oneof */
export interface ServiceChoiceChoiceOneOf {
    /**
     * Name of the custom choice.
     * @maxLength 255
     */
    custom?: string;
    /**
     * ID of the *staff member*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/staff-members/introduction) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/staff-members/introduction))
     * providing the service.
     * @format GUID
     */
    staffMemberId?: string;
    /** Information about the option's duration. */
    duration?: Duration;
}
export interface Duration {
    /**
     * Duration of the service in minutes.
     *
     * Min: `1` minute
     * Max: `44639` minutes (30 days, 23 hours, and 59 minutes)
     * @min 1
     * @max 44639
     */
    minutes?: number;
    /**
     * Name of the duration option.
     *
     * Default: Human-readable text of `minutes`. For example, `1 hr 30 min`.
     * @maxLength 255
     */
    name?: string | null;
}
/**
 * Money.
 * Default format to use. Sufficiently compliant with majority of standards: w3c, ISO 4217, ISO 20022, ISO 8583:2003.
 */
export interface Money {
    /**
     * Monetary amount. Decimal string with a period as a decimal separator (e.g., 3.99). Optionally, a single (-), to indicate that the amount is negative.
     * @format DECIMAL_VALUE
     * @decimalValue options { gte:0, maxScale:2 }
     */
    value?: string;
    /**
     * Currency code. Must be valid ISO 4217 currency code (e.g., USD).
     * @format CURRENCY
     */
    currency?: string;
    /**
     * Monetary amount. Decimal string in local format (e.g., 1 000,30). Optionally, a single (-), to indicate that the amount is negative.
     * @maxLength 50
     */
    formattedValue?: string | null;
}
export interface ServiceOptions {
    /**
     * Values of the service options.
     *
     * Max: 1 service option
     * @minSize 1
     * @maxSize 1
     */
    values?: ServiceOption[];
}
export interface ServiceVariants {
    /**
     * Values of the service variants.
     * @minSize 1
     * @maxSize 100
     */
    values?: ServiceVariant[];
}
export interface ExtendedFields {
    /**
     * Extended field data. Each key corresponds to the namespace of the app that created the extended fields.
     * The value of each key is structured according to the schema defined when the extended fields were configured.
     *
     * You can only access fields for which you have the appropriate permissions.
     *
     * Learn more about [extended fields](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields).
     */
    namespaces?: Record<string, Record<string, any>>;
}
export interface CreateServiceOptionsAndVariantsRequest {
    /** Service options and variants to create. */
    serviceOptionsAndVariants: ServiceOptionsAndVariants;
}
export interface CreateServiceOptionsAndVariantsResponse {
    /** Information about the created service options and variants. */
    serviceOptionsAndVariants?: ServiceOptionsAndVariants;
}
export interface CloneServiceOptionsAndVariantsRequest {
    /**
     * ID of the `serviceOptionsAndVariants` object to clone.
     * @format GUID
     */
    cloneFromId: string;
    /**
     * ID of the service to which the cloned `serviceOptionsAndVariants` are
     * connected.
     * @format GUID
     */
    targetServiceId: string;
}
export interface CloneServiceOptionsAndVariantsResponse {
    /** Cloned `serviceOptionsAndVariants` object. */
    serviceOptionsAndVariants?: ServiceOptionsAndVariants;
}
export interface GetServiceOptionsAndVariantsRequest {
    /**
     * ID of the `serviceOptionsAndVariants` object to retrieve.
     * @format GUID
     */
    serviceOptionsAndVariantsId: string;
}
export interface GetServiceOptionsAndVariantsResponse {
    /** Retrieved `serviceOptionsAndVariants` object. */
    serviceOptionsAndVariants?: ServiceOptionsAndVariants;
}
export interface GetServiceOptionsAndVariantsByServiceIdRequest {
    /**
     * ID of the service to retrieve options and variants for.
     * @format GUID
     */
    serviceId: string;
}
export interface GetServiceOptionsAndVariantsByServiceIdResponse {
    /** Retrieved `serviceOptionsAndVariants` object. */
    serviceVariants?: ServiceOptionsAndVariants;
}
export interface UpdateServiceOptionsAndVariantsRequest {
    /** `ServiceOptionsAndVariants` object to update. */
    serviceOptionsAndVariants: ServiceOptionsAndVariants;
}
export interface UpdateServiceOptionsAndVariantsResponse {
    /** Updated `serviceOptionsAndVariants` object. */
    serviceOptionsAndVariants?: ServiceOptionsAndVariants;
}
export interface DeleteServiceOptionsAndVariantsRequest {
    /**
     * ID of the `serviceOptionsAndVariants` object to delete.
     * @format GUID
     */
    serviceOptionsAndVariantsId: string;
    /** Revision of the `serviceOptionsAndVariants` object to delete. */
    revision?: string;
}
export interface DeleteServiceOptionsAndVariantsResponse {
}
export interface QueryServiceOptionsAndVariantsRequest {
    /** Information about filters, paging, and returned fields. */
    query: QueryV2;
}
export interface QueryV2 extends QueryV2PagingMethodOneOf {
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
    /**
     * Filter object.
     *
     * Learn more about the [filter section](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-filter-section).
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object.
     *
     * Learn more about the [sort section](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#the-sort-section).
     * @maxSize 10
     */
    sort?: Sorting[];
}
/** @oneof */
export interface QueryV2PagingMethodOneOf {
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
}
export interface Sorting {
    /**
     * Name of the field to sort by.
     * @maxLength 512
     */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrder;
}
export declare enum SortOrder {
    ASC = "ASC",
    DESC = "DESC"
}
export interface Paging {
    /** Number of items to load. */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
export interface CursorPaging {
    /**
     * Maximum number of items to return in the results.
     * @max 100
     */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * Pass the relevant cursor token from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     * @maxLength 16000
     */
    cursor?: string | null;
}
export interface QueryServiceOptionsAndVariantsResponse {
    /** Retrieved `serviceOptionsAndVariants` objects. */
    serviceOptionsAndVariantsList?: ServiceOptionsAndVariants[];
    /** Paging metadata. */
    pagingMetadata?: PagingMetadataV2;
}
export interface PagingMetadataV2 {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Offset that was requested. */
    offset?: number | null;
    /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
    total?: number | null;
    /** Flag that indicates the server failed to calculate the `total` field. */
    tooManyToCount?: boolean | null;
    /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
    cursors?: Cursors;
}
export interface Cursors {
    /**
     * Cursor string pointing to the next page in the list of results.
     * @maxLength 16000
     */
    next?: string | null;
    /**
     * Cursor pointing to the previous page in the list of results.
     * @maxLength 16000
     */
    prev?: string | null;
}
export interface ResourceNotification {
    /**
     * Updated resource entity.
     * 'resource.schedules' is deprecated and will not be returned. Please use 'resource.scheduleIds' instead.
     */
    resource?: Resource;
    /** Event type. */
    event?: Event;
}
export interface Resource {
    /**
     * Resource ID.
     * @format GUID
     * @readonly
     */
    _id?: string | null;
    /**
     * Resource name.
     * @maxLength 1200
     */
    name?: string | null;
    /**
     * Resource email address.
     * @maxLength 500
     */
    email?: string | null;
    /**
     * Resource phone number.
     * @maxLength 500
     */
    phone?: string | null;
    /**
     * Resource description.
     * @maxLength 500
     */
    description?: string | null;
    /**
     * Deprecated. Please use tags.
     * @maxLength 500
     * @deprecated
     */
    tag?: string | null;
    /**
     * Resource tags. Tags are used to identify, group, and filter the different types of resources. For example, 'staff' or 'room'.
     * @maxLength 200
     */
    tags?: string[] | null;
    /** Resource images. */
    images?: string[];
    /**
     * Deprecated. Please use scheduleIds. List of the schedules owned by this resource. Min size 1.
     * @deprecated
     */
    schedules?: Schedule[];
    /**
     * List of IDs of schedules owned by this resource.
     * @format GUID
     * @readonly
     */
    scheduleIds?: string[] | null;
    /**
     * Resource status. Default: `CREATED`.
     * @readonly
     */
    status?: ResourceStatus;
    /**
     * Wix user ID, if the resource is associated with the Wix user.
     * A staff member resource can be associated with a Wix user via assignment of a permissions role in the business manager.
     * @format GUID
     * @readonly
     */
    wixUserId?: string | null;
}
export interface FocalPoint {
    /** X-coordinate of the focal point. */
    x?: number;
    /** Y-coordinate of the focal point. */
    y?: number;
    /** crop by height */
    height?: number | null;
    /** crop by width */
    width?: number | null;
}
export interface Schedule {
    /** Schedule ID. */
    _id?: string;
    /** ID of the schedule's owner entity. This may be a resource ID or a service ID. */
    scheduleOwnerId?: string | null;
    /**
     * Schedule's time zone in [Area/Location](https://en.wikipedia.org/wiki/Tz_database) format. Read-only.
     * Derived from the Wix Business time zone.
     * @readonly
     */
    timeZone?: string | null;
    /**
     * Deprecated. Please use the [Sessions API](https://dev.wix.com/api/rest/wix-bookings/schedules-and-sessions/session) instead.
     * @deprecated
     */
    intervals?: RecurringInterval[];
    /**
     * Default title for the schedule's sessions. Maximum length: 6000 characters.
     * @maxLength 6000
     */
    title?: string | null;
    /**
     * __Deprecated.__
     * Tags for grouping schedules. These tags are the default tags for the schedule's sessions.
     * The Wix Bookings app uses the following predefined tags to set schedule type: `"INDIVIDUAL"`, `"GROUP"`, and `"COURSE"`. Once the schedule type is set using these tags, you cannot update it. In addition to the app's tags, you can create and update your own tags.
     * @deprecated
     */
    tags?: string[] | null;
    /** Default location for the schedule's sessions. */
    location?: Location;
    /**
     * Maximum number of participants that can be added to the schedule's sessions.
     * Must be at most `1` for schedule whose availability is affected by another schedule. E.g, appointment schedules of the Wix Bookings app.
     * @min 1
     * @max 1000
     */
    capacity?: number | null;
    /**
     * Deprecated. Please use the [Booking Services V2](https://dev.wix.com/api/rest/wix-bookings/services-v2) payment instead.
     * @deprecated
     */
    rate?: Rate;
    /**
     * __Deprecated.__
     * @deprecated
     */
    availability?: Availability;
    /**
     * Number of participants registered to sessions in this schedule, calculated as the sum of the party sizes.
     * @readonly
     */
    totalNumberOfParticipants?: number;
    /**
     * *Partial list** of participants which are registered to sessions in this schedule.
     * Participants who are registered in the schedule are automatically registered to any session that is created for the schedule.
     * To retrieve the full list of schedule participants please use the [Query Extended Bookings API](https://dev.wix.com/api/rest/wix-bookings/bookings-reader-v2/query-extended-bookings).
     * @readonly
     */
    participants?: Participant[];
    /**
     * __Deprecated.__
     * @deprecated
     */
    externalCalendarOverrides?: ExternalCalendarOverrides;
    /**
     * Schedule status. Default: Created
     * @readonly
     */
    status?: ScheduleStatus;
    /**
     * Schedule creation date.
     * @readonly
     */
    created?: Date | null;
    /**
     * Schedule last update date.
     * @readonly
     */
    updated?: Date | null;
    /**
     * Schedule version number, updated each time the schedule is updated.
     * @readonly
     */
    version?: number;
    /**
     * Fields which were inherited from the Business Info page under Settings in the Dashboard.
     * @readonly
     */
    inheritedFields?: string[];
    /**
     * __Deprecated.__
     * @deprecated
     */
    conferenceProvider?: ConferenceProvider;
    /**
     * A conference created for the schedule. This is used when a participant is added to a schedule.
     * **Partially deprecated.** Only `hostUrl` and `guestUrl` are to be supported.
     * @deprecated
     */
    calendarConference?: CalendarConference;
}
export interface RecurringInterval {
    /**
     * The recurring interval identifier.
     * @readonly
     */
    _id?: string;
    /** The start time of the recurring interval. Required. */
    start?: Date | null;
    /** The end time of the recurring interval. Optional. Empty value indicates that there is no end time. */
    end?: Date | null;
    /** The interval rules. The day, hour and minutes the interval is recurring. */
    interval?: Interval;
    /** The frequency of the interval. Optional. The default is frequency with the default repetition. */
    frequency?: Frequency;
    /** Specifies the list of linked schedules and the way this link affects the corresponding schedules' availability. Can be calculated from the schedule or overridden on the recurring interval. */
    affectedSchedules?: LinkedSchedule[];
    /** The type of recurring interval. */
    intervalType?: RecurringIntervalType;
}
export interface Interval {
    /** The day the interval occurs. Optional. The default is the day of the recurring interval's start time. */
    daysOfWeek?: Day;
    /**
     * The hour of the day the interval occurs. Must be consistent with the interval start time. Optional. The default is 0. Minimum: 0, maximum: 23.
     * @max 23
     */
    hourOfDay?: number | null;
    /**
     * The minutes of the hour the interval accrues. Must be consistent with the interval end time. Optional. The default is 0. Minimum: 0, maximum: 59.
     * @max 59
     */
    minuteOfHour?: number | null;
    /** The duration of the interval in minutes. Required. Part of the session end time calculation. */
    duration?: number;
}
export declare enum Day {
    /** Undefined. */
    UNDEFINED = "UNDEFINED",
    /** Monday. */
    MON = "MON",
    /** Tuesday. */
    TUE = "TUE",
    /** Wednesday. */
    WED = "WED",
    /** Thursday. */
    THU = "THU",
    /** Friday. */
    FRI = "FRI",
    /** Saturday. */
    SAT = "SAT",
    /** Sunday. */
    SUN = "SUN"
}
export interface Frequency {
    /**
     * The frequency of the recurrence in weeks. i.e. when this value is 4, the interval occurs every 4 weeks. Optional. The default is 1. minimum: 1, maximum: 52.
     * @min 1
     * @max 52
     */
    repetition?: number | null;
}
export interface LinkedSchedule {
    /**
     * Schedule ID.
     * @format GUID
     */
    scheduleId?: string;
    /** Sets this schedule's availability for the duration of the linked schedule's sessions. Default is `"BUSY"`. */
    transparency?: Transparency;
    /**
     * Owner ID, of the linked schedule.
     * @readonly
     */
    scheduleOwnerId?: string;
}
export declare enum Transparency {
    UNDEFINED = "UNDEFINED",
    /** The schedule can have available slots during the linked schedule's sessions. */
    FREE = "FREE",
    /** The schedule can't have available slots during the linked schedule's sessions. */
    BUSY = "BUSY"
}
export declare enum RecurringIntervalType {
    /** The default value. Sessions for this interval will be of type EVENT. */
    UNDEFINED = "UNDEFINED",
    /** A recurring interval of events. */
    EVENT = "EVENT",
    /** Deprecated. */
    TIME_AVAILABILITY = "TIME_AVAILABILITY",
    /** A recurring interval for availability. */
    AVAILABILITY = "AVAILABILITY"
}
export interface Location {
    /**
     * Location type.
     * One of:
     * - `"OWNER_BUSINESS"` The business address as set in the site’s general settings.
     * - `"OWNER_CUSTOM"` The address as set when creating the service.
     * - `"CUSTOM"` The address set for the individual session.
     */
    locationType?: LocationType;
    /**
     * Free text address used when locationType is `OWNER_CUSTOM`.
     * @deprecated
     */
    address?: string | null;
    /** Custom address, used when locationType is `"OWNER_CUSTOM"`. Might be used when locationType is `"CUSTOM"` in case the owner sets a custom address for the session which is different from the default. */
    customAddress?: Address;
}
export declare enum LocationType {
    UNDEFINED = "UNDEFINED",
    OWNER_BUSINESS = "OWNER_BUSINESS",
    OWNER_CUSTOM = "OWNER_CUSTOM",
    CUSTOM = "CUSTOM"
}
/** Physical address */
export interface Address extends AddressStreetOneOf {
    /** Street name, number and apartment number. */
    streetAddress?: StreetAddress;
    /** Main address line, usually street and number, as free text. */
    addressLine?: string | null;
    /**
     * Country code.
     * @format COUNTRY
     */
    country?: string | null;
    /** Subdivision. Usually state, region, prefecture or province code, according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). */
    subdivision?: string | null;
    /** City name. */
    city?: string | null;
    /** Zip/postal code. */
    postalCode?: string | null;
    /** Free text providing more detailed address info. Usually contains Apt, Suite, and Floor. */
    addressLine2?: string | null;
    /** A string containing the full address of this location. */
    formattedAddress?: string | null;
    /** Free text to help find the address. */
    hint?: string | null;
    /** Coordinates of the physical address. */
    geocode?: AddressLocation;
    /** Country full name. */
    countryFullname?: string | null;
    /** Multi-level subdivisions from top to bottom. */
    subdivisions?: Subdivision[];
}
/** @oneof */
export interface AddressStreetOneOf {
    /** Street name, number and apartment number. */
    streetAddress?: StreetAddress;
    /** Main address line, usually street and number, as free text. */
    addressLine?: string | null;
}
export interface StreetAddress {
    /** Street number. */
    number?: string;
    /** Street name. */
    name?: string;
    /** Apartment number. */
    apt?: string;
}
export interface AddressLocation {
    /** Address latitude. */
    latitude?: number | null;
    /** Address longitude. */
    longitude?: number | null;
}
export interface Subdivision {
    /** Subdivision code. Usually state, region, prefecture or province code, according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). */
    code?: string;
    /** Subdivision full name. */
    name?: string;
}
export interface LocationsLocation {
    /**
     * Location ID.
     * @format GUID
     * @readonly
     */
    _id?: string | null;
    /**
     * Location name.
     * @maxLength 150
     */
    name?: string;
    /**
     * Location description.
     * @maxLength 500
     */
    description?: string | null;
    /**
     * Whether this is the default location. There can only be one default location per site. The default location can't be archived.
     * @readonly
     */
    default?: boolean;
    /**
     * Location status. Defaults to `ACTIVE`.
     * __Notes:__
     * - [Archiving a location](https://dev.wix.com/api/rest/business-info/locations/archive-location)
     * doesn't affect the location's status.
     * - `INACTIVE` status is currently not supported.
     */
    status?: LocationStatus;
    /**
     * Location type.
     *
     * **Note:** Currently not supported.
     * @deprecated
     */
    locationType?: LocationsLocationType;
    /** Fax number. */
    fax?: string | null;
    /** Timezone in `America/New_York` format. */
    timeZone?: string | null;
    /** Email address. */
    email?: string | null;
    /** Phone number. */
    phone?: string | null;
    /** Address. */
    address?: LocationsAddress;
    /**
     * Business schedule. Array of weekly recurring time periods when the location is open for business. Limited to 100 time periods.
     *
     * __Note:__ Not supported by Wix Bookings.
     */
    businessSchedule?: BusinessSchedule;
    /**
     * Revision number, which increments by 1 each time the location is updated.
     * To prevent conflicting changes, the existing revision must be used when updating a location.
     */
    revision?: string | null;
    /**
     * Whether the location is archived. Archived locations can't be updated.
     * __Note:__ [Archiving a location](https://dev.wix.com/api/rest/business-info/locations/archive-location)
     * doesn't affect its `status`.
     * @readonly
     */
    archived?: boolean;
    /**
     * Location types.
     * @maxSize 10
     */
    locationTypes?: LocationsLocationType[];
}
/** For future use */
export declare enum LocationStatus {
    ACTIVE = "ACTIVE",
    INACTIVE = "INACTIVE"
}
/** For future use */
export declare enum LocationsLocationType {
    UNKNOWN = "UNKNOWN",
    BRANCH = "BRANCH",
    OFFICES = "OFFICES",
    RECEPTION = "RECEPTION",
    HEADQUARTERS = "HEADQUARTERS",
    INVENTORY = "INVENTORY"
}
export interface LocationsAddress {
    /**
     * 2-letter country code in an [ISO-3166 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
     * @format COUNTRY
     */
    country?: string | null;
    /** Code for a subdivision (such as state, prefecture, or province) in [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) format. */
    subdivision?: string | null;
    /** City name. */
    city?: string | null;
    /**
     * Postal or zip code.
     * @maxLength 20
     */
    postalCode?: string | null;
    /** Street address. Includes street name, number, and apartment number in separate fields. */
    streetAddress?: LocationsStreetAddress;
    /** Full address of the location. */
    formatted?: string | null;
    /** Geographic coordinates of location. */
    location?: LocationsAddressLocation;
}
/** Street address. Includes street name, number, and apartment number in separate fields. */
export interface LocationsStreetAddress {
    /** Street number. */
    number?: string;
    /** Street name. */
    name?: string;
    /** Apartment number. */
    apt?: string;
}
/** Address Geolocation */
export interface LocationsAddressLocation {
    /** Latitude of the location. Must be between -90 and 90. */
    latitude?: number | null;
    /** Longitude of the location. Must be between -180 and 180. */
    longitude?: number | null;
}
/** Business schedule. Regular and exceptional time periods when the business is open or the service is available. */
export interface BusinessSchedule {
    /**
     * Weekly recurring time periods when the business is regularly open or the service is available. Limited to 100 time periods.
     * @maxSize 100
     */
    periods?: TimePeriod[];
    /**
     * Exceptions to the business's regular hours. The business can be open or closed during the exception.
     * @maxSize 100
     */
    specialHourPeriod?: SpecialHourPeriod[];
}
/** Weekly recurring time periods when the business is regularly open or the service is available. */
export interface TimePeriod {
    /** Day of the week the period starts on. */
    openDay?: DayOfWeek;
    /**
     * Time the period starts in 24-hour [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) extended format. Valid values are `00:00` to `24:00`, where `24:00` represents
     * midnight at the end of the specified day.
     */
    openTime?: string;
    /** Day of the week the period ends on. */
    closeDay?: DayOfWeek;
    /**
     * Time the period ends in 24-hour [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) extended format. Valid values are `00:00` to `24:00`, where `24:00` represents
     * midnight at the end of the specified day.
     *
     * __Note:__ If `openDay` and `closeDay` specify the same day of the week `closeTime` must be later than `openTime`.
     */
    closeTime?: string;
}
/** Enumerates the days of the week. */
export declare enum DayOfWeek {
    MONDAY = "MONDAY",
    TUESDAY = "TUESDAY",
    WEDNESDAY = "WEDNESDAY",
    THURSDAY = "THURSDAY",
    FRIDAY = "FRIDAY",
    SATURDAY = "SATURDAY",
    SUNDAY = "SUNDAY"
}
/** Exception to the business's regular hours. The business can be open or closed during the exception. */
export interface SpecialHourPeriod {
    /** Start date and time of the exception in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format and [Coordinated Universal Time (UTC)](https://en.wikipedia.org/wiki/Coordinated_Universal_Time). */
    startDate?: string;
    /** End date and time of the exception in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format and [Coordinated Universal Time (UTC)](https://en.wikipedia.org/wiki/Coordinated_Universal_Time). */
    endDate?: string;
    /**
     * Whether the business is closed (or the service is not available) during the exception.
     *
     * Default: `true`.
     */
    isClosed?: boolean;
    /** Additional info about the exception. For example, "We close earlier on New Year's Eve." */
    comment?: string;
}
export interface Rate {
    /**
     * Mapping between a named price option, for example, adult or child prices, and the price, currency, and down payment amount.
     * When present in an update request, the `default_varied_price` is ignored to support backward compatibility.
     */
    labeledPriceOptions?: Record<string, Price>;
    /**
     * Textual price information used when **Price Per Session** is set to **Custom Price** in the app's service details page.
     * When present in an update request, the `default_varied_price` is ignored to support backward compatibility.
     */
    priceText?: string | null;
}
export interface Price {
    /**
     * Required payment amount.
     * @format DECIMAL_VALUE
     */
    amount?: string;
    /**
     * Currency in which the amount is quoted.
     * @format CURRENCY
     */
    currency?: string;
    /**
     * Amount of a down payment or deposit as part of the transaction.
     * @format DECIMAL_VALUE
     */
    downPayAmount?: string;
}
/**
 * <!-- Needs updating when recurrence has been tested
 * Schedule's availability calculation is executed by the schedule's available intervals and this additional information.
 * Schedule's available intervals are recurring intervals (defined in the schedule) minus sessions that has no more spots for bookings (including time between_slots), or schedule's sessions with open spots for bookings.-->
 */
export interface Availability {
    /** Date and time the schedule starts to be available for booking. */
    start?: Date | null;
    /** Date and time the schedule stops being available for booking. No value indicates no end time. */
    end?: Date | null;
    /** Other schedules that impact the availability calculation. Relevant only when there are availability constraints. */
    linkedSchedules?: LinkedSchedule[];
    /** Constraints for calculating the schedule's availability. */
    constraints?: AvailabilityConstraints;
}
/** Describes how to calculate the specific slots that are available for booking. */
export interface AvailabilityConstraints {
    /**
     * A list of duration options for slots, in minutes. Minimum value for a duration is 1.
     * The availability calculation generates slots with these durations, where there is no conflict with existing sessions or other availability constraints.
     * @min 1
     */
    slotDurations?: number[];
    /**
     * The number of minutes between the `end` of one slot, and the `start` of the next.
     * Minimum value is 0, maximum value is 120.
     * @max 720
     */
    timeBetweenSlots?: number;
    /**
     * Specify how to split the slots in intervals of minutes.
     * This value indicates the time between available slots' start time. e.g., from 5 minute slots (3:00, 3:05, 3:15) and 1 hour slots (3:00, 4:00, 5:00).
     * Optional. The default is the first duration in slot_durations field.
     * Deprecated. Use the `split_slots_interval.value_in_minutes`.
     * @deprecated
     */
    splitInterval?: number | null;
    /**
     * An object defining the time between available slots' start times.  For example, a slot with slots_split_interval=5 can start every 5 minutes. The default is the slot duration.
     * @readonly
     */
    slotsSplitInterval?: SplitInterval;
}
/** The time between available slots' start times. For example, For 5 minute slots, 3:00, 3:05, 3:15 etc. For 1 hour slots, 3:00, 4:00, 5:00 etc. */
export interface SplitInterval {
    /**
     * Whether the slot duration is used as the split interval value.
     * If `same_as_duration` is `true`, the `value_in_minutes` is the sum of the first duration in
     * `schedule.availabilityConstraints.SlotDurations` field, and `schedule.availabilityConstraints.TimeBetweenSlots` field.
     */
    sameAsDuration?: boolean | null;
    /** Number of minutes between available slots' start times when `same_as_duration` is `false`. */
    valueInMinutes?: number | null;
}
export interface Participant {
    /**
     * Participant ID. Currently represents the booking.id.
     * @format GUID
     */
    _id?: string;
    /**
     * Contact ID.
     * @format GUID
     */
    contactId?: string | null;
    /** Participant's name. */
    name?: string | null;
    /** Participant's phone number. */
    phone?: string | null;
    /** Participant's email address. */
    email?: string | null;
    /** Group or party size. The number of people attending. Defaults to 0. Maximum is 250. */
    partySize?: number;
    /**
     * Approval status for the participant.
     * <!-- Commented out untill updateParticipant is exposed Generally the same status as the booking, unless updated using the `updateParticipant()` API. Defaults to `"UNDEFINED"`.-->
     */
    approvalStatus?: ApprovalStatus;
    /**
     * Whether the participant was inherited from the schedule, as opposed to being booked directly to the session.
     * @readonly
     */
    inherited?: boolean;
}
export declare enum ApprovalStatus {
    /** Default. */
    UNDEFINED = "UNDEFINED",
    /** Pending business approval. */
    PENDING = "PENDING",
    /** Approved by the business. */
    APPROVED = "APPROVED",
    /** Declined by the business. */
    DECLINED = "DECLINED"
}
export interface ExternalCalendarOverrides {
    /** Synced title of the external calendar event. */
    title?: string | null;
    /** Synced description of the external calendar event. */
    description?: string | null;
}
export declare enum ScheduleStatus {
    /** Undefined schedule status. */
    UNDEFINED = "UNDEFINED",
    /** The schedule was created. */
    CREATED = "CREATED",
    /** The schedule was cancelled. */
    CANCELLED = "CANCELLED"
}
export interface Version {
    /** Schedule version number, updated each time the schedule is updated. */
    scheduleVersion?: number | null;
    /** Participants version number, updated each time the schedule participants are updated. */
    participantsVersion?: number | null;
}
export interface ConferenceProvider {
    /** Conferencing provider ID */
    providerId?: string;
}
export interface CalendarConference {
    /** Wix Calendar conference ID. */
    _id?: string;
    /** Conference meeting ID in the provider's conferencing system. */
    externalId?: string;
    /** Conference provider ID. */
    providerId?: string;
    /** URL used by the host to start the conference. */
    hostUrl?: string;
    /** URL used by a guest to join the conference. */
    guestUrl?: string;
    /** Password to join the conference. */
    password?: string | null;
    /** Conference description. */
    description?: string | null;
    /** Conference type. */
    conferenceType?: ConferenceType;
    /** ID of the account owner in the video conferencing service. */
    accountOwnerId?: string | null;
}
export declare enum ConferenceType {
    /** Undefined conference type. */
    UNDEFINED = "UNDEFINED",
    /** API-generated online meeting. */
    ONLINE_MEETING_PROVIDER = "ONLINE_MEETING_PROVIDER",
    /** User-defined meeting. */
    CUSTOM = "CUSTOM"
}
export declare enum ResourceStatus {
    /** Undefined resource status. */
    UNDEFINED = "UNDEFINED",
    /** The resource was created. */
    CREATED = "CREATED",
    /** The resource was deleted. */
    DELETED = "DELETED",
    /** The resource was updated. */
    UPDATED = "UPDATED"
}
export interface BusinessLocation {
    /**
     * The ID of the business location. Has to be non-empty
     * @format GUID
     */
    locationId?: string;
}
export declare enum Event {
    /** Undefined resource event. */
    UNDEFINED = "UNDEFINED",
    /** The resource was updated. */
    Updated = "Updated",
    /** The resource was deleted. */
    Deleted = "Deleted",
    /** The resource was created. */
    Created = "Created",
    /** The schedule was updated. */
    Schedule_Updated = "Schedule_Updated"
}
export interface Empty {
}
export interface ScheduleNotification extends ScheduleNotificationEventOneOf {
    scheduleCreated?: ScheduleCreated;
    scheduleUpdated?: ScheduleUpdated;
    scheduleCancelled?: ScheduleCancelled;
    sessionCreated?: SessionCreated;
    sessionUpdated?: SessionUpdated;
    sessionCancelled?: SessionCancelled;
    availabilityPolicyUpdated?: AvailabilityPolicyUpdated;
    /** @deprecated */
    intervalSplit?: IntervalSplit;
    recurringSessionSplit?: RecurringSessionSplit;
    /**
     * Inspect `schedule.scheduleOwnerUserId` on `scheduleUpdated` instead.
     * @deprecated
     */
    scheduleUnassignedFromUser?: ScheduleUnassignedFromUser;
    preserveFutureSessionsWithParticipants?: boolean | null;
    /**
     * Whether to notify participants about changed sessions. deprecated, use participant_notification
     * @deprecated
     */
    notifyParticipants?: boolean;
    /** site properties. Optional. Given in create schedule notification. */
    siteProperties?: SitePropertiesOnScheduleCreation;
    instanceId?: string;
}
/** @oneof */
export interface ScheduleNotificationEventOneOf {
    scheduleCreated?: ScheduleCreated;
    scheduleUpdated?: ScheduleUpdated;
    scheduleCancelled?: ScheduleCancelled;
    sessionCreated?: SessionCreated;
    sessionUpdated?: SessionUpdated;
    sessionCancelled?: SessionCancelled;
    availabilityPolicyUpdated?: AvailabilityPolicyUpdated;
    /** @deprecated */
    intervalSplit?: IntervalSplit;
    recurringSessionSplit?: RecurringSessionSplit;
    /**
     * Inspect `schedule.scheduleOwnerUserId` on `scheduleUpdated` instead.
     * @deprecated
     */
    scheduleUnassignedFromUser?: ScheduleUnassignedFromUser;
}
export interface ScheduleCreated {
    schedule?: Schedule;
}
export interface ScheduleUpdated {
    /** The old schedule before the update. */
    oldSchedule?: Schedule;
    /** The new schedule after the update. */
    newSchedule?: Schedule;
    /**
     * Recurring sessions updated event. If this field is given, the reason for the schedule updated event was
     * updating at least one of the given schedule's recurring sessions.
     * This event is triggered by create/update/delete recurring session apis.
     */
    recurringSessions?: RecurringSessionsUpdated;
    /** Whether to notify participants about the change and an optional custom message */
    participantNotification?: ParticipantNotification;
    /**
     * Whether this notification was created as a result of an anonymization request, such as GDPR.
     * An anonymized participant will have the following details:
     * name = "deleted"
     * phone = "deleted"
     * email = "deleted@deleted.com"
     */
    triggeredByAnonymizeRequest?: boolean | null;
}
export interface RecurringSessionsUpdated {
    /** Old schedule's recurring session list. */
    oldRecurringSessions?: Session[];
    /** New schedule's recurring session list. */
    newRecurringSessions?: Session[];
}
export interface Session {
    /**
     * Session ID.
     * @readonly
     */
    _id?: string | null;
    /**
     * ID of the schedule that the session belongs to.
     * @immutable
     */
    scheduleId?: string;
    /**
     * ID of the resource or service that the session's schedule belongs to.
     * @readonly
     */
    scheduleOwnerId?: string | null;
    /** Original start date and time of the session in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Coordinated_Universal_Time_(UTC)) format. */
    originalStart?: Date | null;
    /** An object specifying the start date and time of the session. If the session is a recurring session, `start` must contain a `localDateTime`. */
    start?: CalendarDateTime;
    /**
     * An object specifying the end date and time of the session. The `end` time must be after the `start` time and be same type as `start`.
     * If the session is a recurring session, `end` must contain a `localDateTime`.
     */
    end?: CalendarDateTime;
    /**
     * An object specifying a list of schedules and the way each schedule's availability is affected by the session. For example, the schedule of an instructor is affected by sessions of the class that they instruct.
     * The array is inherited from the schedule and can be overridden even if the session is a recurring session.
     */
    affectedSchedules?: LinkedSchedule[];
    /**
     * Session title.
     * The value is inherited from the schedule and can be overridden unless the session is a recurring session.
     * @maxLength 6000
     */
    title?: string | null;
    /**
     * __Deprecated.__
     * Tags for the session.
     * The value is inherited from the schedule and can be overridden unless the session is a recurring session.
     * @maxLength 200
     * @deprecated
     */
    tags?: string[] | null;
    /**
     * An object describing the location where the session takes place.
     * Defaults to the schedule location.
     * For single sessions, `session.location.businessLocation` can only be provided for locations that are defined in the schedule using `schedule.location` or `schedule.availability.locations`.
     */
    location?: Location;
    /**
     * Maximum number of participants that can be added to the session. Defaults to the schedule capacity.
     * The value is inherited from the schedule and can be overridden unless the session is a recurring session.
     * @max 1000
     */
    capacity?: number | null;
    /**
     * Deprecated. Please use the [Booking Services V2](https://dev.wix.com/api/rest/wix-bookings/services-v2) payment instead.
     * @deprecated
     */
    rate?: Rate;
    /**
     * Time reserved after the session end time, derived from the schedule availability constraints and the time between slots. Read-only.
     * If the session is a recurring session, this field must be empty.
     */
    timeReservedAfter?: number | null;
    /**
     * Additional information about the session.
     * Notes are not supported for recurring sessions.
     * @maxLength 10000
     */
    notes?: string;
    /**
     * The number of participants booked for the session. Read-only.
     * Calculated as the sum of the party sizes.
     * @readonly
     */
    totalNumberOfParticipants?: number;
    /**
     * *Partial list** list of participants booked for the session.
     * The list includes participants who have registered for this specific session, and participants who have registered for a schedule that includes this session.
     * If the session is a recurring session, this field must be empty.
     * To retrieve the full list of session participants please use the [Query Extended Bookings API](https://dev.wix.com/api/rest/wix-bookings/bookings-reader-v2/query-extended-bookings).
     */
    participants?: Participant[];
    /**
     * A list of properties for which values were inherited from the schedule.
     * This does not include participants that were inherited from the schedule.
     * @readonly
     */
    inheritedFields?: string[];
    /**
     * __Deprecated.__
     * @deprecated
     */
    externalCalendarOverrides?: ExternalCalendarOverrides;
    /**
     * Session status.
     * @readonly
     */
    status?: Status;
    /**
     * Recurring interval ID. Defined when a session will be a recurring session. read-only. Optional.
     * For example, when creating a class service  with recurring sessions, you add a recurrence rule to create recurring sessions.
     * This field is omitted for single sessions or instances of recurring sessions.
     * Specified when the session was originally generated from a schedule recurring interval.
     * Deprecated. Use `recurringSessionId`.
     * @readonly
     * @deprecated
     */
    recurringIntervalId?: string | null;
    /**
     * The ID of the recurring session if this session is an instance of a recurrence. Use this ID to update the recurrence and all of the instances.
     * @readonly
     */
    recurringSessionId?: string | null;
    /** Session type. */
    type?: SessionType;
    /**
     * A conference created for the session according to the details set in the schedule's conference provider information.
     * If the session is a recurring session, this field is inherited from the schedule.
     * **Partially deprecated.** Only `hostUrl` and `guestUrl` are to be supported.
     * @deprecated
     */
    calendarConference?: CalendarConference;
    /**
     * A string representing a recurrence rule (RRULE) for a recurring session, as defined in [iCalendar RFC 5545](https://icalendar.org/iCalendar-RFC-5545/3-3-10-recurrence-rule.html).
     * If the session is an instance of a recurrence pattern, the `instanceOfRecurrence` property will be contain the recurrence rule and this property will be empty.
     * The RRULE defines a rule for repeating a session.
     * Supported parameters are:
     *
     * |Keyword|Description|Supported values|
     * |--|--|---|
     * |`FREQ`|The frequency at which the session is recurs. Required.|`WEEKLY`|
     * |`INTERVAL`|How often, in terms of `FREQ`, the session recurs. Default is 1. Optional.|
     * |`UNTIL`|The UTC end date and time of the recurrence. Optional.|
     * |`BYDAY`|Day of the week when the event should recur. Required.|One of: `MO`, `TU`, `WE`, `TH`, `FR`, `SA`, `SU`|
     *
     *
     * For example, a session that repeats every second week on a Monday until January 7, 2022 at 8 AM:
     * `"FREQ=WEEKLY;INTERVAL=2;BYDAY=MO;UNTIL=20220107T080000Z"`
     *
     * <!--ORIGINAL COMMENTS:
     * `FREQ` — The frequency with which the session should be repeated (such as DAILY or WEEKLY).
     * Supported `WEEKLY` value is supported.
     * INTERVAL — Works together with FREQ to specify how often the session should be repeated. For example, FREQ=WEEKLY;INTERVAL=2 means once every two weeks. Optional. Default value is 1.
     * COUNT — The number of times this event should be repeated. Not yet supported.
     * UNTIL — The UTC date & time until which the session should be repeated. This parameter is optional. When it is not specified, the event repeats forever.
     * The format is a short ISO date, followed by 'T' and a short time with seconds and without milliseconds, terminated by the UTC designator 'Z'. For example, until Jan. 19th 2018 at 7:00 AM: 'UNTIL=20180119T070000Z'.
     * BYDAY - The days of the week when the event should be repeated. Currently, only a single day is supported. This parameter is mandatory.
     * Possible values are: MO, TU, WE, TH, FR, SA, SU
     * Note that DTSTART and DTEND lines are not allowed in this field; session start and end times are specified in the start and end fields.
     * **Example**: FREQ=WEEKLY;INTERVAL=2;BYDAY=MO;UNTIL=20200427T070000Z
     * ORIGINAL COMMENTS-->
     */
    recurrence?: string | null;
    /**
     * A string representing a recurrence rule (RRULE) if the session is an instance of a recurrence pattern.
     * Empty when the session is not an instance of a recurrence rule, or if the session defines a recurrence pattern, and `recurrence` is not empty.
     * @readonly
     */
    instanceOfRecurrence?: string | null;
    /**
     * The session version.
     * Composed by the schedule, session and participants versions.
     * @readonly
     */
    version?: SessionVersion;
}
export interface CalendarDateTime {
    /**
     * UTC date-time in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Coordinated_Universal_Time_(UTC)) format. If a time zone offset is specified, the time is converted to UTC. For example, if you specify  `new Date('2021-01-06T16:00:00.000-07:00')`, the stored value will be `"2021-01-06T23:00:00.000Z"`.
     * Required if `localDateTime` is not specified.
     * If `localDateTime` is specified, `timestamp` is calculated as `localDateTime`, using the business's time zone.
     */
    timestamp?: Date | null;
    /** An object containing the local date and time for the business's time zone. */
    localDateTime?: LocalDateTime;
    /**
     * The time zone. Optional. Derived from the schedule's time zone.
     * In case this field is associated with recurring session, this field is empty.
     * @readonly
     */
    timeZone?: string | null;
}
export interface LocalDateTime {
    /** Year. 4-digit format. */
    year?: number | null;
    /**
     * Month number, from 1-12.
     * @min 1
     * @max 12
     */
    monthOfYear?: number | null;
    /** Day of the month, from 1-31. */
    dayOfMonth?: number | null;
    /**
     * Hour of the day in 24-hour format, from 0-23.
     * @max 23
     */
    hourOfDay?: number | null;
    /**
     * Minute, from 0-59.
     * @max 59
     */
    minutesOfHour?: number | null;
}
export interface ExternalCalendarInfo {
    /** The external calendar type (e.g. Google Calendar, iCal, etc). */
    calendarType?: CalendarType;
}
export declare enum CalendarType {
    /** There is no information about the external calendar type. */
    UNDEFINED = "UNDEFINED",
    /** [Google Calendar](https://developers.google.com/calendar/api/guides/overview). */
    GOOGLE = "GOOGLE",
    /** Apple iCalendar. */
    I_CAL = "I_CAL",
    /** __Deprecated__. Use `MICROSOFT` instead. */
    OUTLOOK = "OUTLOOK",
    /** __Deprecated__. Use `MICROSOFT` instead. */
    OFFICE_365 = "OFFICE_365",
    /** Microsoft Calendar. For example, Office 365 calendar or Outlook calendar. */
    MICROSOFT = "MICROSOFT",
    /** A different type of external calendar, not listed here. */
    OTHER = "OTHER"
}
export declare enum Status {
    /** Undefined status. */
    UNDEFINED = "UNDEFINED",
    /** Session is confirmed. Default status. */
    CONFIRMED = "CONFIRMED",
    /**
     * Session is cancelled.
     * A cancelled session can be the cancellation of a recurring session that should no longer be displayed or a deleted single session.
     * The ListSessions returns cancelled sessions only if 'includeDelete' flag is set to true.
     */
    CANCELLED = "CANCELLED"
}
export declare enum SessionType {
    UNDEFINED = "UNDEFINED",
    /**
     * Creates an event on the calendar for the owner of the schedule that the session belongs to.
     * Default type.
     */
    EVENT = "EVENT",
    /** Represents a resource's available working hours. */
    WORKING_HOURS = "WORKING_HOURS",
    /** Deprecated. Please use WORKING_HOURS. */
    TIME_AVAILABILITY = "TIME_AVAILABILITY",
    /** Deprecated. Represents a resource's available hours. Please use WORKING_HOURS. */
    AVAILABILITY = "AVAILABILITY"
}
export interface SessionVersion {
    /** Incremental version number, which is updated on each change to the session or on changes affecting the session. */
    number?: string | null;
}
export interface ParticipantNotification {
    /**
     * Whether to send the message about the changes to the customer.
     *
     * Default: `false`
     */
    notifyParticipants?: boolean;
    /** Custom message to send to the participants about the changes to the booking. */
    message?: string | null;
}
export interface ScheduleCancelled {
    schedule?: Schedule;
    /** Whether to notify participants about the change and an optional custom message */
    participantNotification?: ParticipantNotification;
    oldSchedule?: Schedule;
}
export interface SessionCreated {
    session?: Session;
}
export interface SessionUpdated {
    oldSession?: Session;
    newSession?: Session;
    /** Whether to notify participants about the change and an optional custom message */
    participantNotification?: ParticipantNotification;
    /**
     * Whether this notification was created as a result of an anonymization request, such as GDPR.
     * An anonymized participant will have the following details:
     * name = "deleted"
     * phone = "deleted"
     * email = "deleted@deleted.com"
     */
    triggeredByAnonymizeRequest?: boolean | null;
}
export interface SessionCancelled {
    session?: Session;
    /** Whether to notify participants about the change and an optional custom message */
    participantNotification?: ParticipantNotification;
}
export interface AvailabilityPolicyUpdated {
    availabilityPolicy?: AvailabilityPolicy;
}
/** Availability policy applied to all site schedules. */
export interface AvailabilityPolicy {
    /** Specify how to split the schedule slots in intervals of minutes. */
    splitInterval?: SplitInterval;
}
export interface IntervalSplit {
    scheduleId?: string;
    intervals?: RecurringInterval[];
    newScheduleVersion?: number | null;
    oldScheduleVersion?: number | null;
}
export interface RecurringSessionSplit {
    scheduleId?: string;
    recurringSessions?: Session[];
    newScheduleVersion?: number | null;
    oldScheduleVersion?: number | null;
}
/** Schedule unassigned from user. */
export interface ScheduleUnassignedFromUser {
    /**
     * The Wix user id.
     * @format GUID
     */
    userId?: string | null;
    /** The schedule that was unassigned from the user. */
    schedule?: Schedule;
}
export interface MultipleSessionsCreated {
    schedulesWithSessions?: ScheduleWithSessions[];
}
export interface ScheduleWithSessions {
    schedule?: Schedule;
    siteProperties?: SitePropertiesOnScheduleCreation;
    sessions?: Session[];
}
export interface SitePropertiesOnScheduleCreation {
    /** The global time zone value. */
    timeZone?: string | null;
}
export interface MigrationEvent {
    migrationData?: MigrationData;
}
export interface MigrationData {
    businessId?: string | null;
    staffs?: StaffData[];
}
export interface StaffData {
    resourceId?: string;
    syncRequestEmail?: string;
    refreshToken?: string;
}
export interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /**
     * Unique event ID.
     * Allows clients to ignore duplicate webhooks.
     */
    _id?: string;
    /**
     * Assumes actions are also always typed to an entity_type
     * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
     */
    entityFqdn?: string;
    /**
     * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
     * This is although the created/updated/deleted notion is duplication of the oneof types
     * Example: created/updated/deleted/started/completed/email_opened
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number defining the order of updates to the underlying entity.
     * For example, given that some entity was updated at 16:00 and than again at 16:01,
     * it is guaranteed that the sequence number of the second update is strictly higher than the first.
     * As the consumer, you can use this value to ensure that you handle messages in the correct order.
     * To do so, you will need to persist this number on your end, and compare the sequence number from the
     * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
export interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
export interface EntityCreatedEvent {
    entity?: string;
}
export interface RestoreInfo {
    deletedDate?: Date | null;
}
export interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntity?: string;
}
export interface EntityDeletedEvent {
    /** Entity that was deleted */
    deletedEntity?: string | null;
}
export interface ActionEvent {
    body?: string;
}
/** Encapsulates all details written to the Greyhound topic when a site's properties are updated. */
export interface SitePropertiesNotification {
    /** The site ID for which this update notification applies. */
    metasiteId?: string;
    /** The actual update event. */
    event?: SitePropertiesEvent;
    /**
     * A convenience set of mappings from the MetaSite ID to its constituent services.
     * @maxSize 500
     */
    translations?: Translation[];
    /** Context of the notification */
    changeContext?: ChangeContext;
}
/** The actual update event for a particular notification. */
export interface SitePropertiesEvent {
    /** Version of the site's properties represented by this update. */
    version?: number;
    /** Set of properties that were updated - corresponds to the fields in "properties". */
    fields?: string[];
    /** Updated properties. */
    properties?: Properties;
}
export interface Properties {
    /** Site categories. */
    categories?: Categories;
    /** Site locale. */
    locale?: Locale;
    /**
     * Site language.
     *
     * Two-letter language code in [ISO 639-1 alpha-2](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format.
     */
    language?: string | null;
    /**
     * Site currency format used to bill customers.
     *
     * Three-letter currency code in [ISO-4217 alphabetic](https://en.wikipedia.org/wiki/ISO_4217#Active_codes) format.
     */
    paymentCurrency?: string | null;
    /** Timezone in `America/New_York` format. */
    timeZone?: string | null;
    /** Email address. */
    email?: string | null;
    /** Phone number. */
    phone?: string | null;
    /** Fax number. */
    fax?: string | null;
    /** Address. */
    address?: V4Address;
    /** Site display name. */
    siteDisplayName?: string | null;
    /** Business name. */
    businessName?: string | null;
    /** Path to the site's logo in Wix Media (without Wix Media base URL). */
    logo?: string | null;
    /** Site description. */
    description?: string | null;
    /**
     * Business schedule. Regular and exceptional time periods when the business is open or the service is available.
     *
     * __Note:__ Not supported by Wix Bookings.
     */
    businessSchedule?: BusinessSchedule;
    /** Supported languages of a site and the primary language. */
    multilingual?: Multilingual;
    /** Cookie policy the Wix user defined for their site (before the site visitor interacts with/limits it). */
    consentPolicy?: ConsentPolicy;
    /**
     * Supported values: `FITNESS SERVICE`, `RESTAURANT`, `BLOG`, `STORE`, `EVENT`, `UNKNOWN`.
     *
     * Site business type.
     */
    businessConfig?: string | null;
    /** External site URL that uses Wix as its headless business solution. */
    externalSiteUrl?: string | null;
    /** Track clicks analytics. */
    trackClicksAnalytics?: boolean;
}
export interface Categories {
    /** Primary site category. */
    primary?: string;
    /**
     * Secondary site category.
     * @maxSize 50
     */
    secondary?: string[];
    /** Business Term Id */
    businessTermId?: string | null;
}
export interface Locale {
    /** Two-letter language code in [ISO 639-1 alpha-2](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format. */
    languageCode?: string;
    /** Two-letter country code in [ISO-3166 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2#Officially_assigned_code_elements) format. */
    country?: string;
}
export interface V4Address {
    /** Street name. */
    street?: string;
    /** City name. */
    city?: string;
    /** Two-letter country code in an [ISO-3166 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format. */
    country?: string;
    /** State. */
    state?: string;
    /**
     * Zip or postal code.
     * @maxLength 20
     */
    zip?: string;
    /** Extra information to be displayed in the address. */
    hint?: AddressHint;
    /** Whether this address represents a physical location. */
    isPhysical?: boolean;
    /** Google-formatted version of this address. */
    googleFormattedAddress?: string;
    /** Street number. */
    streetNumber?: string;
    /** Apartment number. */
    apartmentNumber?: string;
    /** Geographic coordinates of location. */
    coordinates?: GeoCoordinates;
}
/**
 * Extra information on displayed addresses.
 * This is used for display purposes. Used to add additional data about the address, such as "In the passage".
 * Free text. In addition, the user can state where to display the additional description - before, after, or instead of the address string.
 */
export interface AddressHint {
    /** Extra text displayed next to, or instead of, the actual address. */
    text?: string;
    /** Where the extra text should be displayed. */
    placement?: PlacementType;
}
/** Where the extra text should be displayed: before, after or instead of the actual address. */
export declare enum PlacementType {
    BEFORE = "BEFORE",
    AFTER = "AFTER",
    REPLACE = "REPLACE"
}
/** Geocoordinates for a particular address. */
export interface GeoCoordinates {
    /** Latitude of the location. Must be between -90 and 90. */
    latitude?: number;
    /** Longitude of the location. Must be between -180 and 180. */
    longitude?: number;
}
export interface Multilingual {
    /**
     * Supported languages list.
     * @maxSize 200
     */
    supportedLanguages?: SupportedLanguage[];
    /** Whether to redirect to user language. */
    autoRedirect?: boolean;
}
export interface SupportedLanguage {
    /** Two-letter language code in [ISO 639-1 alpha-2](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format. */
    languageCode?: string;
    /** Locale. */
    locale?: Locale;
    /** Whether the supported language is the primary language for the site. */
    isPrimary?: boolean;
    /** Language icon. */
    countryCode?: string;
    /** How the language will be resolved. For internal use. */
    resolutionMethod?: ResolutionMethod;
}
export declare enum ResolutionMethod {
    QUERY_PARAM = "QUERY_PARAM",
    SUBDOMAIN = "SUBDOMAIN",
    SUBDIRECTORY = "SUBDIRECTORY"
}
export interface ConsentPolicy {
    /** Whether the site uses cookies that are essential to site operation. Always `true`. */
    essential?: boolean | null;
    /** Whether the site uses cookies that affect site performance and other functional measurements. */
    functional?: boolean | null;
    /** Whether the site uses cookies that collect analytics about how the site is used (in order to improve it). */
    analytics?: boolean | null;
    /** Whether the site uses cookies that collect information allowing better customization of the experience for a current visitor. */
    advertising?: boolean | null;
    /** CCPA compliance flag. */
    dataToThirdParty?: boolean | null;
}
/** A single mapping from the MetaSite ID to a particular service. */
export interface Translation {
    /** The service type. */
    serviceType?: string;
    /** The application definition ID; this only applies to services of type ThirdPartyApps. */
    appDefId?: string;
    /** The instance ID of the service. */
    instanceId?: string;
}
export interface ChangeContext extends ChangeContextPayloadOneOf {
    /** Properties were updated. */
    propertiesChange?: PropertiesChange;
    /** Default properties were created on site creation. */
    siteCreated?: SiteCreated;
    /** Properties were cloned on site cloning. */
    siteCloned?: SiteCloned;
}
/** @oneof */
export interface ChangeContextPayloadOneOf {
    /** Properties were updated. */
    propertiesChange?: PropertiesChange;
    /** Default properties were created on site creation. */
    siteCreated?: SiteCreated;
    /** Properties were cloned on site cloning. */
    siteCloned?: SiteCloned;
}
export interface PropertiesChange {
}
export interface SiteCreated {
    /** Origin template site id. */
    originTemplateId?: string | null;
}
export interface SiteCloned {
    /** Origin site id. */
    originMetaSiteId?: string;
}
export interface MessageEnvelope {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
export interface IdentificationData extends IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityType;
}
/** @oneof */
export interface IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
}
export declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
interface CustomServiceOptionNonNullableFields {
    name: string;
    choices: string[];
}
interface ServiceOptionNonNullableFields {
    customData?: CustomServiceOptionNonNullableFields;
    _id: string;
    type: ServiceOptionType;
}
interface ServiceOptionsNonNullableFields {
    values: ServiceOptionNonNullableFields[];
}
interface DurationNonNullableFields {
    minutes: number;
}
interface ServiceChoiceNonNullableFields {
    custom: string;
    staffMemberId: string;
    duration?: DurationNonNullableFields;
    optionId: string;
}
interface MoneyNonNullableFields {
    value: string;
    currency: string;
}
interface ServiceVariantNonNullableFields {
    choices: ServiceChoiceNonNullableFields[];
    price?: MoneyNonNullableFields;
}
interface ServiceVariantsNonNullableFields {
    values: ServiceVariantNonNullableFields[];
}
export interface ServiceOptionsAndVariantsNonNullableFields {
    options?: ServiceOptionsNonNullableFields;
    variants?: ServiceVariantsNonNullableFields;
    minPrice?: MoneyNonNullableFields;
    maxPrice?: MoneyNonNullableFields;
}
export interface CreateServiceOptionsAndVariantsResponseNonNullableFields {
    serviceOptionsAndVariants?: ServiceOptionsAndVariantsNonNullableFields;
}
export interface CloneServiceOptionsAndVariantsResponseNonNullableFields {
    serviceOptionsAndVariants?: ServiceOptionsAndVariantsNonNullableFields;
}
export interface GetServiceOptionsAndVariantsResponseNonNullableFields {
    serviceOptionsAndVariants?: ServiceOptionsAndVariantsNonNullableFields;
}
export interface GetServiceOptionsAndVariantsByServiceIdResponseNonNullableFields {
    serviceVariants?: ServiceOptionsAndVariantsNonNullableFields;
}
export interface UpdateServiceOptionsAndVariantsResponseNonNullableFields {
    serviceOptionsAndVariants?: ServiceOptionsAndVariantsNonNullableFields;
}
export interface QueryServiceOptionsAndVariantsResponseNonNullableFields {
    serviceOptionsAndVariantsList: ServiceOptionsAndVariantsNonNullableFields[];
}
export interface BaseEventMetadata {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
}
export interface EventMetadata extends BaseEventMetadata {
    /**
     * Unique event ID.
     * Allows clients to ignore duplicate webhooks.
     */
    _id?: string;
    /**
     * Assumes actions are also always typed to an entity_type
     * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
     */
    entityFqdn?: string;
    /**
     * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
     * This is although the created/updated/deleted notion is duplication of the oneof types
     * Example: created/updated/deleted/started/completed/email_opened
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number defining the order of updates to the underlying entity.
     * For example, given that some entity was updated at 16:00 and than again at 16:01,
     * it is guaranteed that the sequence number of the second update is strictly higher than the first.
     * As the consumer, you can use this value to ensure that you handle messages in the correct order.
     * To do so, you will need to persist this number on your end, and compare the sequence number from the
     * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
     */
    entityEventSequence?: string | null;
}
export interface ServiceOptionsAndVariantsCreatedEnvelope {
    entity: ServiceOptionsAndVariants;
    metadata: EventMetadata;
}
/** @permissionScope Read Bookings - Public Data
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-PUBLIC
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Read Bookings - Including Participants
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-SENSITIVE
 * @permissionScope Read Bookings - all read permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.READ-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @permissionId BOOKINGS.SERVICE_OPTIONS_AND_VARIANTS_READ
 * @webhook
 * @eventType wix.bookings.catalog.v1.service_options_and_variants_created
 * @slug created
 */
export declare function onServiceOptionsAndVariantsCreated(handler: (event: ServiceOptionsAndVariantsCreatedEnvelope) => void | Promise<void>): void;
export interface ServiceOptionsAndVariantsDeletedEnvelope {
    entity: ServiceOptionsAndVariants;
    metadata: EventMetadata;
}
/** @permissionScope Read Bookings - Public Data
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-PUBLIC
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Read Bookings - Including Participants
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-SENSITIVE
 * @permissionScope Read Bookings - all read permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.READ-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @permissionId BOOKINGS.SERVICE_OPTIONS_AND_VARIANTS_READ
 * @webhook
 * @eventType wix.bookings.catalog.v1.service_options_and_variants_deleted
 * @slug deleted
 */
export declare function onServiceOptionsAndVariantsDeleted(handler: (event: ServiceOptionsAndVariantsDeletedEnvelope) => void | Promise<void>): void;
export interface ServiceOptionsAndVariantsUpdatedEnvelope {
    entity: ServiceOptionsAndVariants;
    metadata: EventMetadata;
}
/** @permissionScope Read Bookings - Public Data
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-PUBLIC
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Read Bookings - Including Participants
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-SENSITIVE
 * @permissionScope Read Bookings - all read permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.READ-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @permissionId BOOKINGS.SERVICE_OPTIONS_AND_VARIANTS_READ
 * @webhook
 * @eventType wix.bookings.catalog.v1.service_options_and_variants_updated
 * @slug updated
 */
export declare function onServiceOptionsAndVariantsUpdated(handler: (event: ServiceOptionsAndVariantsUpdatedEnvelope) => void | Promise<void>): void;
/**
 * Creates a `serviceOptionsAndVariants` object and for a service.
 *
 *
 * ## Calculate variants
 *
 * Before creating a `serviceOptionsAndVariants` object, you need to
 * anticipate and manually define all its variants, since Wix Bookings doesn't
 * automatically calculate them. For the actual
 * Create Service Options And Variants* call, specify both the `options` and
 * `variants` arrays.
 *
 * ## Limitations
 *
 * Wix Bookings allows you to connect only a single `serviceOptionsAndVariants`
 * object to a service. *Create Service Options And Variants* fails, if the
 * service already has a connected `serviceOptionsAndVariants` object.
 *
 * Currently, you can include only a single option per
 * `serviceOptionsAndVariants` object. Taken together, this means that services
 * are limited to a single option.
 *
 * ## Option ID
 *
 * When creating a`serviceOptionsAndVariants` object, you must specify an ID in
 * [UUID format](https://en.wikipedia.org/wiki/Universally_unique_identifier)
 * for its only option. You must reference this option ID for each variant as
 * `variants.values.choices.optionId`.
 *
 * ## Staff member option
 *
 * To creating an option based on the *staff member*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/staff-members/introduction) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/staff-members/introduction))
 * providing the service, you need to specify `STAFF_MEMBER` as `options.values.type`.
 * Also, specify all staff member IDs as `variants.values.choices.staffMemberId`.
 * You could follow this *sample flow*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/service-options-and-variants/sample-flows#create-staff-member-based-service-variants) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/service-options-and-variants/sample-flows#create-staff-member-based-service-variants)).
 *
 * ## Custom option
 *
 * To create an option based on a custom parameter, specify `CUSTOM` as
 * `options.values.type`. Provide descriptive names for all custom choices as
 * `variants.values.choices.custom`. These names are displayed to customers
 * during the book flow. You could follow this *sample flow*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/service-options-and-variants/sample-flows#create-service-variants-based-on-the-booked-equipment) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/service-options-and-variants/sample-flows#create-service-variants-based-on-the-booked-equipment)).
 *
 * ## Duration option
 *
 * To create an option based on appointment duration, specify `DURATION` as
 * `options.values.type` and set a descriptive name in `options.values.durationData.name`.
 * Also, indicate the appointment length in `minutes` and provide a descriptive
 * `name` for each duration choice in `variants.values.choices.duration`.
 * @param serviceOptionsAndVariants - Service options and variants to create.
 * @public
 * @requiredField serviceOptionsAndVariants
 * @requiredField serviceOptionsAndVariants.options
 * @requiredField serviceOptionsAndVariants.serviceId
 * @requiredField serviceOptionsAndVariants.variants
 * @permissionId BOOKINGS.SERVICE_OPTIONS_AND_VARIANTS_CREATE
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @returns Information about the created service options and variants.
 * @fqn wix.bookings.catalog.v1.ServiceOptionsAndVariantsService.CreateServiceOptionsAndVariants
 */
export declare function createServiceOptionsAndVariants(serviceOptionsAndVariants: ServiceOptionsAndVariants): Promise<ServiceOptionsAndVariants & ServiceOptionsAndVariantsNonNullableFields>;
/**
 * Clones a `serviceOptionsAndVariants` object and connects it to a *service*
 * ([SDK](https://dev.wix.com/docs/rest/business-solutions/bookings/services/services-v2/introduction) | [REST](https://dev.wix.com/docs/sdk/backend-modules/bookings/services/introduction)).
 *
 *
 * The call fails if the service already has a connected
 * `serviceOptionsAndVariants` object.
 *
 * The cloned `serviceOptionsAndVariants` object gets a new, unique option ID.
 * The option ID of the existing `serviceOptionsAndVariants` object isn't reused.
 *
 * For example, you may call this method after *cloning a service*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/services/clone-service) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/services-v2/clone-service)).
 * @param cloneFromId - ID of the `serviceOptionsAndVariants` object to clone.
 * @param targetServiceId - ID of the service to which the cloned `serviceOptionsAndVariants` are
 * connected.
 * @public
 * @requiredField cloneFromId
 * @requiredField targetServiceId
 * @permissionId BOOKINGS.SERVICE_OPTIONS_AND_VARIANTS_CREATE
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @fqn wix.bookings.catalog.v1.ServiceOptionsAndVariantsService.CloneServiceOptionsAndVariants
 */
export declare function cloneServiceOptionsAndVariants(cloneFromId: string, targetServiceId: string): Promise<CloneServiceOptionsAndVariantsResponse & CloneServiceOptionsAndVariantsResponseNonNullableFields>;
/**
 * Retrieves a `serviceOptionsAndVariants` object by its ID.
 * @param serviceOptionsAndVariantsId - ID of the `serviceOptionsAndVariants` object to retrieve.
 * @public
 * @requiredField serviceOptionsAndVariantsId
 * @permissionId BOOKINGS.SERVICE_OPTIONS_AND_VARIANTS_READ
 * @permissionScope Read Bookings - Public Data
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-PUBLIC
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Read Bookings - Including Participants
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-SENSITIVE
 * @permissionScope Read Bookings - all read permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.READ-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @applicableIdentity VISITOR
 * @returns Retrieved `serviceOptionsAndVariants` object.
 * @fqn wix.bookings.catalog.v1.ServiceOptionsAndVariantsService.GetServiceOptionsAndVariants
 */
export declare function getServiceOptionsAndVariants(serviceOptionsAndVariantsId: string): Promise<ServiceOptionsAndVariants & ServiceOptionsAndVariantsNonNullableFields>;
/**
 * Retrieves a `serviceOptionsAndVariants` object by *service ID*
 * ([SDK](https://dev.wix.com/docs/rest/business-solutions/bookings/services/services-v2/introduction) | [REST](https://dev.wix.com/docs/sdk/backend-modules/bookings/services/introduction)).
 * @param serviceId - ID of the service to retrieve options and variants for.
 * @public
 * @requiredField serviceId
 * @permissionId BOOKINGS.SERVICE_OPTIONS_AND_VARIANTS_READ
 * @permissionScope Read Bookings - Public Data
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-PUBLIC
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Read Bookings - Including Participants
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-SENSITIVE
 * @permissionScope Read Bookings - all read permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.READ-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @applicableIdentity VISITOR
 * @fqn wix.bookings.catalog.v1.ServiceOptionsAndVariantsService.GetServiceOptionsAndVariantsByServiceId
 */
export declare function getServiceOptionsAndVariantsByServiceId(serviceId: string): Promise<GetServiceOptionsAndVariantsByServiceIdResponse & GetServiceOptionsAndVariantsByServiceIdResponseNonNullableFields>;
/**
 * Updates a `serviceOptionsAndVariants` object.
 *
 *
 * Currently, only a single option is supported per `serviceOptionsAndVariants` object.
 *
 * If you want to update `variants`, you must pass the entire list of supported
 * variants, not only newly added variants.
 *
 * If you want to update `options`, you must pass the entire list of supported
 * options, not only newly added options.
 * @param _id - ID of the `serviceOptionsAndVariants` object.
 * @public
 * @requiredField _id
 * @requiredField serviceOptionsAndVariants
 * @requiredField serviceOptionsAndVariants.revision
 * @param serviceOptionsAndVariants - Service options and variants to update.
 * @param options - Options for updating the service options and variants.
 * @permissionId BOOKINGS.SERVICE_OPTIONS_AND_VARIANTS_UPDATE
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @returns Updated `serviceOptionsAndVariants` object.
 * @fqn wix.bookings.catalog.v1.ServiceOptionsAndVariantsService.UpdateServiceOptionsAndVariants
 */
export declare function updateServiceOptionsAndVariants(_id: string | null, serviceOptionsAndVariants: UpdateServiceOptionsAndVariants): Promise<ServiceOptionsAndVariants & ServiceOptionsAndVariantsNonNullableFields>;
export interface UpdateServiceOptionsAndVariants {
    /**
     * ID of the `serviceOptionsAndVariants` object.
     * @format GUID
     * @readonly
     */
    _id?: string | null;
    /**
     * ID of the service related to these options and variants.
     * @format GUID
     * @immutable
     */
    serviceId?: string | null;
    /** Service options. Note that currently only a single option is supported per service. */
    options?: ServiceOptions;
    /** Information about the service's variants. */
    variants?: ServiceVariants;
    /**
     * Price of the cheapest service variant.
     * @readonly
     */
    minPrice?: Money;
    /**
     * Price of the most expensive service variant.
     * @readonly
     */
    maxPrice?: Money;
    /**
     * Revision number, which increments by 1 each time the `serviceOptionsAndVariants` object is updated.
     * To prevent conflicting changes,
     * the current revision must be passed when updating and deleting the `serviceOptionsAndVariants` object.
     *
     * Ignored when creating a `serviceOptionsAndVariants` object.
     * @immutable
     */
    revision?: string | null;
    /** Extensions enabling users to save custom data related to service options and variants. */
    extendedFields?: ExtendedFields;
}
/**
 * Deletes a `serviceOptionsAndVariants` object.
 *
 *
 * Because each service can be connected to only a single `serviceOptionsAndVariants`
 * object, the service doesn't support *varied pricing*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/services/about-service-payments) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/services-v2/about-service-payments#service-rates))
 * after deleting a `serviceOptionsAndVariants` object. Instead, Wix Bookings
 * uses its standard price calculation.
 * @param serviceOptionsAndVariantsId - ID of the `serviceOptionsAndVariants` object to delete.
 * @public
 * @requiredField serviceOptionsAndVariantsId
 * @param options - Options for deleting the service options and variants.
 * @permissionId BOOKINGS.SERVICE_OPTIONS_AND_VARIANTS_DELETE
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @fqn wix.bookings.catalog.v1.ServiceOptionsAndVariantsService.DeleteServiceOptionsAndVariants
 */
export declare function deleteServiceOptionsAndVariants(serviceOptionsAndVariantsId: string, options?: DeleteServiceOptionsAndVariantsOptions): Promise<void>;
export interface DeleteServiceOptionsAndVariantsOptions {
    /** Revision of the `serviceOptionsAndVariants` object to delete. */
    revision?: string;
}
/**
 * Creates a query to retrieve a list of `serviceOptionsAndVariants` objects.
 *
 * The `queryServiceOptionsAndVariants()` function builds a query to retrieve a list of `serviceOptionsAndVariants` objects and returns a `ServiceOptionsAndVariantsQueryBuilder` object.
 *
 * The returned object contains the query definition, which is typically used to run the query using the [find()](https://dev.wix.com/docs/sdk/backend-modules/bookings/service-options-and-variants/service-options-and-variants-list-query-builder/find) function.
 *
 * You can refine the query by chaining `ServiceOptionsAndVariantsQueryBuilder` functions onto the query. `ServiceOptionsAndVariantsQueryBuilder` functions enable you to sort, filter, and control the results that `queryServiceOptionsAndVariants()` returns.
 *
 * `queryServiceOptionsAndVariants()` runs with the following `ServiceOptionsAndVariantsQueryBuilder` default that you can override:
 *
 * + `limit` is `50`.
 * + Sorted by `id` in ascending order.
 *
 * The functions that are chained to `queryServiceOptionsAndVariants()` are applied in the order they are called. For example, if you apply `ascending("options.values.type")` and then `ascending("variants.values.price")`, the results are sorted first by the `"type"`, and then, if there are multiple results with the same `"type"`, the items are sorted by `"price"`.
 *
 * The following `ServiceOptionsAndVariantsQueryBuilder` functions are supported for the `queryServiceOptionsAndVariants()` function. For a full description of the `serviceOptionsAndVariants` object, see the object returned for the [items](https://dev.wix.com/docs/sdk/backend-modules/bookings/service-options-and-variants/service-options-and-variants-list-query-result/items) property in `ServiceOptionsAndVariantsQueryResult`.
 * @public
 * @permissionScope Read Bookings - Public Data
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-PUBLIC
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Read Bookings - Including Participants
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-SENSITIVE
 * @permissionScope Read Bookings - all read permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.READ-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @permissionId BOOKINGS.SERVICE_OPTIONS_AND_VARIANTS_READ
 * @applicableIdentity APP
 * @applicableIdentity VISITOR
 * @fqn wix.bookings.catalog.v1.ServiceOptionsAndVariantsService.QueryServiceOptionsAndVariants
 */
export declare function queryServiceOptionsAndVariants(): ServiceOptionsAndVariantsListQueryBuilder;
interface QueryCursorResult {
    cursors: Cursors;
    hasNext: () => boolean;
    hasPrev: () => boolean;
    length: number;
    pageSize: number;
}
export interface ServiceOptionsAndVariantsListQueryResult extends QueryCursorResult {
    items: ServiceOptionsAndVariants[];
    query: ServiceOptionsAndVariantsListQueryBuilder;
    next: () => Promise<ServiceOptionsAndVariantsListQueryResult>;
    prev: () => Promise<ServiceOptionsAndVariantsListQueryResult>;
}
export interface ServiceOptionsAndVariantsListQueryBuilder {
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    eq: (propertyName: '_id' | 'serviceId', value: any) => ServiceOptionsAndVariantsListQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    ne: (propertyName: '_id' | 'serviceId', value: any) => ServiceOptionsAndVariantsListQueryBuilder;
    /** @param propertyName - Property whose value is compared with `values`.
     * @param values - List of values to compare against.
     */
    hasSome: (propertyName: 'options.values.id' | 'options.values.type' | 'variants.values.choices.custom' | 'variants.values.choices.optionId' | 'variants.values.price.value' | 'variants.values.price.currency', value: any[]) => ServiceOptionsAndVariantsListQueryBuilder;
    /** Refines a query to match items where the specified property is in a short list of specified values. */
    in: (propertyName: '_id' | 'serviceId', value: any) => ServiceOptionsAndVariantsListQueryBuilder;
    /** Refines a query to match items where the specified property is in a list of specified values, such as from another table. */
    exists: (propertyName: 'options.values' | 'variants.values', value: boolean) => ServiceOptionsAndVariantsListQueryBuilder;
    /**
     * Adds a sort to a query, sorting by the specified properties in ascending order.
     *
     * The `ascending()` function refines a `CUSTOM_QUERY_BUILDER_NAME` to sort by the value of `propertyName` in ascending order. You can specify multiple properties for sorting in ascending order by passing each property name as an additional argument. `ascending()` sorts the results in the order the properties are passed. You can sort the following types:
     *
     * - Number: Sorts numerically.
     * - Date: Sorts by date and time.
     * - String: Sorts lexicographically, so `'abc'` comes after `'XYZ'`. If a property contains a number stored as a string (for example, `'0'`), that value is sorted alphabetically and not numerically. If a property doesn't have a value, that value is ranked lowest.
     * @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments. */
    ascending: (...propertyNames: Array<'_id' | 'serviceId'>) => ServiceOptionsAndVariantsListQueryBuilder;
    /**
     * Adds a sort to a query, sorting by the specified properties in descending order.
     *
     * The `descending()` function refines a `CUSTOM_QUERY_BUILDER_NAME` to sort by the value of `propertyName` in descending order.
     *
     * You can specify multiple properties for sorting in descending order by passing each property name as an additional argument. `descending()` sorts the results in the order the properties are passed. You can sort the following types:
     *
     * - Number: Sorts numerically.
     * - Date: Sorts by date and time.
     * - String: Sorts lexicographically, so `'abc'` comes after `'XYZ'`. If a property contains a number stored as a string (for example, `'0'`), that value is sorted alphabetically and not numerically. If a property doesn't have a value, that value is ranked lowest.
     * @param propertyNames - Properties used in the sort. To sort by multiple properties, pass properties as additional arguments. */
    descending: (...propertyNames: Array<'_id' | 'serviceId'>) => ServiceOptionsAndVariantsListQueryBuilder;
    /** @param limit - Number of items to return, which is also the `pageSize` of the results object. */
    limit: (limit: number) => ServiceOptionsAndVariantsListQueryBuilder;
    /** @param cursor - A pointer to specific record */
    skipTo: (cursor: string) => ServiceOptionsAndVariantsListQueryBuilder;
    find: () => Promise<ServiceOptionsAndVariantsListQueryResult>;
}
export {};
