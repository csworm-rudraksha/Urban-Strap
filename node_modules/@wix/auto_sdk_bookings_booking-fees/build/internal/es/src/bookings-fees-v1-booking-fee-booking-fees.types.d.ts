export interface BookingFee {
    /**
     * Booking fee ID.
     * @format GUID
     * @readonly
     */
    id?: string | null;
    /**
     * ID of the booking associated with the fee.
     * @format GUID
     */
    bookingId?: string | null;
    /** Cancellation fee details. */
    cancellationFee?: CancellationFee;
    /**
     * Information about the *booking policy snapshot*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/booking-policy-snapshots/introduction) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/policies/booking-policy-snapshots/introduction))
     * according to which the fee was created.
     */
    policyDetails?: PolicyDetails;
}
export interface CancellationFee {
    /** Price the customer must pay. */
    price?: Money;
    /** Status of the booking fee. */
    status?: BookingFeeStatus;
    /**
     * Information about what triggered the creation of the booking fee.
     * @readonly
     */
    trigger?: Trigger;
}
/**
 * Money.
 * Default format to use. Sufficiently compliant with majority of standards: w3c, ISO 4217, ISO 20022, ISO 8583:2003.
 */
export interface Money {
    /**
     * Monetary amount. Decimal string with a period as a decimal separator (e.g., 3.99). Optionally, a single (-), to indicate that the amount is negative.
     * @format DECIMAL_VALUE
     * @decimalValue options { gte:0, maxScale:2 }
     */
    value?: string;
    /**
     * Currency code. Must be valid ISO 4217 currency code (e.g., USD).
     * @format CURRENCY
     */
    currency?: string;
    /**
     * Monetary amount. Decimal string in local format (e.g., 1 000,30). Optionally, a single (-), to indicate that the amount is negative.
     * @maxLength 50
     * @readonly
     */
    formattedValue?: string | null;
}
export declare enum BookingFeeStatus {
    /** There is no eCommerce order associated with the booking. */
    UNKNOWN_STATUS = "UNKNOWN_STATUS",
    /** The fee is informational only; the customer doesn't have to pay it. For example, it shows how much the customer would owe if they canceled the booking now. */
    PREVIEW = "PREVIEW",
    /** The booking fee hasn't been added to the eCommerce order yet. */
    NOT_YET_APPLIED_TO_ORDER = "NOT_YET_APPLIED_TO_ORDER",
    /** The booking fee has been added to the eCommerce order. The customer may not have paid it yet. */
    APPLIED_TO_ORDER = "APPLIED_TO_ORDER"
}
/** The domain event that triggered the booking fee calculation. */
export declare enum Trigger {
    /** There is no information about what triggered the creation of the booking fee. */
    UNKNOWN_TRIGGER = "UNKNOWN_TRIGGER",
    /** The booking fee was created because the customer didn't show up to the booking or canceled after the expiration of the last cancellation window. */
    NOT_ATTENDED = "NOT_ATTENDED",
    /** The booking fee was created because the customer canceled the booking before the expiration of the last cancellation window. */
    BOOKING_CANCELED = "BOOKING_CANCELED"
}
export interface PolicyDetails {
    /**
     * ID of the booking policy.
     * @format GUID
     * @readonly
     */
    id?: string | null;
    /**
     * Description of the booking policy.
     * @maxLength 2500
     */
    description?: string | null;
}
export interface FailedToApplyBookingFeeToOrder {
    /** Booking fee which couldn't to be applied to the eCommerce order. */
    bookingFee?: BookingFee;
    /**
     * IDs of the booking fees that are related to the booking fee which couldn't be
     * applied to the eCommerce order.
     * @format GUID
     * @maxSize 4
     */
    relatedBookingFeeIds?: string[];
    /** Information about the affected eCommerce order. */
    ecomOrderInfo?: EcomOrderInfo;
    /**
     * Information about whether to notify the business about failing to apply the
     * booking fees to the eCommerce order and the message to send.
     */
    businessNotification?: BusinessNotification;
}
export interface EcomOrderInfo {
    /**
     * Order ID.
     * @format GUID
     */
    orderId?: string | null;
    /** Additional fee price. */
    additionalFeePrice?: Price;
    /**
     * The eCommerce additional fee id that was created on the order.
     * @format GUID
     */
    additionalFeeId?: string | null;
}
export interface Price {
    /**
     * Amount.
     * @decimalValue options { gte:0, lte:1000000000000000, maxScale:2 }
     */
    amount?: string;
    /**
     * Amount formatted with currency symbol.
     * @readonly
     * @maxLength 100
     */
    formattedAmount?: string;
}
export interface BusinessNotification {
    /**
     * Whether to notify the business about changes made to the booking fees.
     * Default is false.
     */
    notifyBusiness?: boolean | null;
    /**
     * Optional custom message to send.
     * @minLength 1
     * @maxLength 5000
     */
    message?: string | null;
}
export interface FailedToCollectAppliedBookingFees {
    /**
     * IDs of the bookings for which the booking fees couldn't be collected from the
     * customer.
     * @format GUID
     * @maxSize 4
     */
    bookingIds?: string[];
    /** Information about the affected eCommerce order. */
    ecomOrderInfo?: EcomOrderInfo;
    /**
     * Information about whether to notify the business about failing to collect the
     * booking fees from the customer and the message to send.
     */
    businessNotification?: BusinessNotification;
}
export interface ListBookingFeesByBookingIdsRequest {
    /**
     * IDs of the bookings to retrieve booking fees for.
     * @format GUID
     * @maxSize 5
     */
    bookingIds?: string[];
    /**
     * IDs of the multi service bookings to retrieve booking fees for.
     * @format GUID
     * @maxSize 1
     */
    multiServiceBookingIds?: string[];
}
export interface ListBookingFeesByBookingIdsResponse {
    /** List of retrieved booking fees. */
    bookingFees?: BookingFee[];
    /** Paging metadata. */
    pagingMetadata?: CursorPagingMetadata;
}
export interface CursorPagingMetadata {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Cursor strings that point to the next page, previous page, or both. */
    cursors?: Cursors;
    /**
     * Whether there are more pages to retrieve following the current page.
     *
     * + `true`: Another page of results can be retrieved.
     * + `false`: This is the last page.
     */
    hasNext?: boolean | null;
}
export interface Cursors {
    /**
     * Cursor string pointing to the next page in the list of results.
     * @maxLength 16000
     */
    next?: string | null;
    /**
     * Cursor pointing to the previous page in the list of results.
     * @maxLength 16000
     */
    prev?: string | null;
}
export interface ApplyBookingFeesToOrderRequest {
    /**
     * IDs of the bookings for which to apply booking fees to an eCommerce order.
     * @format GUID
     * @minSize 1
     * @maxSize 5
     */
    bookingIds: string[] | null;
    /**
     * Custom price override for the additional fee that's added to the eCommerce
     * order. The override mustn't exceed the sum of all booking fees. You must have
     * the `OVERRIDE_BOOKING_FEE_PRICE` permission to use this property.
     */
    priceOverride?: Money;
    /**
     * Information about the message to the business and whether to send it if the
     * booking fee application to the eCommerce order fails.
     */
    businessNotification?: BusinessNotification;
}
export interface ApplyBookingFeesToOrderResponse {
    /**
     * Booking fees that were applied as a single additional fee to the eCommerce
     * order.
     */
    bookingFees?: BookingFee[];
    /** Information about the eCommerce order to which the booking fees are applied. */
    ecomOrderInfo?: EcomOrderInfo;
}
export interface ListNonPreviewBookingFeesByBookingIdsRequest {
    /**
     * IDs of the bookings to retrieve booking fees for.
     * @format GUID
     * @minSize 1
     * @maxSize 100
     */
    bookingIds?: string[];
}
export interface ListNonPreviewBookingFeesByBookingIdsResponse {
    /** List of retrieved booking fees. */
    bookingFees?: BookingFee[];
}
export interface CollectAppliedBookingFeesRequest {
    /**
     * ID of the eCommerce order that includes the booking fees as a single
     * `additionalFee`.
     * @format GUID
     */
    orderId: string | null;
    /**
     * ID of the additional fee that's related to all given booking fees.
     * @format GUID
     */
    additionalFeeId: string | null;
    /**
     * Information about whether to notify the business about failing to collect the
     * booking fees from the customer and the message to send.
     */
    businessNotification?: BusinessNotification;
}
export interface CollectAppliedBookingFeesResponse {
    /** Collected amount. */
    collectedPrice?: Price;
}
export interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /**
     * Unique event ID.
     * Allows clients to ignore duplicate webhooks.
     */
    id?: string;
    /**
     * Assumes actions are also always typed to an entity_type
     * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
     */
    entityFqdn?: string;
    /**
     * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
     * This is although the created/updated/deleted notion is duplication of the oneof types
     * Example: created/updated/deleted/started/completed/email_opened
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number defining the order of updates to the underlying entity.
     * For example, given that some entity was updated at 16:00 and than again at 16:01,
     * it is guaranteed that the sequence number of the second update is strictly higher than the first.
     * As the consumer, you can use this value to ensure that you handle messages in the correct order.
     * To do so, you will need to persist this number on your end, and compare the sequence number from the
     * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
export interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
export interface EntityCreatedEvent {
    entityAsJson?: string;
    /** Indicates the event was triggered by a restore-from-trashbin operation for a previously deleted entity */
    restoreInfo?: RestoreInfo;
}
export interface RestoreInfo {
    deletedDate?: Date | null;
}
export interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntityAsJson?: string;
}
export interface EntityDeletedEvent {
    /** Entity that was deleted */
    deletedEntityAsJson?: string | null;
}
export interface ActionEvent {
    bodyAsJson?: string;
}
export interface MessageEnvelope {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
export interface IdentificationData extends IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityType;
}
/** @oneof */
export interface IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
}
export declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
interface MoneyNonNullableFields {
    value: string;
    currency: string;
}
interface CancellationFeeNonNullableFields {
    price?: MoneyNonNullableFields;
    status: BookingFeeStatus;
    trigger: Trigger;
}
interface BookingFeeNonNullableFields {
    cancellationFee?: CancellationFeeNonNullableFields;
}
export interface ListBookingFeesByBookingIdsResponseNonNullableFields {
    bookingFees: BookingFeeNonNullableFields[];
}
interface PriceNonNullableFields {
    amount: string;
    formattedAmount: string;
}
interface EcomOrderInfoNonNullableFields {
    additionalFeePrice?: PriceNonNullableFields;
}
export interface ApplyBookingFeesToOrderResponseNonNullableFields {
    bookingFees: BookingFeeNonNullableFields[];
    ecomOrderInfo?: EcomOrderInfoNonNullableFields;
}
export interface CollectAppliedBookingFeesResponseNonNullableFields {
    collectedPrice?: PriceNonNullableFields;
}
export {};
