export interface BookingFee {
    /**
     * Booking fee ID.
     * @format GUID
     * @readonly
     */
    _id?: string | null;
    /**
     * ID of the booking associated with the fee.
     * @format GUID
     */
    bookingId?: string | null;
    /** Cancellation fee details. */
    cancellationFee?: CancellationFee;
    /**
     * Information about the *booking policy snapshot*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/booking-policy-snapshots/introduction) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/policies/booking-policy-snapshots/introduction))
     * according to which the fee was created.
     */
    policyDetails?: PolicyDetails;
}
export interface CancellationFee {
    /** Price the customer must pay. */
    price?: Money;
    /** Status of the booking fee. */
    status?: BookingFeeStatus;
    /**
     * Information about what triggered the creation of the booking fee.
     * @readonly
     */
    trigger?: Trigger;
}
/**
 * Money.
 * Default format to use. Sufficiently compliant with majority of standards: w3c, ISO 4217, ISO 20022, ISO 8583:2003.
 */
export interface Money {
    /**
     * Monetary amount. Decimal string with a period as a decimal separator (e.g., 3.99). Optionally, a single (-), to indicate that the amount is negative.
     * @format DECIMAL_VALUE
     * @decimalValue options { gte:0, maxScale:2 }
     */
    value?: string;
    /**
     * Currency code. Must be valid ISO 4217 currency code (e.g., USD).
     * @format CURRENCY
     */
    currency?: string;
    /**
     * Monetary amount. Decimal string in local format (e.g., 1 000,30). Optionally, a single (-), to indicate that the amount is negative.
     * @maxLength 50
     * @readonly
     */
    formattedValue?: string | null;
}
export declare enum BookingFeeStatus {
    /** There is no eCommerce order associated with the booking. */
    UNKNOWN_STATUS = "UNKNOWN_STATUS",
    /** The fee is informational only; the customer doesn't have to pay it. For example, it shows how much the customer would owe if they canceled the booking now. */
    PREVIEW = "PREVIEW",
    /** The booking fee hasn't been added to the eCommerce order yet. */
    NOT_YET_APPLIED_TO_ORDER = "NOT_YET_APPLIED_TO_ORDER",
    /** The booking fee has been added to the eCommerce order. The customer may not have paid it yet. */
    APPLIED_TO_ORDER = "APPLIED_TO_ORDER"
}
/** The domain event that triggered the booking fee calculation. */
export declare enum Trigger {
    /** There is no information about what triggered the creation of the booking fee. */
    UNKNOWN_TRIGGER = "UNKNOWN_TRIGGER",
    /** The booking fee was created because the customer didn't show up to the booking or canceled after the expiration of the last cancellation window. */
    NOT_ATTENDED = "NOT_ATTENDED",
    /** The booking fee was created because the customer canceled the booking before the expiration of the last cancellation window. */
    BOOKING_CANCELED = "BOOKING_CANCELED"
}
export interface PolicyDetails {
    /**
     * ID of the booking policy.
     * @format GUID
     * @readonly
     */
    _id?: string | null;
    /**
     * Description of the booking policy.
     * @maxLength 2500
     */
    description?: string | null;
}
export interface FailedToApplyBookingFeeToOrder {
    /** Booking fee which couldn't to be applied to the eCommerce order. */
    bookingFee?: BookingFee;
    /**
     * IDs of the booking fees that are related to the booking fee which couldn't be
     * applied to the eCommerce order.
     * @format GUID
     * @maxSize 4
     */
    relatedBookingFeeIds?: string[];
    /** Information about the affected eCommerce order. */
    ecomOrderInfo?: EcomOrderInfo;
    /**
     * Information about whether to notify the business about failing to apply the
     * booking fees to the eCommerce order and the message to send.
     */
    businessNotification?: BusinessNotification;
}
export interface EcomOrderInfo {
    /**
     * Order ID.
     * @format GUID
     */
    orderId?: string | null;
    /** Additional fee price. */
    additionalFeePrice?: Price;
    /**
     * The eCommerce additional fee id that was created on the order.
     * @format GUID
     */
    additionalFeeId?: string | null;
}
export interface Price {
    /**
     * Amount.
     * @decimalValue options { gte:0, lte:1000000000000000, maxScale:2 }
     */
    amount?: string;
    /**
     * Amount formatted with currency symbol.
     * @readonly
     * @maxLength 100
     */
    formattedAmount?: string;
}
export interface BusinessNotification {
    /**
     * Whether to notify the business about changes made to the booking fees.
     * Default is false.
     */
    notifyBusiness?: boolean | null;
    /**
     * Optional custom message to send.
     * @minLength 1
     * @maxLength 5000
     */
    message?: string | null;
}
export interface FailedToCollectAppliedBookingFees {
    /**
     * IDs of the bookings for which the booking fees couldn't be collected from the
     * customer.
     * @format GUID
     * @maxSize 4
     */
    bookingIds?: string[];
    /** Information about the affected eCommerce order. */
    ecomOrderInfo?: EcomOrderInfo;
    /**
     * Information about whether to notify the business about failing to collect the
     * booking fees from the customer and the message to send.
     */
    businessNotification?: BusinessNotification;
}
export interface ListBookingFeesByBookingIdsRequest {
    /**
     * IDs of the bookings to retrieve booking fees for.
     * @format GUID
     * @maxSize 5
     */
    bookingIds?: string[];
    /**
     * IDs of the multi service bookings to retrieve booking fees for.
     * @format GUID
     * @maxSize 1
     */
    multiServiceBookingIds?: string[];
}
export interface ListBookingFeesByBookingIdsResponse {
    /** List of retrieved booking fees. */
    bookingFees?: BookingFee[];
    /** Paging metadata. */
    pagingMetadata?: CursorPagingMetadata;
}
export interface CursorPagingMetadata {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Cursor strings that point to the next page, previous page, or both. */
    cursors?: Cursors;
    /**
     * Whether there are more pages to retrieve following the current page.
     *
     * + `true`: Another page of results can be retrieved.
     * + `false`: This is the last page.
     */
    hasNext?: boolean | null;
}
export interface Cursors {
    /**
     * Cursor string pointing to the next page in the list of results.
     * @maxLength 16000
     */
    next?: string | null;
    /**
     * Cursor pointing to the previous page in the list of results.
     * @maxLength 16000
     */
    prev?: string | null;
}
export interface ApplyBookingFeesToOrderRequest {
    /**
     * IDs of the bookings for which to apply booking fees to an eCommerce order.
     * @format GUID
     * @minSize 1
     * @maxSize 5
     */
    bookingIds: string[] | null;
    /**
     * Custom price override for the additional fee that's added to the eCommerce
     * order. The override mustn't exceed the sum of all booking fees. You must have
     * the `OVERRIDE_BOOKING_FEE_PRICE` permission to use this property.
     */
    priceOverride?: Money;
    /**
     * Information about the message to the business and whether to send it if the
     * booking fee application to the eCommerce order fails.
     */
    businessNotification?: BusinessNotification;
}
export interface ApplyBookingFeesToOrderResponse {
    /**
     * Booking fees that were applied as a single additional fee to the eCommerce
     * order.
     */
    bookingFees?: BookingFee[];
    /** Information about the eCommerce order to which the booking fees are applied. */
    ecomOrderInfo?: EcomOrderInfo;
}
export interface ListNonPreviewBookingFeesByBookingIdsRequest {
    /**
     * IDs of the bookings to retrieve booking fees for.
     * @format GUID
     * @minSize 1
     * @maxSize 100
     */
    bookingIds?: string[];
}
export interface ListNonPreviewBookingFeesByBookingIdsResponse {
    /** List of retrieved booking fees. */
    bookingFees?: BookingFee[];
}
export interface CollectAppliedBookingFeesRequest {
    /**
     * ID of the eCommerce order that includes the booking fees as a single
     * `additionalFee`.
     * @format GUID
     */
    orderId: string | null;
    /**
     * ID of the additional fee that's related to all given booking fees.
     * @format GUID
     */
    additionalFeeId: string | null;
    /**
     * Information about whether to notify the business about failing to collect the
     * booking fees from the customer and the message to send.
     */
    businessNotification?: BusinessNotification;
}
export interface CollectAppliedBookingFeesResponse {
    /** Collected amount. */
    collectedPrice?: Price;
}
export interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /**
     * Unique event ID.
     * Allows clients to ignore duplicate webhooks.
     */
    _id?: string;
    /**
     * Assumes actions are also always typed to an entity_type
     * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
     */
    entityFqdn?: string;
    /**
     * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
     * This is although the created/updated/deleted notion is duplication of the oneof types
     * Example: created/updated/deleted/started/completed/email_opened
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number defining the order of updates to the underlying entity.
     * For example, given that some entity was updated at 16:00 and than again at 16:01,
     * it is guaranteed that the sequence number of the second update is strictly higher than the first.
     * As the consumer, you can use this value to ensure that you handle messages in the correct order.
     * To do so, you will need to persist this number on your end, and compare the sequence number from the
     * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
export interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
export interface EntityCreatedEvent {
    entity?: string;
}
export interface RestoreInfo {
    deletedDate?: Date | null;
}
export interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntity?: string;
}
export interface EntityDeletedEvent {
    /** Entity that was deleted */
    deletedEntity?: string | null;
}
export interface ActionEvent {
    body?: string;
}
export interface MessageEnvelope {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
export interface IdentificationData extends IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityType;
}
/** @oneof */
export interface IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
}
export declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
interface MoneyNonNullableFields {
    value: string;
    currency: string;
}
interface CancellationFeeNonNullableFields {
    price?: MoneyNonNullableFields;
    status: BookingFeeStatus;
    trigger: Trigger;
}
interface BookingFeeNonNullableFields {
    cancellationFee?: CancellationFeeNonNullableFields;
}
export interface ListBookingFeesByBookingIdsResponseNonNullableFields {
    bookingFees: BookingFeeNonNullableFields[];
}
interface PriceNonNullableFields {
    amount: string;
    formattedAmount: string;
}
interface EcomOrderInfoNonNullableFields {
    additionalFeePrice?: PriceNonNullableFields;
}
export interface ApplyBookingFeesToOrderResponseNonNullableFields {
    bookingFees: BookingFeeNonNullableFields[];
    ecomOrderInfo?: EcomOrderInfoNonNullableFields;
}
export interface CollectAppliedBookingFeesResponseNonNullableFields {
    collectedPrice?: PriceNonNullableFields;
}
/**
 * Retrieves booking fees by booking IDs.
 *
 *
 * Instead of returning `bookingFee` objects with the `cancellationFee.price.value`
 * set to `0.00`, the method doesn't return a `bookingFee` object for the relevant
 * booking IDs. For example, no `bookingFee` object is returned if the canceled
 * booking was free or if the booking was canceled before the start of the earliest
 * cancellation window with an associated fee.
 *
 * If the service's booking policy has been updated since the booking was created,
 * booking fees are calculated according to the *booking policy snapshot*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/booking-policy-snapshots/introduction) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/policies/booking-policy-snapshots/introduction))
 * rather than the current version of the *policy*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/booking-policies/introduction) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/policies/booking-policies/introduction)).
 *
 * This method calculates the cancellation fee amount based on the time of the
 * call, you can't specify a time. Similarly, it calculates the cancellation fee
 * based on the number of participants who canceled, not a provided number.
 *
 * A `cancellationFee.status` of `PREVIEW` indicates that the booking fee is
 * informational only; the customer isn't required to pay it. When the `status` is
 * set to `UNKNOWN_STATUS` there is no eCommerce order associated with the booking. For
 * example, if a custom checkout was used for the booking instead of the
 * _eCommerce checkout_
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/ecom/checkout/setup) | [REST](https://dev.wix.com/docs/rest/business-solutions/e-commerce/checkout/introduction)).
 *
 * If multiple events would trigger the calculation of a booking fee, for example
 * when a booking is first canceled and then marked as not attended, Wix calculates
 * the booking fee based on the first trigger. In this example, the booking
 * cancellation.
 * @public
 * @documentationMaturity preview
 * @param options - Options to use when listing booking fees.
 * @permissionId BOOKINGS.BOOKING_FEES_READ
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Read Bookings - Including Participants
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-SENSITIVE
 * @permissionScope Read Bookings - all read permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.READ-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @applicableIdentity VISITOR
 * @fqn wix.bookings.fees.v1.BookingFees.ListBookingFeesByBookingIds
 */
export declare function listBookingFeesByBookingIds(options?: ListBookingFeesByBookingIdsOptions): Promise<ListBookingFeesByBookingIdsResponse & ListBookingFeesByBookingIdsResponseNonNullableFields>;
export interface ListBookingFeesByBookingIdsOptions {
    /**
     * IDs of the bookings to retrieve booking fees for.
     * @format GUID
     * @maxSize 5
     */
    bookingIds?: string[];
    /**
     * IDs of the multi service bookings to retrieve booking fees for.
     * @format GUID
     * @maxSize 1
     */
    multiServiceBookingIds?: string[];
}
/**
 * Applies booking fees to an _eCommerce order_
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/ecom/orders/setup) | [REST](https://dev.wix.com/docs/rest/business-solutions/e-commerce/orders/introduction)).
 *
 *
 * The booking fees are added as a single additional fee to the eCommerce order.
 * The order's `additionalFee.lineItemIds` array is set to the list of corresponding
 * booking IDs. By default, the `additionalFee.price.amount` is the sum of all
 * booking fee prices. But you may provide a `priceOverride` instead. The override
 * price can't be higher than the sum of all booking fees.
 *
 * Apply Booking Fees to Order also updates the prices of all affected line items
 * in the relevant eCommerce order to zero. After a cancellation fee is applied
 * to an eCommerce order, the cancellation fee's `price.value` is updated to `0.00`
 * and its trigger is set to `UNKNOWN_TRIGGER`. You can retrieve the fee amount
 * from the corresponding `additionalFee` object of the eCommerce order with
 * _Search Orders_
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/ecom/orders/search-orders) | [REST](https://dev.wix.com/docs/rest/business-solutions/e-commerce/orders/search-orders)).
 *
 * If you apply multiple booking fees to an eCommerce order, they either all fail or
 * all succeed together. For example, the call fails if the booking fees are associated
 * with different eCommmerce orders.
 * @param bookingIds - IDs of the bookings for which to apply booking fees to an eCommerce order.
 * @public
 * @documentationMaturity preview
 * @requiredField bookingIds
 * @requiredField options.priceOverride.currency
 * @requiredField options.priceOverride.value
 * @param options - Options to use when applying booking fees to an eCommerce order.
 * @permissionId BOOKINGS.BOOKING_FEE_APPLY_TO_ORDER
 * @fqn wix.bookings.fees.v1.BookingFees.ApplyBookingFeesToOrder
 */
export declare function applyBookingFeesToOrder(bookingIds: string[] | null, options?: ApplyBookingFeesToOrderOptions): Promise<ApplyBookingFeesToOrderResponse & ApplyBookingFeesToOrderResponseNonNullableFields>;
export interface ApplyBookingFeesToOrderOptions {
    /**
     * Custom price override for the additional fee that's added to the eCommerce
     * order. The override mustn't exceed the sum of all booking fees. You must have
     * the `OVERRIDE_BOOKING_FEE_PRICE` permission to use this property.
     */
    priceOverride?: Money;
    /**
     * Information about the message to the business and whether to send it if the
     * booking fee application to the eCommerce order fails.
     */
    businessNotification?: BusinessNotification;
}
/**
 * Collects booking fees by charging the customer using the payment method that's
 * saved on the corresponding *eCommerce order*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/ecom/orders/setup) | [REST](https://dev.wix.com/docs/rest/business-solutions/e-commerce/orders/introduction))
 *
 *
 * <blockquote class="warning">
 *
 * __Warning:__
 * Currently, there is no validation that prevents idempotent requests.
 * This means that your code must make sure to not charge customers multiple
 * times for the same booking fee. You could use
 * _List Transactions For Single Order_
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/ecom/order-transactions/list-transactions-for-single-order) | [REST](https://dev.wix.com/docs/rest/business-solutions/e-commerce/order-transactions/list-transactions-for-single-order))
 * to check which charges were made previously for an eCommerce order.
 *
 * </blockquote>
 *
 * An HTTP status of `200` means that all booking fees were successfully collected.
 * Any other HTPP status means that collection failed.
 *
 * Collects the order's `additionalFees.price.amount` that's related to the
 * booking fees. If there are multiple additional fees on the eCommerce order,
 * the amount that's collected differs from `priceSummary.totalAdditionalFees.amount`.
 *
 * Possible failure reasons include:
 * + The order's `status` isn't `APPROVED`.
 * + There is no payment method saved on the order.
 * + The order's `balanceSummary.balance.amount` is lower than the
 * `additionalFees.price.amount` to collect.
 * + The order's `additionalFeeId` doesn't belong to a Wix Bookings cancellation fee.
 * @param orderId - ID of the eCommerce order that includes the booking fees as a single
 * `additionalFee`.
 * @public
 * @documentationMaturity preview
 * @requiredField options.additionalFeeId
 * @requiredField orderId
 * @param options - Options to use when collecting booking fees that have been applied to an eCommerce order.
 * @permissionId BOOKINGS.BOOKING_FEE_COLLECT
 * @fqn wix.bookings.fees.v1.BookingFees.CollectAppliedBookingFees
 */
export declare function collectAppliedBookingFees(orderId: string | null, options?: CollectAppliedBookingFeesOptions): Promise<CollectAppliedBookingFeesResponse & CollectAppliedBookingFeesResponseNonNullableFields>;
export interface CollectAppliedBookingFeesOptions {
    /**
     * ID of the additional fee that's related to all given booking fees.
     * @format GUID
     */
    additionalFeeId: string | null;
    /**
     * Information about whether to notify the business about failing to collect the
     * booking fees from the customer and the message to send.
     */
    businessNotification?: BusinessNotification;
}
export {};
