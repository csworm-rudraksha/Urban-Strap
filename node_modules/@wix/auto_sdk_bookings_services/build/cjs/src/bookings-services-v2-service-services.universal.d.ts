/** The `service` object represents an offering that a business provides to its customers. */
export interface Service {
    /**
     * Service ID.
     * @format GUID
     * @readonly
     */
    _id?: string | null;
    /**
     * Service type.
     * Learn more about *service types*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/services/about-service-types) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/services-v2/about-service-types)).
     */
    type?: ServiceType;
    /**
     * Order of the service within a *category*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/categories/setup) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/categories-v1/category-object)).
     */
    sortOrder?: number | null;
    /**
     * Service name.
     * @maxLength 400
     * @minLength 1
     */
    name?: string | null;
    /**
     * Service description. For example, `High-class hair styling, cuts, straightening and color`.
     * @maxLength 7000
     */
    description?: string | null;
    /**
     * Short service description, such as `Hair styling`.
     * @maxLength 6000
     */
    tagLine?: string | null;
    /**
     * Default maximum number of customers that can book the service. The service cannot be booked beyond this capacity.
     * @min 1
     * @max 1000
     */
    defaultCapacity?: number | null;
    /** Media associated with the service. */
    media?: Media;
    /** Whether the service is hidden from the site. */
    hidden?: boolean | null;
    /**
     * _Category_
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/categories/setup) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/categories-v1/category-object))
     * the service is associated with.
     */
    category?: V2Category;
    /** Form the customer filled out when booking the service. */
    form?: Form;
    /**
     * Payment options for booking the service.
     * Learn more about *service payments*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/services/about-service-payments) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/services-v2/about-service-payments)).
     */
    payment?: Payment;
    /** Online booking settings. */
    onlineBooking?: OnlineBooking;
    /** Conferencing options for the service. */
    conferencing?: Conferencing;
    /**
     * The locations this service is offered at. Read more about *service locations*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/services/about-service-locations) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/services-v2/about-service-locations)).
     * @immutable
     * @maxSize 500
     */
    locations?: V2Location[];
    /**
     * _Policy_
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/booking-policies/introduction) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/policies/booking-policies/introduction))
     * determining under what conditions this service can be booked. For example, whether the service can only be booked up to 30 minutes before it begins.
     */
    bookingPolicy?: BookingPolicy;
    /**
     * The service's *schedule*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/calendar/schedules/introduction) | [REST](https://dev.wix.com/docs/rest/business-management/calendar/schedules-v3/introduction)),
     * which can be used to manage the service's *events*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/calendar/events/introduction) | [REST](https://dev.wix.com/docs/rest/business-management/calendar/events-v3/introduction)).
     */
    schedule?: V2Schedule;
    /**
     * IDs of the *staff members*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/staff-members/introduction) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/staff-members/introduction))
     * providing the service. Available only for appointment-based services.
     * @maxSize 220
     * @format GUID
     */
    staffMemberIds?: string[];
    /**
     * Information about which resources must be available so customers can book the service.
     * For example, a meeting room or equipment.
     * @maxSize 3
     */
    serviceResources?: ServiceResource[];
    /**
     * A slug is the last part of the URL address that serves as a unique identifier of the service.
     * The list of supported slugs includes past service names for backwards compatibility, and a custom slug if one was set by the business owner.
     * @readonly
     * @maxSize 100
     */
    supportedSlugs?: Slug[];
    /**
     * Active slug for the service.
     * Learn more about *service slugs*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/services/about-service-slugs) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/services-v2/about-service-slugs)).
     * @readonly
     */
    mainSlug?: Slug;
    /**
     * URLs to various service-related pages, such as the calendar page and the booking page.
     * @readonly
     */
    urls?: URLs;
    /** Extensions enabling users to save custom data related to the service. */
    extendedFields?: ExtendedFields;
    /** Custom SEO data for the service. */
    seoData?: SeoSchema;
    /**
     * Date and time the service was created in `YYYY-MM-DDThh:mm:ss.sssZ` format.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * Date and time the service was updated in `YYYY-MM-DDThh:mm:ss.sssZ` format.
     * @readonly
     */
    _updatedDate?: Date | null;
    /**
     * Revision number, which increments by 1 each time the service is updated. To
     * prevent conflicting changes, the existing revision must be used when updating
     * a service.
     * @readonly
     */
    revision?: string | null;
}
export declare enum ServiceType {
    /** Appointment-based service. */
    APPOINTMENT = "APPOINTMENT",
    /** Class service. */
    CLASS = "CLASS",
    /** Course service. */
    COURSE = "COURSE"
}
export interface Media {
    /**
     * Media items associated with the service.
     * @maxSize 100
     */
    items?: MediaItem[];
    /** Primary media associated with the service. */
    mainMedia?: MediaItem;
    /** Cover media associated with the service. */
    coverMedia?: MediaItem;
}
export interface MediaItem extends MediaItemItemOneOf {
    /** Details of the image associated with the service, such as URL and size. */
    image?: string;
}
/** @oneof */
export interface MediaItemItemOneOf {
    /** Details of the image associated with the service, such as URL and size. */
    image?: string;
}
export interface V2Category {
    /**
     * Category ID.
     * @format GUID
     */
    _id?: string;
    /**
     * Category name.
     * @maxLength 500
     * @readonly
     */
    name?: string | null;
    /**
     * Order of a category within a category list.
     * @readonly
     */
    sortOrder?: number | null;
}
export interface Form {
    /**
     * ID of the form associated with the service.
     * The form information that you submit when booking includes contact details, participants, and other form fields set up for the service.
     * You can manage the service booking form fields using the Bookings Forms API.
     * @format GUID
     */
    _id?: string;
}
export interface FormSettings {
    /** Whether the service booking form should be hidden from the site. */
    hidden?: boolean | null;
}
export interface Payment extends PaymentRateOneOf {
    /**
     * The details for the fixed price of the service.
     *
     * Required when: `rateType` is `FIXED`
     */
    fixed?: FixedPayment;
    /**
     * The details for the custom price of the service.
     *
     * Required when: `rateType` is `CUSTOM`
     */
    custom?: CustomPayment;
    /**
     * The details for the varied pricing of the service.
     * Read more about [varied price options](https://support.wix.com/en/article/wix-bookings-about-getting-paid-online#offering-varied-price-options).
     *
     * Required when: `rateType` is `VARIED`
     */
    varied?: VariedPayment;
    /** The rate the customer is expected to pay for the service. */
    rateType?: RateType;
    /** The payment options a customer can use to pay for the service. */
    options?: PaymentOptions;
    /**
     * IDs of pricing plans that can be used as payment for the service.
     * @readonly
     * @maxSize 75
     * @format GUID
     */
    pricingPlanIds?: string[];
}
/** @oneof */
export interface PaymentRateOneOf {
    /**
     * The details for the fixed price of the service.
     *
     * Required when: `rateType` is `FIXED`
     */
    fixed?: FixedPayment;
    /**
     * The details for the custom price of the service.
     *
     * Required when: `rateType` is `CUSTOM`
     */
    custom?: CustomPayment;
    /**
     * The details for the varied pricing of the service.
     * Read more about [varied price options](https://support.wix.com/en/article/wix-bookings-about-getting-paid-online#offering-varied-price-options).
     *
     * Required when: `rateType` is `VARIED`
     */
    varied?: VariedPayment;
}
export declare enum RateType {
    /** Unknown rate type. */
    UNKNOWN_RATE_TYPE = "UNKNOWN_RATE_TYPE",
    /** The service has a fixed price. */
    FIXED = "FIXED",
    /** The service has a custom price, expressed as a price description. */
    CUSTOM = "CUSTOM",
    /** This service is offered with a set of different prices based on different terms. */
    VARIED = "VARIED",
    /** This service is offered free of charge. */
    NO_FEE = "NO_FEE"
}
export interface FixedPayment {
    /**
     * The fixed price required to book the service.
     *
     * Required when: `rateType` is `FIXED`
     */
    price?: Money;
    /**
     * The deposit price required to book the service.
     *
     * Required when: `rateType` is `FIXED` and `paymentOptions.deposit` is `true`
     */
    deposit?: Money;
}
/**
 * Money.
 * Default format to use. Sufficiently compliant with majority of standards: w3c, ISO 4217, ISO 20022, ISO 8583:2003.
 */
export interface Money {
    /**
     * Monetary amount. Decimal string with a period as a decimal separator (e.g., 3.99). Optionally, a single (-), to indicate that the amount is negative.
     * @format DECIMAL_VALUE
     * @decimalValue options { gt:0, maxScale:2 }
     */
    value?: string;
    /**
     * Currency code. Must be valid ISO 4217 currency code (e.g., USD).
     * @format CURRENCY
     * @readonly
     */
    currency?: string;
    /**
     * Monetary amount. Decimal string in local format (e.g., 1 000,30). Optionally, a single (-), to indicate that the amount is negative.
     * @maxLength 50
     */
    formattedValue?: string | null;
}
export interface CustomPayment {
    /**
     * A custom description explaining to the customer how to pay for the service.
     * @maxLength 50
     */
    description?: string | null;
}
export interface VariedPayment {
    /** The default price for the service without any variants. It will also be used as the default price for any new variant. */
    defaultPrice?: Money;
    /**
     * The deposit price required to book the service.
     *
     * Required when: `rateType` is `VARIED` and `paymentOptions.deposit` is `true`
     */
    deposit?: Money;
    /**
     * The minimal price a customer may pay for this service, based on its variants.
     * @readonly
     */
    minPrice?: Money;
    /**
     * The maximum price a customer may pay for this service, based on its variants.
     * @readonly
     */
    maxPrice?: Money;
}
export interface PaymentOptions {
    /**
     * Customers can pay for the service online.
     * When `true`:
     * + `rateType` must be either `FIXED` or `VARIED`.
     * + `fixed.price` or `varied.default_price` must be specified respectively. Read more about [getting paid online](https://support.wix.com/en/article/wix-bookings-about-getting-paid-online).
     */
    online?: boolean | null;
    /** Customers can pay for the service in person. */
    inPerson?: boolean | null;
    /**
     * This service requires a deposit to be made online in order to book it.
     * When `true`:
     * + `rateType` must be `VARIED` or `FIXED`.
     * + A `deposit` must be specified.
     */
    deposit?: boolean | null;
    /** Customers can pay for the service using a pricing plan. */
    pricingPlan?: boolean | null;
}
export interface OnlineBooking {
    /**
     * Whether the service can be booked online.
     * When set to `true`, customers can book the service online. Configure the payment options via the `service.payment` property.
     * When set to `false`, customers cannot book the service online, and the service can only be paid for in person.
     */
    enabled?: boolean | null;
    /** Booking the service requires approval by the Wix user. */
    requireManualApproval?: boolean | null;
    /** Multiple customers can request to book the same time slot. This is relevant when `requireManualApproval` is `true`. */
    allowMultipleRequests?: boolean | null;
}
export interface Conferencing {
    /** Whether a conference link is generated for the service's sessions. */
    enabled?: boolean | null;
}
export interface V2Location extends V2LocationOptionsOneOf {
    /** Information about business locations. */
    business?: BusinessLocationOptions;
    /** Information about custom locations. */
    custom?: CustomLocationOptions;
    /**
     * Location ID.
     * @format GUID
     * @readonly
     */
    _id?: string;
    /**
     * Location type.
     *
     * Default: `CUSTOM`
     */
    type?: LocationTypeEnumLocationType;
    /**
     * Location address. Empty for `{"type": "CUSTOMER"}`.
     * @readonly
     */
    calculatedAddress?: CommonAddress;
}
/** @oneof */
export interface V2LocationOptionsOneOf {
    /** Information about business locations. */
    business?: BusinessLocationOptions;
    /** Information about custom locations. */
    custom?: CustomLocationOptions;
}
export declare enum LocationTypeEnumLocationType {
    UNKNOWN_LOCATION_TYPE = "UNKNOWN_LOCATION_TYPE",
    /**
     * Location set by the business that is not a standard business *location*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/business-tools/locations/introduction) | [REST](https://dev.wix.com/docs/rest/business-management/locations/introduction)).
     */
    CUSTOM = "CUSTOM",
    /**
     * Business *location*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/business-tools/locations/introduction) | [REST](https://dev.wix.com/docs/rest/business-management/locations/introduction)).
     */
    BUSINESS = "BUSINESS",
    /**
     * The customer specifies any address when booking. Available only for
     * appointment-based services.
     */
    CUSTOMER = "CUSTOMER"
}
export interface CommonAddress extends CommonAddressStreetOneOf {
    /** Street name and number. */
    streetAddress?: CommonStreetAddress;
    /** @maxLength 255 */
    addressLine1?: string | null;
    /**
     * 2-letter country code in an [ISO-3166 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
     * @format COUNTRY
     */
    country?: string | null;
    /**
     * Code for a subdivision (such as state, prefecture, or province) in [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) format.
     * @maxLength 255
     */
    subdivision?: string | null;
    /**
     * City name.
     * @maxLength 255
     */
    city?: string | null;
    /**
     * Postal or zip code.
     * @maxLength 255
     */
    postalCode?: string | null;
    /**
     * Full address of the location.
     * @maxLength 512
     */
    formatted?: string | null;
}
/** @oneof */
export interface CommonAddressStreetOneOf {
    /** Street name and number. */
    streetAddress?: CommonStreetAddress;
    /** @maxLength 255 */
    addressLine?: string | null;
}
/** Street address. Includes street name, number, and apartment number in separate fields. */
export interface CommonStreetAddress {
    /**
     * Street number.
     * @maxLength 255
     */
    number?: string;
    /**
     * Street name.
     * @maxLength 255
     */
    name?: string;
    /**
     * Apartment number.
     * @maxLength 255
     */
    apt?: string;
}
export interface CommonAddressLocation {
    /** Address latitude. */
    latitude?: number | null;
    /** Address longitude. */
    longitude?: number | null;
}
export interface BusinessLocationOptions {
    /**
     * ID of the business *location*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/business-tools/locations/introduction) | [REST](https://dev.wix.com/docs/rest/business-management/locations/introduction)).
     * When setting a business location, specify only the location ID. Other location details are overwritten.
     * @format GUID
     */
    _id?: string;
    /**
     * Business location name.
     * @readonly
     * @maxLength 150
     */
    name?: string;
    /**
     * Whether this is the default location. There can only be a single default location per site.
     * @readonly
     */
    default?: boolean | null;
    /**
     * Business location address.
     * @readonly
     */
    address?: CommonAddress;
    /**
     * Business location email.
     * @format EMAIL
     * @readonly
     */
    email?: string | null;
    /**
     * Business location phone.
     * @format PHONE
     * @readonly
     */
    phone?: string | null;
}
export interface CustomLocationOptions {
    /**
     * ID of the custom location.
     * @format GUID
     * @readonly
     */
    _id?: string;
    /** Address of the custom location. */
    address?: CommonAddress;
}
/**
 * `BookingPolicy` is the main entity of `BookingPolicyService` and specifies a set of rules for booking a service
 * by visitors and members.
 *
 * Each `BookingPolicy` consists of a number of sub-policies. When the Bookings App is provisioned to a meta site then a
 * default `BookingPolicy` will be created with defaults for each of these sub-policies. This also applies when a request
 * is received to create a new `BookingPolicy` and one or more of these sub-policies are not provided.
 *
 * Sub-policies are defined in separate objects as specified below.
 *
 * - The `LimitEarlyBookingPolicy` object defines the policy for limiting early bookings.
 * - The `LimitLateBookingPolicy` object defines the policy for limiting late bookings.
 * - The `BookAfterStartPolicy` object defines the policy for booking after the start of the schedule.
 * - The `CancellationPolicy` object defines the policy for canceling a booked entity.
 * - The `ReschedulePolicy` object defines the policy for rescheduling booked entity.
 * - The `WaitlistPolicy` object defines the policy for a waitlist.
 * - The `ParticipantsPolicy` object defines the policy regarding the participants per booking.
 * - The `ResourcesPolicy` object defines the policy regarding the resources per booking.
 * - The `CancellationFeePolicy` object defines the policy regarding cancellation fees.
 * - The `SaveCreditCardPolicy` object defines the policy for saving credit card details.
 *
 * By default each sub-policy is disabled. A more detailed specification of the default settings of each sub-policy
 * can be found in the description of the corresponding object.
 *
 * Partial updates are supported on the main entity level, however in order to update a sub-policy the client needs to provide the whole sub-policy object.
 */
export interface BookingPolicy {
    /**
     * The ID to the policy for the booking.
     * @format GUID
     */
    _id?: string;
    /**
     * Date and time the policy was created.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * Date and time the policy was updated.
     * @readonly
     */
    _updatedDate?: Date | null;
    /**
     * Name of the policy.
     * @maxLength 400
     * @readonly
     */
    name?: string | null;
    /**
     * Custom description for the policy. This policy is displayed to the participant.
     * @readonly
     */
    customPolicyDescription?: PolicyDescription;
    /**
     * Whether the policy is the default for the meta site.
     * @readonly
     */
    default?: boolean | null;
    /**
     * Policy for limiting early bookings.
     * @readonly
     */
    limitEarlyBookingPolicy?: LimitEarlyBookingPolicy;
    /**
     * Policy for limiting late bookings.
     * @readonly
     */
    limitLateBookingPolicy?: LimitLateBookingPolicy;
    /**
     * Policy on booking an entity after the start of the schedule.
     * @readonly
     */
    bookAfterStartPolicy?: BookAfterStartPolicy;
    /**
     * Policy for canceling a booked entity.
     * @readonly
     */
    cancellationPolicy?: CancellationPolicy;
    /**
     * Policy for rescheduling a booked entity.
     * @readonly
     */
    reschedulePolicy?: ReschedulePolicy;
    /**
     * Waitlist policy for the service.
     * @readonly
     */
    waitlistPolicy?: WaitlistPolicy;
    /**
     * Policy regarding the participants per booking.
     * @readonly
     */
    participantsPolicy?: ParticipantsPolicy;
    /**
     * Policy for allocating resources.
     * @readonly
     */
    resourcesPolicy?: ResourcesPolicy;
    /**
     * Rules for cancellation fees.
     * @readonly
     */
    cancellationFeePolicy?: CancellationFeePolicy;
    /**
     * Rule for saving credit card.
     * @readonly
     */
    saveCreditCardPolicy?: SaveCreditCardPolicy;
}
/** A description of the policy to display to participants. */
export interface PolicyDescription {
    /**
     * Whether the description should be displayed. If `true`, the description is displayed.
     *
     * Default: `false`
     */
    enabled?: boolean;
    /**
     * The description to display.
     *
     * Default: Empty
     * Max length: 2500 characters
     * @maxLength 2500
     */
    description?: string;
}
/** The policy for limiting early bookings. */
export interface LimitEarlyBookingPolicy {
    /**
     * Whether there is a limit on how early a customer
     * can book. When `false`, there is no limit on the earliest
     * booking time and customers can book in advance, as early as they like.
     *
     * Default: `false`
     */
    enabled?: boolean;
    /**
     * Maximum number of minutes before the start of the session that a booking can be made. This value must be greater
     * than `latest_booking_in_minutes` in the `LimitLateBookingPolicy` policy.
     *
     * Default: 10080 minutes (7 days)
     * Min: 1 minute
     * @min 1
     */
    earliestBookingInMinutes?: number;
}
/**
 * The policy for limiting late bookings.
 *
 * This policy and the `BookAfterStartPolicy` policy cannot be enabled at the same time. So if this policy
 * is enabled, `BookAfterStartPolicy` must be disabled.
 */
export interface LimitLateBookingPolicy {
    /**
     * Whether there is a limit on how late a customer
     * can book. When `false`, there is no limit on the latest
     * booking time and customers can book up to the last minute.
     *
     * Default: `false`
     */
    enabled?: boolean;
    /**
     * Minimum number of minutes before the start of the session that a booking can be made.
     * For a schedule, this is relative to the start time of the next booked session, excluding past-booked sessions.
     * This value must be less than `earliest_booking_in_minutes` in the `LimitEarlyBookingPolicy` policy.
     *
     * Default: 1440 minutes (1 day)
     * Min: 1 minute
     * @min 1
     */
    latestBookingInMinutes?: number;
}
/**
 * The policy for whether a session can be booked after the start of the schedule.
 * This policy and `LimitLateBookingPolicy` cannot be enabled at the same time. So if this policy
 * is enabled, the `LimitLateBookingPolicy` policy must be disabled.
 */
export interface BookAfterStartPolicy {
    /**
     * Whether booking is allowed after the start of the schedule. When `true`,
     * customers can book after the start of the schedule.
     *
     * Default: `false`
     */
    enabled?: boolean;
}
/** The policy for canceling a booked session. */
export interface CancellationPolicy {
    /**
     * Whether canceling a booking is allowed. When `true`, customers
     * can cancel the booking.
     *
     * Default: `false`
     */
    enabled?: boolean;
    /**
     * Whether there is a limit on the latest cancellation time. When `true`,
     * a time limit is enforced.
     *
     * Default: `false`
     */
    limitLatestCancellation?: boolean;
    /**
     * Minimum number of minutes before the start of the booked session that the booking can be canceled.
     *
     * Default: 1440 minutes (1 day)
     * Min: 1 minute
     * @min 1
     */
    latestCancellationInMinutes?: number;
}
/** The policy for rescheduling a booked session. */
export interface ReschedulePolicy {
    /**
     * Whether rescheduling a booking is allowed. When `true`, customers
     * can reschedule the booking.
     *
     * Default: `false`
     */
    enabled?: boolean;
    /**
     * Whether there is a limit on the latest reschedule time. When `true`,
     * a time limit is enforced.
     *
     * Default: `false`
     */
    limitLatestReschedule?: boolean;
    /**
     * Minimum number of minutes before the start of the booked session that the booking can be rescheduled.
     *
     * Default: 1440 minutes (1 day)
     * Min: 1 minute
     * @min 1
     */
    latestRescheduleInMinutes?: number;
}
/** The policy for the waitlist. */
export interface WaitlistPolicy {
    /**
     * Whether the session has a waitlist. If `true`, there is a waitlist.
     *
     * Default: `false`
     */
    enabled?: boolean;
    /**
     * Number of spots available in the waitlist.
     *
     * Default: 10 spots
     * Min: 1 spot
     * @min 1
     */
    capacity?: number;
    /**
     * Amount of time a participant is given to book, once notified that a spot is available.
     *
     * Default: 10 minutes
     * Min: 1 spot
     * @min 1
     */
    reservationTimeInMinutes?: number;
}
/** The policy for the maximum number of participants per booking. */
export interface ParticipantsPolicy {
    /**
     * Maximum number of participants allowed.
     *
     * Default: 1 participant
     * Min: 1 participant
     * @min 1
     */
    maxParticipantsPerBooking?: number;
}
/** The policy regarding the allocation of resources (e.g. staff members). */
export interface ResourcesPolicy {
    /**
     * `true` if this policy is enabled, `false` otherwise.
     * When `false` then the client must always select a resource when booking an appointment.
     */
    enabled?: boolean;
    /**
     * `true`, if it is allowed to automatically assign a resource when booking an appointment,
     * `false`, if the client must always select a resource.
     *
     * Default: `false`
     */
    autoAssignAllowed?: boolean;
}
export interface CancellationFeePolicy {
    /**
     * Whether canceling a booking will result in a cancellation fee
     *
     * Default: `false`
     */
    enabled?: boolean;
    /**
     * Cancellation windows describing the time of cancellation and the fee to charge.
     * @maxSize 2
     */
    cancellationWindows?: CancellationWindow[];
    /**
     * Whether the cancellation fee should not be automatically collected when customer cancels the booking.
     *
     * Default: `true`
     */
    autoCollectFeeEnabled?: boolean | null;
}
export interface CancellationWindow extends CancellationWindowFeeOneOf {
    /** Amount to be charged as a cancellation fee. */
    amount?: Money;
    /**
     * Percentage of the original price to be charged as a cancellation fee.
     * @decimalValue options { gt:0, lte:100, maxScale:2 }
     */
    percentage?: string;
    /**
     * The fee will be applied if the booked session starts within this start time in minutes.
     * @min 1
     */
    startInMinutes?: number | null;
}
/** @oneof */
export interface CancellationWindowFeeOneOf {
    /** Amount to be charged as a cancellation fee. */
    amount?: Money;
    /**
     * Percentage of the original price to be charged as a cancellation fee.
     * @decimalValue options { gt:0, lte:100, maxScale:2 }
     */
    percentage?: string;
}
export interface SaveCreditCardPolicy {
    /** Default: `false` */
    enabled?: boolean;
}
export interface V2Schedule {
    /**
     * ID of the *schedule*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/calendar/schedules/introduction) | [REST](https://dev.wix.com/docs/rest/business-management/calendar/schedules-v3/introduction))
     * to which the service's events belong.
     * @format GUID
     * @readonly
     */
    _id?: string | null;
    /**
     * Start time of the first session in the schedule. For courses only.
     * @readonly
     */
    firstSessionStart?: Date | null;
    /**
     * End time of the last session in the schedule. For courses only.
     * @readonly
     */
    lastSessionEnd?: Date | null;
    /** Limitations affecting the service availability. */
    availabilityConstraints?: V2AvailabilityConstraints;
}
export interface V2AvailabilityConstraints {
    /**
     * Calculated list of all supported session durations for the service. For
     * appointment-based services without varied pricing based on session length, it
     * matches the single value in the `sessionDurations` array. For appointment-based
     * services with varied pricing based on session length, it includes session
     * durations for all *variants*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/service-options-and-variants/introduction) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/service-options-and-variants/introduction)),
     * while ignoring `sessionDurations`.
     * For courses and classes, it includes durations for all future
     * recurring sessions but excludes durations for one-off or past recurring sessions.
     * @readonly
     * @maxSize 50
     */
    durations?: Duration[];
    /**
     * List of supported session durations in minutes. Specify `sessionDurations` only
     * for appointment-based services. Do not specify it for classes or courses. Note that
     * session durations for appointment-based services with varied pricing based on
     * session length are retrieved from service *variants*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/service-options-and-variants/introduction) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/service-options-and-variants/introduction)),
     * while this array is ignored.
     *
     * Min: `1` minute
     * Max: `44639` minutes (30 days, 23 hours, and 59 minutes)
     * @min 1
     * @max 44639
     * @maxSize 50
     */
    sessionDurations?: number[];
    /**
     * The number of minutes between the end of a session and the start of the next.
     *
     *
     * Min: `0` minutes
     * Max: `720` minutes
     * @max 720
     */
    timeBetweenSessions?: number;
}
export interface Duration {
    /**
     * The duration of the service in minutes.
     *
     * Min: `1` minute
     * Max: `44639` minutes (30 days, 23 hours, and 59 minutes)
     * @min 1
     * @max 44639
     */
    minutes?: number;
}
export interface StaffMember {
    /**
     * ID of the staff member providing the service, can be used to retrieve resource information using wix-bookings-backend resources API.
     * @format GUID
     * @readonly
     */
    staffMemberId?: string;
    /**
     * Name of the staff member
     * @maxLength 40
     * @readonly
     */
    name?: string | null;
    /**
     * Main media associated with the service.
     * @readonly
     */
    mainMedia?: StaffMediaItem;
}
export interface StaffMediaItem extends StaffMediaItemItemOneOf {
    /** Details of the image associated with the staff, such as URL and size. */
    image?: string;
}
/** @oneof */
export interface StaffMediaItemItemOneOf {
    /** Details of the image associated with the staff, such as URL and size. */
    image?: string;
}
export interface StaffMemberDetails {
    /**
     * Staff members providing the service. For appointments only.
     * @maxSize 220
     */
    staffMembers?: StaffMember[];
}
export interface ResourceGroup {
    /**
     * An optional resource group ID. If specified, it references a resource group in the resource groups API.
     * TODO - referenced_entity annotation
     * @format GUID
     */
    resourceGroupId?: string | null;
    /**
     * Resource IDs. Each ID references a resource in the resources API and may be a subset of resources within a resource group.
     * TODO - referenced_entity annotation
     */
    resourceIds?: ResourceIds;
    /**
     * Specifies how many resources in the group / resource IDs are required to book the service.
     * Defaults to 1.
     * @min 1
     */
    requiredResourcesNumber?: number | null;
    /**
     * If set to `true`, the customer can select the specific resources while booking the service.
     * If set to `false`, the resources required to book the service will be auto-selected at the time of the booking.
     * Defaults to false.
     * @readonly
     */
    selectableResource?: boolean | null;
}
export interface ResourceIds {
    /**
     * Values of the resource IDs.
     * @maxSize 100
     * @format GUID
     */
    values?: string[];
}
export interface ServiceResource extends ServiceResourceSelectionOneOf {
    /**
     * Details about the required *resource type*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/resource-types/introduction) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/resources/resource-types-v2/introduction)).
     */
    resourceType?: ResourceType;
}
/** @oneof */
export interface ServiceResourceSelectionOneOf {
}
export interface ResourceType {
    /**
     * The type of the resource.
     * @format GUID
     */
    _id?: string | null;
    /**
     * The name of the resource type.
     * @readonly
     * @maxLength 40
     * @minLength 1
     */
    name?: string | null;
}
export interface Slug {
    /**
     * The unique part of service's URL that identifies the service's information page. For example, `service-1` in `https:/example.com/services/service-1`.
     * @maxLength 500
     */
    name?: string;
    /**
     * Whether the slug was generated or customized. If `true`, the slug was customized manually by the business owner. Otherwise, the slug was automatically generated from the service name.
     * @readonly
     */
    custom?: boolean | null;
    /**
     * Date and time the slug was created. This is a system field.
     * @readonly
     */
    _createdDate?: Date | null;
}
export interface URLs {
    /**
     * The URL for the service page.
     * @readonly
     */
    servicePage?: string;
    /**
     * The URL for the booking entry point. It can be either to the calendar or to the service page.
     * @readonly
     */
    bookingPage?: string;
    /**
     * The URL for the calendar. Can be empty if no calendar exists.
     * @readonly
     */
    calendarPage?: string;
}
export interface ExtendedFields {
    /**
     * Extended field data. Each key corresponds to the namespace of the app that created the extended fields.
     * The value of each key is structured according to the schema defined when the extended fields were configured.
     *
     * You can only access fields for which you have the appropriate permissions.
     *
     * Learn more about [extended fields](https://dev.wix.com/docs/rest/articles/getting-started/extended-fields).
     */
    namespaces?: Record<string, Record<string, any>>;
}
/**
 * The SEO schema object contains data about different types of meta tags. It makes sure that the information about your page is presented properly to search engines.
 * The search engines use this information for ranking purposes, or to display snippets in the search results.
 * This data will override other sources of tags (for example patterns) and will be included in the <head> section of the HTML document, while not being displayed on the page itself.
 */
export interface SeoSchema {
    /** SEO tag information. */
    tags?: Tag[];
    /** SEO general settings. */
    settings?: Settings;
}
export interface Keyword {
    /** Keyword value. */
    term?: string;
    /** Whether the keyword is the main focus keyword. */
    isMain?: boolean;
    /**
     * The source that added the keyword terms to the SEO settings.
     * @maxLength 1000
     */
    origin?: string | null;
}
export interface Tag {
    /**
     * SEO tag type.
     *
     *
     * Supported values: `title`, `meta`, `script`, `link`.
     */
    type?: string;
    /**
     * A `{"key": "value"}` pair object where each SEO tag property (`"name"`, `"content"`, `"rel"`, `"href"`) contains a value.
     * For example: `{"name": "description", "content": "the description itself"}`.
     */
    props?: Record<string, any> | null;
    /** SEO tag meta data. For example, `{"height": 300, "width": 240}`. */
    meta?: Record<string, any> | null;
    /** SEO tag inner content. For example, `<title> inner content </title>`. */
    children?: string;
    /** Whether the tag is a custom tag. */
    custom?: boolean;
    /** Whether the tag is disabled. */
    disabled?: boolean;
}
export interface Settings {
    /**
     * Whether the Auto Redirect feature, which creates `301 redirects` on a slug change, is enabled.
     *
     *
     * Default: `false` (Auto Redirect is enabled.)
     */
    preventAutoRedirect?: boolean;
    /**
     * User-selected keyword terms for a specific page.
     * @maxSize 5
     */
    keywords?: Keyword[];
}
/**
 * Message for reindexing search data to a given search schema. Support both upsert and delete flows as well as
 * performs context manipulation with adding tenant, provided in message to callscope.
 */
export interface ReindexMessage extends ReindexMessageActionOneOf {
    upsert?: Upsert;
    delete?: Delete;
    entityFqdn?: string;
    tenantId?: string;
    eventTime?: Date | null;
    entityEventSequence?: string | null;
    schema?: Schema;
}
/** @oneof */
export interface ReindexMessageActionOneOf {
    upsert?: Upsert;
    delete?: Delete;
}
export interface Upsert {
    entityId?: string;
    entityAsJson?: string;
}
export interface Delete {
    entityId?: string;
}
export interface Schema {
    label?: string;
    clusterName?: string;
}
export interface SetCustomSlugEvent {
    /** The main slug for the service after the update */
    mainSlug?: Slug;
}
export interface ServicesUrlsChanged {
}
export interface DomainEvent extends DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
    /**
     * Unique event ID.
     * Allows clients to ignore duplicate webhooks.
     */
    _id?: string;
    /**
     * Assumes actions are also always typed to an entity_type
     * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
     */
    entityFqdn?: string;
    /**
     * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
     * This is although the created/updated/deleted notion is duplication of the oneof types
     * Example: created/updated/deleted/started/completed/email_opened
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number defining the order of updates to the underlying entity.
     * For example, given that some entity was updated at 16:00 and than again at 16:01,
     * it is guaranteed that the sequence number of the second update is strictly higher than the first.
     * As the consumer, you can use this value to ensure that you handle messages in the correct order.
     * To do so, you will need to persist this number on your end, and compare the sequence number from the
     * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
     */
    entityEventSequence?: string | null;
}
/** @oneof */
export interface DomainEventBodyOneOf {
    createdEvent?: EntityCreatedEvent;
    updatedEvent?: EntityUpdatedEvent;
    deletedEvent?: EntityDeletedEvent;
    actionEvent?: ActionEvent;
}
export interface EntityCreatedEvent {
    entity?: string;
}
export interface RestoreInfo {
    deletedDate?: Date | null;
}
export interface EntityUpdatedEvent {
    /**
     * Since platformized APIs only expose PATCH and not PUT we can't assume that the fields sent from the client are the actual diff.
     * This means that to generate a list of changed fields (as opposed to sent fields) one needs to traverse both objects.
     * We don't want to impose this on all developers and so we leave this traversal to the notification recipients which need it.
     */
    currentEntity?: string;
}
export interface EntityDeletedEvent {
    /** Entity that was deleted */
    deletedEntity?: string | null;
}
export interface ActionEvent {
    body?: string;
}
export interface MessageEnvelope {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
    /** Stringify payload. */
    data?: string;
}
export interface IdentificationData extends IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
    /** @readonly */
    identityType?: WebhookIdentityType;
}
/** @oneof */
export interface IdentificationDataIdOneOf {
    /**
     * ID of a site visitor that has not logged in to the site.
     * @format GUID
     */
    anonymousVisitorId?: string;
    /**
     * ID of a site visitor that has logged in to the site.
     * @format GUID
     */
    memberId?: string;
    /**
     * ID of a Wix user (site owner, contributor, etc.).
     * @format GUID
     */
    wixUserId?: string;
    /**
     * ID of an app.
     * @format GUID
     */
    appId?: string;
}
export declare enum WebhookIdentityType {
    UNKNOWN = "UNKNOWN",
    ANONYMOUS_VISITOR = "ANONYMOUS_VISITOR",
    MEMBER = "MEMBER",
    WIX_USER = "WIX_USER",
    APP = "APP"
}
export interface CreateServiceRequest {
    /** Service to create. */
    service: Service;
}
export interface CreateServiceResponse {
    /** Created service. */
    service?: Service;
}
export interface ValidateServiceRequest {
    /** Service to validate. */
    service?: Service;
}
export interface ValidateServiceResponse {
    /** Whether the service is valid. */
    valid?: boolean;
    /** Field violations. */
    fieldViolations?: FieldViolation[];
}
export interface FieldViolation {
    /**
     * Path to the invalid field.
     * @maxLength 2000
     */
    fieldName?: string;
    /**
     * Description of the error.
     * @maxLength 2000
     */
    description?: string;
    /**
     * Rule name of the violation
     * @maxLength 2000
     */
    ruleName?: string;
}
export interface BulkCreateServicesRequest {
    /**
     * Services to create.
     * @maxSize 100
     */
    services?: Service[];
    /** Whether to return the created service objects. */
    returnEntity?: boolean;
}
export interface BulkCreateServicesResponse {
    /** The result of each service creation. */
    results?: BulkServiceResult[];
    /** Create statistics. */
    bulkActionMetadata?: BulkActionMetadata;
}
export interface BulkServiceResult {
    /** Update metadata. */
    itemMetadata?: ItemMetadata;
    /** Updated service. */
    item?: Service;
}
export interface ItemMetadata {
    /**
     * Item ID. Should always be available, unless it's impossible (for example, when failing to create an item).
     * @format GUID
     */
    _id?: string | null;
    /** Index of the item within the request array. Allows for correlation between request and response items. */
    originalIndex?: number;
    /** Whether the requested action was successful for this item. When `false`, the `error` field is populated. */
    success?: boolean;
    /** Details about the error in case of failure. */
    error?: ApplicationError;
}
export interface ApplicationError {
    /** Error code. */
    code?: string;
    /** Description of the error. */
    description?: string;
    /** Data related to the error. */
    data?: Record<string, any> | null;
}
export interface BulkActionMetadata {
    /** Number of items that were successfully processed. */
    totalSuccesses?: number;
    /** Number of items that couldn't be processed. */
    totalFailures?: number;
    /** Number of failures without details because detailed failure threshold was exceeded. */
    undetailedFailures?: number;
}
export interface GetServiceRequest {
    /**
     * ID of the service to retrieve.
     * @format GUID
     */
    serviceId: string;
}
export declare enum V2RequestedFields {
    /** Unknown requested field. */
    UNKNOWN_REQUESTED_FIELD = "UNKNOWN_REQUESTED_FIELD",
    /** When passed, `service.staff_members` is returned. */
    STAFF_MEMBER_DETAILS = "STAFF_MEMBER_DETAILS",
    /** When passed, `service.service_resources.resource_type.name` is returned. */
    RESOURCE_TYPE_DETAILS = "RESOURCE_TYPE_DETAILS"
}
export interface GetServiceResponse {
    /** Retrieved service. */
    service?: Service;
}
export interface GetServiceAvailabilityConstraintsRequest {
    /**
     * ID of the service to retrieve.
     * @format GUID
     */
    serviceId?: string;
}
export interface GetServiceAvailabilityConstraintsResponse {
    /** The retrieved availability constraints of the service. */
    constraints?: ServiceAvailabilityConstraints;
}
export interface ServiceAvailabilityConstraints {
    /**
     * The booking policy.
     * @readonly
     */
    bookingPolicy?: BookingPolicy;
    /**
     * The service schedule, including the schedule ID and availability constraints.
     * @readonly
     */
    schedule?: V2Schedule;
    /**
     * The locations this service is offered at.
     * Only multiple locations of type `BUSINESS` are supported. Multiple locations of type `CUSTOM` or `CUSTOMER` are not supported.
     * For courses only: Currently, only one location is supported for all location types.
     * Use the `Set Service Locations` method to change the locations this service is offered at.
     * @readonly
     * @maxSize 100
     */
    locations?: V2Location[];
    /**
     * Resource groups required to book the service. For backward compatibility only. Use `Service Resources` instead.
     * @maxSize 3
     * @readonly
     * @deprecated Resource groups required to book the service. For backward compatibility only. Use `Service Resources` instead.
     * @replacedBy service_resources
     * @targetRemovalDate 2024-08-19
     */
    resourceGroups?: ResourceGroup[];
    /**
     * Resource groups required to book the service.
     * @maxSize 3
     * @readonly
     */
    serviceResources?: ServiceResource[];
    /**
     * The time between available slots' start times.
     * For example, for 5-minute slots: 3:00, 3:05, 3:10 etc. For 1-hour slots: 3:00, 4:00, 5:00 etc.
     * Applied to all schedules of the site.
     * For appointments only.
     * @readonly
     */
    slotsSplitInterval?: V1SplitInterval;
    /**
     * Online booking settings.
     * @readonly
     */
    onlineBooking?: OnlineBooking;
}
/** The time between available slots' start times. For example, For 5 minute slots, 3:00, 3:05, 3:15 etc. For 1 hour slots, 3:00, 4:00, 5:00 etc. */
export interface V1SplitInterval {
    /**
     * Whether the slot duration is used as the split interval value.
     * If `same_as_duration` is `true`, the `value_in_minutes` is the sum of the first duration in
     * `schedule.availabilityConstraints.SlotDurations` field, and `schedule.availabilityConstraints.TimeBetweenSlots` field.
     */
    sameAsDuration?: boolean | null;
    /** Number of minutes between available slots' start times when `same_as_duration` is `false`. */
    valueInMinutes?: number | null;
}
export interface UpdateServiceRequest {
    /** Service to update. */
    service: Service;
}
export interface UpdateServiceResponse {
    /** Updated service. */
    service?: Service;
}
export interface BulkUpdateServicesRequest {
    /**
     * Services to update.
     * @maxSize 100
     */
    services?: MaskedService[];
    /** Whether to include the updated services in the response. Default: `false` */
    returnEntity?: boolean;
}
export interface MaskedService {
    /** Service to update. */
    service?: Service;
    /** Explicit list of fields to update. */
    mask?: string[];
}
export interface BulkUpdateServicesResponse {
    /** The result of each service update. */
    results?: BulkServiceResult[];
    /** Update statistics. */
    bulkActionMetadata?: BulkActionMetadata;
}
export interface BulkUpdateServicesByFilterRequest {
    /** Filter to identify the services to update. */
    filter: Record<string, any> | null;
    /** Service to update. */
    service: Service;
}
export interface BulkUpdateServicesByFilterResponse {
    /**
     * ID of the service update job.
     *
     * Pass this ID to [Get Async Job](https://dev.wix.com/docs/rest/business-management/async-job/introduction) to retrieve job details and metadata.
     * @format GUID
     */
    jobId?: string;
}
export interface DeleteServiceRequest {
    /**
     * ID of the service to delete.
     * @format GUID
     */
    serviceId: string;
    /**
     * Whether to preserve future sessions with participants.
     *
     * Default: `false`
     */
    preserveFutureSessionsWithParticipants?: boolean;
    /**
     * Whether to notify participants about the change and an optional
     * custom message.
     */
    participantNotification?: V2ParticipantNotification;
}
export interface V2ParticipantNotification {
    /**
     * Whether to send the message about the changes to the customer.
     *
     * Default: `false`
     */
    notifyParticipants?: boolean | null;
    /**
     * Custom message to send to the participants about the changes to the booking.
     * @maxLength 2000
     */
    message?: string | null;
}
export interface DeleteServiceResponse {
}
export interface BulkDeleteServicesRequest {
    /**
     * IDs of the services to delete.
     * @format GUID
     * @maxSize 100
     */
    ids: string[];
    /**
     * Whether to preserve future sessions with participants.
     *
     * Default: `false`.
     */
    preserveFutureSessionsWithParticipants?: boolean;
    /**
     * Whether to notify participants about the change and an optional
     * custom message.
     */
    participantNotification?: V2ParticipantNotification;
}
export interface BulkDeleteServicesResponse {
    /** The result of each service removal. */
    results?: BulkServiceResult[];
    /** Delete statistics. */
    bulkActionMetadata?: BulkActionMetadata;
}
export interface BulkDeleteServicesByFilterRequest {
    /** Filter to identify the services that need to be deleted. */
    filter: Record<string, any> | null;
    /**
     * Whether to preserve future sessions with participants.
     *
     * Default: `false`.
     */
    preserveFutureSessionsWithParticipants?: boolean;
    /** Whether to notify participants about the change and an optional custom message. */
    participantNotification?: V2ParticipantNotification;
}
export interface BulkDeleteServicesByFilterResponse {
    /**
     * ID of the service deletion job.
     *
     * Pass this ID to [Get Async Job](https://dev.wix.com/docs/rest/business-management/async-job/introduction) to retrieve job details and metadata.
     * @format GUID
     */
    jobId?: string;
}
export interface QueryServicesRequest {
    /** WQL expression. */
    query: QueryV2;
}
export interface QueryV2 extends QueryV2PagingMethodOneOf {
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
    /**
     * Filter object in the following format:
     *
     * `"filter" : {
     * "fieldName1": "value1",
     * "fieldName2":{"$operator":"value2"}
     * }`
     *
     * Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`
     *
     * Read more about [supported fields and operators](https://dev.wix.com/api/rest/wix-bookings/services-v2/filtering-and-sorting).
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object in the following format:
     * `[ {"fieldName":"sortField1","order":"ASC"},
     * {"fieldName":"sortField2","order":"DESC"} ]`
     *
     * Read more about [sorting](https://dev.wix.com/api/rest/wix-bookings/services-v2/filtering-and-sorting#wix-bookings_services-v2_filtering-and-sorting_sorting).
     * @maxSize 50
     */
    sort?: Sorting[];
}
/** @oneof */
export interface QueryV2PagingMethodOneOf {
    /** Paging options to limit and skip the number of items. */
    paging?: Paging;
}
export interface Sorting {
    /**
     * Name of the field to sort by.
     * @maxLength 512
     */
    fieldName?: string;
    /** Sort order. */
    order?: SortOrder;
}
export declare enum SortOrder {
    ASC = "ASC",
    DESC = "DESC"
}
export interface Paging {
    /** Number of items to load. */
    limit?: number | null;
    /** Number of items to skip in the current sort order. */
    offset?: number | null;
}
export interface CursorPaging {
    /**
     * Number of items to load.
     * @max 100
     */
    limit?: number | null;
    /**
     * Pointer to the next or previous page in the list of results.
     *
     * You can get the relevant cursor token
     * from the `pagingMetadata` object in the previous call's response.
     * Not relevant for the first request.
     * @maxLength 16000
     */
    cursor?: string | null;
}
export interface QueryServicesResponse {
    /** The retrieved services. */
    services?: Service[];
    /** Paging metadata, including offset and count. */
    pagingMetadata?: PagingMetadataV2;
}
export interface PagingMetadataV2 {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Offset that was requested. */
    offset?: number | null;
    /** Total number of items that match the query. Returned if offset paging is used and the `tooManyToCount` flag is not set. */
    total?: number | null;
    /** Flag that indicates the server failed to calculate the `total` field. */
    tooManyToCount?: boolean | null;
    /** Cursors to navigate through the result pages using `next` and `prev`. Returned if cursor paging is used. */
    cursors?: Cursors;
}
export interface Cursors {
    /**
     * Cursor pointing to next page in the list of results.
     * @maxLength 16000
     */
    next?: string | null;
    /**
     * Cursor pointing to previous page in the list of results.
     * @maxLength 16000
     */
    prev?: string | null;
}
export interface SearchServicesRequest {
    /** WQL, search or aggregation expression. */
    search: CursorSearch;
}
export interface CursorSearch extends CursorSearchPagingMethodOneOf {
    /**
     * Cursor pointing to page of results.
     * When requesting 'cursor_paging.cursor', no `filter`, `sort` or `search` can be provided.
     */
    cursorPaging?: CursorPaging;
    /** A filter object. See documentation [here](https://bo.wix.com/wix-docs/rnd/platformization-guidelines/api-query-language#platformization-guidelines_api-query-language_defining-in-protobuf) */
    filter?: Record<string, any> | null;
    /**
     * Sort object in the form [{"fieldName":"sortField1"},{"fieldName":"sortField2","direction":"DESC"}]
     * @maxSize 10
     */
    sort?: Sorting[];
    /**
     * Aggregations | Faceted search: refers to a way to explore large amounts of data by displaying summaries about various partitions of the data and later allowing to narrow the navigation to a specific partition.
     * @maxSize 10
     */
    aggregations?: Aggregation[];
    /** Free text to match in searchable fields */
    search?: SearchDetails;
    /**
     * UTC offset or IANA time zone. Valid values are
     * ISO 8601 UTC offsets, such as +02:00 or -06:00,
     * and IANA time zone IDs, such as Europe/Rome
     *
     * Affects all filters and aggregations returned values.
     * You may override this behavior in a specific filter by providing
     * timestamps including time zone. e.g. `"2023-12-20T10:52:34.795Z"`
     * @maxLength 50
     */
    timeZone?: string | null;
}
/** @oneof */
export interface CursorSearchPagingMethodOneOf {
    /**
     * Cursor pointing to page of results.
     * When requesting 'cursor_paging.cursor', no `filter`, `sort` or `search` can be provided.
     */
    cursorPaging?: CursorPaging;
}
export interface Aggregation extends AggregationKindOneOf {
    /** Value aggregation */
    value?: ValueAggregation;
    /** Range aggregation */
    range?: RangeAggregation;
    /** Scalar aggregation */
    scalar?: ScalarAggregation;
    /** Date histogram aggregation */
    dateHistogram?: DateHistogramAggregation;
    /** Nested aggregation */
    nested?: NestedAggregation;
    /**
     * User-defined name of aggregation, should be unique, will appear in aggregation results
     * @maxLength 100
     */
    name?: string | null;
    /** Type of aggregation, client must provide matching aggregation field below */
    type?: AggregationType;
    /**
     * Field to aggregate by, use dot notation to specify json path
     * @maxLength 200
     */
    fieldPath?: string;
    /**
     * deprecated, use `nested` instead
     * @deprecated deprecated, use `nested` instead
     * @replacedBy kind.nested
     * @targetRemovalDate 2025-01-01
     */
    groupBy?: GroupByAggregation;
}
/** @oneof */
export interface AggregationKindOneOf {
    /** Value aggregation */
    value?: ValueAggregation;
    /** Range aggregation */
    range?: RangeAggregation;
    /** Scalar aggregation */
    scalar?: ScalarAggregation;
    /** Date histogram aggregation */
    dateHistogram?: DateHistogramAggregation;
    /** Nested aggregation */
    nested?: NestedAggregation;
}
export interface RangeBucket {
    /** Inclusive lower bound of the range. Required if to is not given. */
    from?: number | null;
    /** Exclusive upper bound of the range. Required if from is not given. */
    to?: number | null;
}
export declare enum SortType {
    COUNT = "COUNT",
    VALUE = "VALUE"
}
export declare enum SortDirection {
    DESC = "DESC",
    ASC = "ASC"
}
export declare enum MissingValues {
    EXCLUDE = "EXCLUDE",
    INCLUDE = "INCLUDE"
}
export interface IncludeMissingValuesOptions {
    /**
     * can specify custom bucket name. Defaults are [string -> "N/A"], [int -> "0"], [bool -> "false"] ...
     * @maxLength 20
     */
    addToBucket?: string;
}
export declare enum ScalarType {
    UNKNOWN_SCALAR_TYPE = "UNKNOWN_SCALAR_TYPE",
    COUNT_DISTINCT = "COUNT_DISTINCT",
    MIN = "MIN",
    MAX = "MAX"
}
export interface ValueAggregation extends ValueAggregationOptionsOneOf {
    /** options for including missing values */
    includeOptions?: IncludeMissingValuesOptions;
    /** Should sort by number of matches or value of the field */
    sortType?: SortType;
    /** Should sort in ascending or descending order */
    sortDirection?: SortDirection;
    /** How many aggregations would you like to return? Can be between 1 and 250. 10 is the default. */
    limit?: number | null;
    /** should missing values be included or excluded from the aggregation results. Default is EXCLUDE */
    missingValues?: MissingValues;
}
/** @oneof */
export interface ValueAggregationOptionsOneOf {
    /** options for including missing values */
    includeOptions?: IncludeMissingValuesOptions;
}
export declare enum NestedAggregationType {
    UNKNOWN_AGGREGATION_TYPE = "UNKNOWN_AGGREGATION_TYPE",
    VALUE = "VALUE",
    RANGE = "RANGE",
    SCALAR = "SCALAR",
    DATE_HISTOGRAM = "DATE_HISTOGRAM"
}
export interface RangeAggregation {
    /**
     * Range buckets
     * @maxSize 50
     */
    buckets?: RangeBucket[];
}
export interface ScalarAggregation {
    /** Define the operator for the scalar aggregation */
    type?: ScalarType;
}
export interface DateHistogramAggregation {
    /** Interval for date histogram aggregation */
    interval?: DateHistogramAggregationInterval;
}
export declare enum DateHistogramAggregationInterval {
    /** Unknown interval. */
    UNKNOWN_INTERVAL = "UNKNOWN_INTERVAL",
    /** Yearly interval. */
    YEAR = "YEAR",
    /** Monthly interval. */
    MONTH = "MONTH",
    /** Weekly interval. */
    WEEK = "WEEK",
    /** Daily interval. */
    DAY = "DAY",
    /** Hourly interval. */
    HOUR = "HOUR",
    /** Minute interval. */
    MINUTE = "MINUTE",
    /** Second interval. */
    SECOND = "SECOND"
}
export interface NestedAggregationItem extends NestedAggregationItemKindOneOf {
    /** Value aggregation */
    value?: ValueAggregation;
    /** Range aggregation */
    range?: RangeAggregation;
    /** Scalar aggregation */
    scalar?: ScalarAggregation;
    /** Date histogram aggregation */
    dateHistogram?: DateHistogramAggregation;
    /**
     * User-defined name of aggregation, should be unique, will appear in aggregation results
     * @maxLength 100
     */
    name?: string | null;
    /** Type of aggregation, client must provide matching aggregation field below */
    type?: NestedAggregationType;
    /**
     * Field to aggregate by, use dont notation to specify json path
     * @maxLength 200
     */
    fieldPath?: string;
}
/** @oneof */
export interface NestedAggregationItemKindOneOf {
    /** Value aggregation */
    value?: ValueAggregation;
    /** Range aggregation */
    range?: RangeAggregation;
    /** Scalar aggregation */
    scalar?: ScalarAggregation;
    /** Date histogram aggregation */
    dateHistogram?: DateHistogramAggregation;
}
export declare enum AggregationType {
    UNKNOWN_AGGREGATION_TYPE = "UNKNOWN_AGGREGATION_TYPE",
    VALUE = "VALUE",
    RANGE = "RANGE",
    SCALAR = "SCALAR",
    DATE_HISTOGRAM = "DATE_HISTOGRAM",
    NESTED = "NESTED"
}
/** nested aggregation expressed through a list of aggregation where each next aggregation is nested within previous one */
export interface NestedAggregation {
    /**
     * Flattened list of aggregations, where each next aggregation is nested within previous one
     * @minSize 2
     * @maxSize 10
     */
    nestedAggregations?: NestedAggregationItem[];
}
export interface GroupByAggregation extends GroupByAggregationKindOneOf {
    /** Value aggregation configuration */
    value?: ValueAggregation;
    /**
     * User-defined name of aggregation, should be unique, will appear in aggregation results
     * @maxLength 100
     */
    name?: string | null;
    /**
     * Field to aggregate by
     * @maxLength 200
     */
    fieldPath?: string;
}
/** @oneof */
export interface GroupByAggregationKindOneOf {
    /** Value aggregation configuration */
    value?: ValueAggregation;
}
export interface SearchDetails {
    /** Boolean search mode */
    mode?: Mode;
    /**
     * Search term or expression
     * @maxLength 200
     */
    expression?: string | null;
    /**
     * Fields to search in. If empty - server will search in own default fields
     * @maxSize 10
     * @maxLength 200
     */
    fields?: string[];
    /** Flag if should use auto fuzzy search (allowing typos by a managed proximity algorithm) */
    fuzzy?: boolean;
}
export declare enum Mode {
    /** Any */
    OR = "OR",
    /** All */
    AND = "AND"
}
export interface SearchServicesResponse {
    /** The retrieved services. */
    services?: Service[];
    /** Cursor paging metadata */
    pagingMetadata?: CursorPagingMetadata;
    /** Response aggregation data */
    aggregationData?: AggregationData;
}
export interface CursorPagingMetadata {
    /** Number of items returned in the response. */
    count?: number | null;
    /** Use these cursor to paginate between results. [Read more](https://dev.wix.com/api/rest/getting-started/api-query-language#getting-started_api-query-language_cursor-paging). */
    cursors?: Cursors;
    /**
     * Indicates if there are more results after the current page.
     * If `true`, another page of results can be retrieved.
     * If `false`, this is the last page.
     */
    hasNext?: boolean | null;
}
export interface AggregationData {
    /**
     * key = aggregation name (as derived from search request)
     * @maxSize 10000
     */
    results?: AggregationResults[];
}
export interface ValueAggregationResult {
    /**
     * Value of the field
     * @maxLength 100
     */
    value?: string;
    /** Count of entities with this value */
    count?: number;
}
export interface RangeAggregationResult {
    /** Inclusive lower bound of the range */
    from?: number | null;
    /** Exclusive upper bound of the range */
    to?: number | null;
    /** Count of entities in this range */
    count?: number;
}
export interface NestedAggregationResults extends NestedAggregationResultsResultOneOf {
    /** Value aggregation results */
    values?: ValueResults;
    /** Range aggregation results */
    ranges?: RangeResults;
    /** Scalar aggregation results */
    scalar?: AggregationResultsScalarResult;
    /**
     * User-defined name of aggregation, matches the one provided in request
     * @maxLength 100
     */
    name?: string;
    /** Type of aggregation that matches result */
    type?: AggregationType;
    /**
     * Field to aggregate by, matches the one provided in request
     * @maxLength 200
     */
    fieldPath?: string;
}
/** @oneof */
export interface NestedAggregationResultsResultOneOf {
    /** Value aggregation results */
    values?: ValueResults;
    /** Range aggregation results */
    ranges?: RangeResults;
    /** Scalar aggregation results */
    scalar?: AggregationResultsScalarResult;
}
export interface ValueResults {
    /**
     * List of value aggregations
     * @maxSize 250
     */
    results?: ValueAggregationResult[];
}
export interface RangeResults {
    /**
     * List of ranges returned in same order as requested
     * @maxSize 50
     */
    results?: RangeAggregationResult[];
}
export interface AggregationResultsScalarResult {
    /** Type of scalar aggregation */
    type?: ScalarType;
    /** Value of the scalar aggregation */
    value?: number;
}
export interface NestedValueAggregationResult {
    /**
     * Value of the field
     * @maxLength 1000
     */
    value?: string;
    /** Nested aggregations */
    nestedResults?: NestedAggregationResults;
}
export interface ValueResult {
    /**
     * Value of the field
     * @maxLength 1000
     */
    value?: string;
    /** Count of entities with this value */
    count?: number | null;
}
export interface RangeResult {
    /** Inclusive lower bound of the range */
    from?: number | null;
    /** Exclusive upper bound of the range */
    to?: number | null;
    /** Count of entities in this range */
    count?: number | null;
}
export interface ScalarResult {
    /** Value of the scalar aggregation */
    value?: number;
}
export interface NestedResultValue extends NestedResultValueResultOneOf {
    /** Value aggregation result */
    value?: ValueResult;
    /** Range aggregation result */
    range?: RangeResult;
    /** Scalar aggregation result */
    scalar?: ScalarResult;
    /** Date histogram aggregation result */
    dateHistogram?: ValueResult;
}
/** @oneof */
export interface NestedResultValueResultOneOf {
    /** Value aggregation result */
    value?: ValueResult;
    /** Range aggregation result */
    range?: RangeResult;
    /** Scalar aggregation result */
    scalar?: ScalarResult;
    /** Date histogram aggregation result */
    dateHistogram?: ValueResult;
}
export interface Results {
    /** List of nested aggregations */
    results?: Record<string, NestedResultValue>;
}
export interface DateHistogramResult {
    /**
     * Date in ISO 8601 format
     * @maxLength 100
     */
    value?: string;
    /** Count of documents in the bucket */
    count?: number;
}
export interface GroupByValueResults {
    /**
     * List of value aggregations
     * @maxSize 1000
     */
    results?: NestedValueAggregationResult[];
}
export interface DateHistogramResults {
    /**
     * List of date histogram aggregations
     * @maxSize 200
     */
    results?: DateHistogramResult[];
}
/**
 * results of `NESTED` aggregation type in a flattened form
 * aggregations in resulting array are keyed by requested aggregation `name`.
 */
export interface NestedResults {
    /**
     * List of nested aggregations
     * @maxSize 1000
     */
    results?: Results[];
}
export interface AggregationResults extends AggregationResultsResultOneOf {
    /** Value aggregation results */
    values?: ValueResults;
    /** Range aggregation results */
    ranges?: RangeResults;
    /** Scalar aggregation results */
    scalar?: AggregationResultsScalarResult;
    /** Group by value aggregation results */
    groupedByValue?: GroupByValueResults;
    /** Date histogram aggregation results */
    dateHistogram?: DateHistogramResults;
    /** Nested aggregation results */
    nested?: NestedResults;
    /**
     * User-defined name of aggregation as derived from search request
     * @maxLength 100
     */
    name?: string;
    /** Type of aggregation that must match provided kind as derived from search request */
    type?: AggregationType;
    /**
     * Field to aggregate by as derived from search request
     * @maxLength 200
     */
    fieldPath?: string;
}
/** @oneof */
export interface AggregationResultsResultOneOf {
    /** Value aggregation results */
    values?: ValueResults;
    /** Range aggregation results */
    ranges?: RangeResults;
    /** Scalar aggregation results */
    scalar?: AggregationResultsScalarResult;
    /** Group by value aggregation results */
    groupedByValue?: GroupByValueResults;
    /** Date histogram aggregation results */
    dateHistogram?: DateHistogramResults;
    /** Nested aggregation results */
    nested?: NestedResults;
}
export interface QueryPoliciesRequest {
    /**
     * Information about filters, paging, and sorting. See the article about
     * booking policy filters
     * ([REST](https://dev.wix.com/docs/rest/business-solutions/bookings/policies/booking-policies/supported-filters))
     * for all supported filters and sorting options.
     */
    query: CursorQuery;
}
export interface CursorQuery extends CursorQueryPagingMethodOneOf {
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
    /**
     * Filter object in the following format:
     * `"filter" : {
     * "fieldName1": "value1",
     * "fieldName2":{"$operator":"value2"}
     * }`
     * Example of operators: `$eq`, `$ne`, `$lt`, `$lte`, `$gt`, `$gte`, `$in`, `$hasSome`, `$hasAll`, `$startsWith`
     */
    filter?: Record<string, any> | null;
    /**
     * Sort object in the following format:
     * `[{"fieldName":"sortField1","order":"ASC"},{"fieldName":"sortField2","order":"DESC"}]`
     * @maxSize 50
     */
    sort?: Sorting[];
}
/** @oneof */
export interface CursorQueryPagingMethodOneOf {
    /** Cursor token pointing to a page of results. Not used in the first request. Following requests use the cursor token and not `filter` or `sort`. */
    cursorPaging?: CursorPaging;
}
export interface QueryPoliciesResponse {
    /** Retrieved booking policies and information about the services using them. */
    bookingPolicies?: BookingPolicyWithServices[];
    /** Paging metadata. */
    pagingMetadata?: CursorPagingMetadata;
}
export interface BookingPolicyWithServices {
    /** Retrieved booking policy. */
    bookingPolicy?: BookingPolicy;
    /**
     * Up to 5 services connected to the booking policy. If `totalServiceCount` is
     * greater than 5, there are additional services connected to the policy.
     * You can call *Search Services*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/services/search-services) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/services-v2/search-services))
     * specifying the relevant policy ID in the filter, to retrieve all services that are
     * connected to a booking policy.
     * @maxSize 5
     */
    connectedServices?: Service[];
    /** Total number of services connected to the booking policy. */
    totalServiceCount?: number;
}
export interface QueryBookingFormsRequest {
    /**
     * Information about filters, paging, and sorting. See the article about
     * form filters ([REST](https://dev.wix.com/docs/rest/crm/forms/forms/introduction/supported-filters))
     * for all supported filters and sorting options.
     */
    query: CursorQuery;
    /**
     * Conditional fields to return.
     * @maxSize 1
     */
    conditionalFields?: RequestedFields[];
}
export declare enum RequestedFields {
    /** Unknown requested conditional field. */
    UNKNOWN_REQUESTED_FIELD = "UNKNOWN_REQUESTED_FIELD",
    /** Whether to return the site's default booking form. */
    DEFAULT_BOOKING_FORM = "DEFAULT_BOOKING_FORM"
}
export interface QueryBookingFormsResponse {
    /** Retrieved booking forms and information about connected services. */
    bookingForms?: BookingForm[];
    /** Paging metadata. */
    pagingMetadata?: CursorPagingMetadata;
    /** The site's default booking form and information about connected services. */
    defaultBookingForm?: BookingForm;
}
export interface BookingForm {
    /** Information about the retrieved booking form. */
    formDetails?: FormDetails;
    /**
     * Up to 5 services connected to the booking form. If `totalServiceCount` is
     * greater than 5, there are additional services connected to the policy.
     * You can call *Search Services*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/services/search-services) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/services-v2/search-services))
     * specifying the relevant policy ID in the filter, to retrieve all services that are
     * connected to a booking policy.
     * @maxSize 5
     */
    connectedServices?: ConnectedService[];
    /** Total number of services connected to the booking form. */
    totalServiceCount?: number;
}
export interface FormDetails {
    /**
     * Form ID.
     * @format GUID
     */
    formId?: string;
    /**
     * Form name.
     * @maxLength 200
     */
    name?: string | null;
    /**
     * Revision number, which increments by 1 each time the form is updated.
     * To prevent conflicting changes,
     * the current revision must be passed when updating the form.
     * @readonly
     */
    revision?: string | null;
}
export interface ConnectedService {
    /**
     * ID of the service connected to the booking form.
     * @format GUID
     */
    _id?: string | null;
    /**
     * Name of the service connected to the booking form.
     * @maxLength 400
     * @minLength 1
     */
    name?: string | null;
}
export interface CountServicesRequest {
    /**
     * Query filter to base the count on. See supported filters
     * ([REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/services-v2/filtering-and-sorting#filtering))
     * for more details.
     */
    filter?: Record<string, any> | null;
}
export interface CountServicesResponse {
    /** Number of services matching the specified filter. */
    count?: number;
}
export interface QueryLocationsRequest {
    /** Filter. */
    filter?: QueryLocationsFilter;
}
export interface QueryLocationsFilter {
    /**
     * Service filter. See supported filters
     * ([REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/services-v2/filtering-and-sorting#filtering))
     * for more details.
     */
    services?: Record<string, any> | null;
    /**
     * List of business IDs to filter by.
     * @format GUID
     * @maxSize 100
     */
    businessLocationIds?: string[];
}
export interface QueryLocationsResponse {
    /**
     * Retrieved business locations and whether each location is connected to at
     * least one service.
     */
    businessLocations?: BusinessLocations;
    /**
     * Retrieved custom locations and whether each location is connected to at
     * least one service.
     */
    customLocations?: CustomLocations;
    /**
     * Retrieved customer locations and whether each location is connected to at
     * least one service.
     */
    customerLocations?: CustomerLocations;
}
export interface BusinessLocations {
    /**
     * Whether at least one service matching the filter is connected to any of the
     * retrieved business locations.
     */
    exists?: boolean;
    /**
     * Retrieved business locations.
     * @maxSize 100
     */
    locations?: V2Location[];
}
export interface CustomLocations {
    /**
     * Whether at least one service matching the filter is connected to any of the
     * retrieved custom locations.
     */
    exists?: boolean;
}
export interface CustomerLocations {
    /**
     * Whether at least one service matching the filter is connected to any of the
     * retrieved customer locations.
     */
    exists?: boolean;
}
export interface QueryCategoriesRequest {
    /** Filter. */
    filter?: QueryCategoriesFilter;
}
export interface QueryCategoriesFilter {
    /**
     * Service filter. See supported filters
     * ([REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/services-v2/filtering-and-sorting#filtering))
     * for more details.
     */
    services?: Record<string, any> | null;
    /**
     * List of category IDs to filter by.
     * @format GUID
     * @maxSize 100
     */
    categoryIds?: string[];
}
export interface QueryCategoriesResponse {
    /** Retrieved categories. */
    categories?: V2Category[];
}
export interface QueryServicesMultiLanguageRequest {
    /** WQL expression. */
    query?: QueryV2;
}
export interface QueryServicesMultiLanguageResponse {
    /** The retrieved services in the main language */
    services?: Service[];
    /**
     * the retrieved services in the requested language according to the
     * provided linguist aspect
     */
    translatedServices?: Service[];
    /** Paging metadata, including offset and count. */
    pagingMetadata?: PagingMetadataV2;
}
export interface SetServiceLocationsRequest {
    /**
     * ID of the service.
     * @format GUID
     */
    serviceId: string;
    /**
     * List of locations replacing existing service locations. Omitting an existing location removes it from the service. Specify `removedLocationSessionsAction` to determine the handling of future sessions scheduled at that location.
     * @maxSize 100
     */
    locations: V2Location[];
    /**
     * The action to perform on sessions currently set to a removed location. For
     * example, move existing sessions to a new specified location.
     * If not specified, sessions will not be moved to a new location.
     */
    removedLocationSessionsAction?: RemovedLocationSessionsAction;
    /**
     * Whether to notify participants about the change of location, and an
     * Optional custom message. The notification is sent only to participants of sessions that are affected by the change.
     */
    participantNotification?: V2ParticipantNotification;
}
export interface RemovedLocationSessionsAction extends RemovedLocationSessionsActionActionOptionsOneOf {
    /**
     * Details about the new location of future events that were scheduled to take
     * place at a removed location.
     */
    moveToLocationOptions?: MoveToNewLocationsOptions;
    /** Information about what to do with future events at the removed location. */
    action?: Action;
}
/** @oneof */
export interface RemovedLocationSessionsActionActionOptionsOneOf {
    /**
     * Details about the new location of future events that were scheduled to take
     * place at a removed location.
     */
    moveToLocationOptions?: MoveToNewLocationsOptions;
}
export declare enum Action {
    UNKNOWN_ACTION_TYPE = "UNKNOWN_ACTION_TYPE",
    /** Retain all future sessions at their current location. This is the default. */
    KEEP_AT_CURRENT_LOCATION = "KEEP_AT_CURRENT_LOCATION",
    /** Move future events to a new location. */
    MOVE_TO_LOCATION = "MOVE_TO_LOCATION",
    /**
     * Cancel all future events at the removed location.
     * Currently not supported.
     */
    DELETE = "DELETE"
}
export interface MoveToNewLocationsOptions {
    /** The new location to move existing sessions currently set to a removed location, used when `action` is `MOVE_TO_LOCATION`. */
    newLocation?: V2Location;
}
export interface SetServiceLocationsResponse {
    /** The updated service with the newly set locations. */
    service?: Service;
}
export interface EnablePricingPlansForServiceRequest {
    /**
     * ID of the service to update.
     * @format GUID
     */
    serviceId: string;
    /**
     * IDs of the *pricing plans*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/pricing-plans/plans/introduction) | [REST](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/plans/plan-object))
     * to add to the service's `payment.pricingPlanIds` array.
     * @format GUID
     * @maxSize 100
     */
    pricingPlanIds: string[];
}
export interface EnablePricingPlansForServiceResponse {
    /** Updated service. */
    service?: Service;
}
export interface InvalidPricingPlan {
    /**
     * ID of the invalid pricing plan.
     * @format GUID
     */
    _id?: string;
    /**
     * Explanation why the pricing plan is considered invalid.
     * @maxLength 2000
     */
    message?: string;
}
export interface DisablePricingPlansForServiceRequest {
    /**
     * ID of the service to update.
     * @format GUID
     */
    serviceId: string;
    /**
     * IDs of the *pricing plans*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/pricing-plans/plans/introduction) | [REST](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/plans/plan-object))
     * to remove from the service's `payment.pricingPlanIds` array.
     * @format GUID
     * @maxSize 75
     */
    pricingPlanIds?: string[];
}
export interface DisablePricingPlansForServiceResponse {
    /** Updated service. */
    service?: Service;
}
export interface SetCustomSlugRequest {
    /**
     * ID of the service for which to update the active slug.
     * @format GUID
     */
    serviceId: string;
    /**
     * Slug to set as the active service slug.
     * @maxLength 500
     */
    slug?: string;
}
export interface SetCustomSlugResponse {
    /** Updated active service slug. */
    slug?: Slug;
    /** Updated service. */
    service?: Service;
}
export interface ValidateSlugRequest {
    /**
     * IO of the service to check custom slug validity for.
     * @format GUID
     */
    serviceId: string;
    /**
     * Custom slug to validate.
     * @maxLength 500
     */
    slug?: string;
}
export interface ValidateSlugResponse {
    /** Whether the slug is valid. */
    valid?: boolean;
    /**
     * Valid slug. Available only if `{"valid": true}`.
     * @maxLength 500
     */
    slug?: string | null;
    /**
     * Reasons why the slug is invalid. Available only if `{"valid": false}`.
     * @maxSize 3
     */
    errors?: InvalidSlugError[];
}
export declare enum InvalidSlugError {
    /** Unknown slug error. */
    UNKNOWN_SLUG_ERROR = "UNKNOWN_SLUG_ERROR",
    /** Slug contains illegal characters. */
    SLUG_CONTAINS_ILLEGAL_CHARACTERS = "SLUG_CONTAINS_ILLEGAL_CHARACTERS",
    /** Slug is already associated with another service. */
    SLUG_ALREADY_EXISTS = "SLUG_ALREADY_EXISTS"
}
export interface CloneServiceRequest {
    /**
     * ID of the service to clone.
     * @format GUID
     */
    sourceServiceId: string;
}
export interface CloneServiceResponse {
    /** Cloned service. */
    service?: Service;
    /**
     * Information about connected entities that couldn't be cloned. For example,
     * future recurring events, the booking form, service variants, and connected
     * pricing plans.
     */
    errors?: CloneErrors[];
}
export declare enum CloneErrors {
    /**
     * Failed to clone the original service's *options and variants*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/service-options-and-variants/introduction) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/service-options-and-variants/introduction)).
     */
    OPTIONS_AND_VARIANTS = "OPTIONS_AND_VARIANTS",
    /** Failed to clone the original service's *booking form*. */
    FORM = "FORM"
}
/** An event sent every time a category entity is changed. */
export interface CategoryNotification {
    category?: Category;
    event?: CategoryNotificationEvent;
}
/** Categories are used to group multiple services together. A service must be associated with a category in order to be exposed in the Wix Bookings UI. */
export interface Category {
    /**
     * Category ID.
     * @format GUID
     * @readonly
     */
    _id?: string | null;
    /**
     * Category name.
     * @maxLength 500
     */
    name?: string | null;
    /**
     * Category status.
     *
     * Default: `CREATED`
     * @readonly
     */
    status?: CategoryStatus;
    /** Sort order of the category in the live site and dashboard. */
    sortOrder?: number | null;
}
export declare enum CategoryStatus {
    /** The category was created. */
    CREATED = "CREATED",
    /** The category was deleted. */
    DELETED = "DELETED"
}
export declare enum CategoryNotificationEvent {
    /** Category was updated. */
    Updated = "Updated",
    /** Category was deleted. */
    Deleted = "Deleted",
    /** Category was created. */
    Created = "Created"
}
export interface Empty {
}
export interface ScheduleNotification extends ScheduleNotificationEventOneOf {
    scheduleCreated?: ScheduleCreated;
    scheduleUpdated?: ScheduleUpdated;
    scheduleCancelled?: ScheduleCancelled;
    sessionCreated?: SessionCreated;
    sessionUpdated?: SessionUpdated;
    sessionCancelled?: SessionCancelled;
    availabilityPolicyUpdated?: AvailabilityPolicyUpdated;
    /** @deprecated */
    intervalSplit?: IntervalSplit;
    recurringSessionSplit?: RecurringSessionSplit;
    /**
     * Inspect `schedule.scheduleOwnerUserId` on `scheduleUpdated` instead.
     * @deprecated
     */
    scheduleUnassignedFromUser?: ScheduleUnassignedFromUser;
    preserveFutureSessionsWithParticipants?: boolean | null;
    /**
     * Whether to notify participants about changed sessions. deprecated, use participant_notification
     * @deprecated
     */
    notifyParticipants?: boolean;
    /** site properties. Optional. Given in create schedule notification. */
    siteProperties?: SitePropertiesOnScheduleCreation;
    instanceId?: string;
}
/** @oneof */
export interface ScheduleNotificationEventOneOf {
    scheduleCreated?: ScheduleCreated;
    scheduleUpdated?: ScheduleUpdated;
    scheduleCancelled?: ScheduleCancelled;
    sessionCreated?: SessionCreated;
    sessionUpdated?: SessionUpdated;
    sessionCancelled?: SessionCancelled;
    availabilityPolicyUpdated?: AvailabilityPolicyUpdated;
    /** @deprecated */
    intervalSplit?: IntervalSplit;
    recurringSessionSplit?: RecurringSessionSplit;
    /**
     * Inspect `schedule.scheduleOwnerUserId` on `scheduleUpdated` instead.
     * @deprecated
     */
    scheduleUnassignedFromUser?: ScheduleUnassignedFromUser;
}
export interface ScheduleCreated {
    schedule?: Schedule;
}
export interface Schedule {
    /** Schedule ID. */
    _id?: string;
    /** ID of the schedule's owner entity. This may be a resource ID or a service ID. */
    scheduleOwnerId?: string | null;
    /**
     * Schedule's time zone in [Area/Location](https://en.wikipedia.org/wiki/Tz_database) format. Read-only.
     * Derived from the Wix Business time zone.
     * @readonly
     */
    timeZone?: string | null;
    /**
     * Deprecated. Please use the [Sessions API](https://dev.wix.com/api/rest/wix-bookings/schedules-and-sessions/session) instead.
     * @deprecated
     */
    intervals?: RecurringInterval[];
    /**
     * Default title for the schedule's sessions. Maximum length: 6000 characters.
     * @maxLength 6000
     */
    title?: string | null;
    /**
     * __Deprecated.__
     * Tags for grouping schedules. These tags are the default tags for the schedule's sessions.
     * The Wix Bookings app uses the following predefined tags to set schedule type: `"INDIVIDUAL"`, `"GROUP"`, and `"COURSE"`. Once the schedule type is set using these tags, you cannot update it. In addition to the app's tags, you can create and update your own tags.
     * @deprecated
     */
    tags?: string[] | null;
    /** Default location for the schedule's sessions. */
    location?: Location;
    /**
     * Maximum number of participants that can be added to the schedule's sessions.
     * Must be at most `1` for schedule whose availability is affected by another schedule. E.g, appointment schedules of the Wix Bookings app.
     * @min 1
     * @max 1000
     */
    capacity?: number | null;
    /**
     * Deprecated. Please use the [Booking Services V2](https://dev.wix.com/api/rest/wix-bookings/services-v2) payment instead.
     * @deprecated
     */
    rate?: Rate;
    /**
     * __Deprecated.__
     * @deprecated
     */
    availability?: Availability;
    /**
     * Number of participants registered to sessions in this schedule, calculated as the sum of the party sizes.
     * @readonly
     */
    totalNumberOfParticipants?: number;
    /**
     * *Partial list** of participants which are registered to sessions in this schedule.
     * Participants who are registered in the schedule are automatically registered to any session that is created for the schedule.
     * To retrieve the full list of schedule participants please use the [Query Extended Bookings API](https://dev.wix.com/api/rest/wix-bookings/bookings-reader-v2/query-extended-bookings).
     * @readonly
     */
    participants?: Participant[];
    /**
     * __Deprecated.__
     * @deprecated
     */
    externalCalendarOverrides?: ExternalCalendarOverrides;
    /**
     * Schedule status. Default: Created
     * @readonly
     */
    status?: ScheduleStatus;
    /**
     * Schedule creation date.
     * @readonly
     */
    created?: Date | null;
    /**
     * Schedule last update date.
     * @readonly
     */
    updated?: Date | null;
    /**
     * Schedule version number, updated each time the schedule is updated.
     * @readonly
     */
    version?: number;
    /**
     * Fields which were inherited from the Business Info page under Settings in the Dashboard.
     * @readonly
     */
    inheritedFields?: string[];
    /**
     * __Deprecated.__
     * @deprecated
     */
    conferenceProvider?: ConferenceProvider;
    /**
     * A conference created for the schedule. This is used when a participant is added to a schedule.
     * **Partially deprecated.** Only `hostUrl` and `guestUrl` are to be supported.
     * @deprecated
     */
    calendarConference?: CalendarConference;
}
export interface RecurringInterval {
    /**
     * The recurring interval identifier.
     * @readonly
     */
    _id?: string;
    /** The start time of the recurring interval. Required. */
    start?: Date | null;
    /** The end time of the recurring interval. Optional. Empty value indicates that there is no end time. */
    end?: Date | null;
    /** The interval rules. The day, hour and minutes the interval is recurring. */
    interval?: Interval;
    /** The frequency of the interval. Optional. The default is frequency with the default repetition. */
    frequency?: Frequency;
    /** Specifies the list of linked schedules and the way this link affects the corresponding schedules' availability. Can be calculated from the schedule or overridden on the recurring interval. */
    affectedSchedules?: LinkedSchedule[];
    /** The type of recurring interval. */
    intervalType?: RecurringIntervalType;
}
export interface Interval {
    /** The day the interval occurs. Optional. The default is the day of the recurring interval's start time. */
    daysOfWeek?: Day;
    /**
     * The hour of the day the interval occurs. Must be consistent with the interval start time. Optional. The default is 0. Minimum: 0, maximum: 23.
     * @max 23
     */
    hourOfDay?: number | null;
    /**
     * The minutes of the hour the interval accrues. Must be consistent with the interval end time. Optional. The default is 0. Minimum: 0, maximum: 59.
     * @max 59
     */
    minuteOfHour?: number | null;
    /** The duration of the interval in minutes. Required. Part of the session end time calculation. */
    duration?: number;
}
export declare enum Day {
    /** Undefined. */
    UNDEFINED = "UNDEFINED",
    /** Monday. */
    MON = "MON",
    /** Tuesday. */
    TUE = "TUE",
    /** Wednesday. */
    WED = "WED",
    /** Thursday. */
    THU = "THU",
    /** Friday. */
    FRI = "FRI",
    /** Saturday. */
    SAT = "SAT",
    /** Sunday. */
    SUN = "SUN"
}
export interface Frequency {
    /**
     * The frequency of the recurrence in weeks. i.e. when this value is 4, the interval occurs every 4 weeks. Optional. The default is 1. minimum: 1, maximum: 52.
     * @min 1
     * @max 52
     */
    repetition?: number | null;
}
export interface LinkedSchedule {
    /**
     * Schedule ID.
     * @format GUID
     */
    scheduleId?: string;
    /** Sets this schedule's availability for the duration of the linked schedule's sessions. Default is `"BUSY"`. */
    transparency?: Transparency;
    /**
     * Owner ID, of the linked schedule.
     * @readonly
     */
    scheduleOwnerId?: string;
}
export declare enum Transparency {
    UNDEFINED = "UNDEFINED",
    /** The schedule can have available slots during the linked schedule's sessions. */
    FREE = "FREE",
    /** The schedule can't have available slots during the linked schedule's sessions. */
    BUSY = "BUSY"
}
export declare enum RecurringIntervalType {
    /** The default value. Sessions for this interval will be of type EVENT. */
    UNDEFINED = "UNDEFINED",
    /** A recurring interval of events. */
    EVENT = "EVENT",
    /** Deprecated. */
    TIME_AVAILABILITY = "TIME_AVAILABILITY",
    /** A recurring interval for availability. */
    AVAILABILITY = "AVAILABILITY"
}
export interface Location {
    /**
     * Location type.
     * One of:
     * - `"OWNER_BUSINESS"` The business address as set in the site’s general settings.
     * - `"OWNER_CUSTOM"` The address as set when creating the service.
     * - `"CUSTOM"` The address set for the individual session.
     */
    locationType?: LocationType;
    /**
     * Free text address used when locationType is `OWNER_CUSTOM`.
     * @deprecated
     */
    address?: string | null;
    /** Custom address, used when locationType is `"OWNER_CUSTOM"`. Might be used when locationType is `"CUSTOM"` in case the owner sets a custom address for the session which is different from the default. */
    customAddress?: Address;
}
export declare enum LocationType {
    UNDEFINED = "UNDEFINED",
    OWNER_BUSINESS = "OWNER_BUSINESS",
    OWNER_CUSTOM = "OWNER_CUSTOM",
    CUSTOM = "CUSTOM"
}
/** Physical address */
export interface Address extends AddressStreetOneOf {
    /** Street name, number and apartment number. */
    streetAddress?: StreetAddress;
    /** Main address line, usually street and number, as free text. */
    addressLine?: string | null;
    /**
     * Country code.
     * @format COUNTRY
     */
    country?: string | null;
    /** Subdivision. Usually state, region, prefecture or province code, according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). */
    subdivision?: string | null;
    /** City name. */
    city?: string | null;
    /** Zip/postal code. */
    postalCode?: string | null;
    /** Free text providing more detailed address info. Usually contains Apt, Suite, and Floor. */
    addressLine2?: string | null;
    /** A string containing the full address of this location. */
    formattedAddress?: string | null;
    /** Free text to help find the address. */
    hint?: string | null;
    /** Coordinates of the physical address. */
    geocode?: AddressLocation;
    /** Country full name. */
    countryFullname?: string | null;
    /** Multi-level subdivisions from top to bottom. */
    subdivisions?: Subdivision[];
}
/** @oneof */
export interface AddressStreetOneOf {
    /** Street name, number and apartment number. */
    streetAddress?: StreetAddress;
    /** Main address line, usually street and number, as free text. */
    addressLine?: string | null;
}
export interface StreetAddress {
    /** Street number. */
    number?: string;
    /** Street name. */
    name?: string;
    /** Apartment number. */
    apt?: string;
}
export interface AddressLocation {
    /** Address latitude. */
    latitude?: number | null;
    /** Address longitude. */
    longitude?: number | null;
}
export interface Subdivision {
    /** Subdivision code. Usually state, region, prefecture or province code, according to [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2). */
    code?: string;
    /** Subdivision full name. */
    name?: string;
}
export interface LocationsLocation {
    /**
     * Location ID.
     * @format GUID
     * @readonly
     */
    _id?: string | null;
    /**
     * Location name.
     * @maxLength 150
     */
    name?: string;
    /**
     * Location description.
     * @maxLength 500
     */
    description?: string | null;
    /**
     * Whether this is the default location. There can only be one default location per site. The default location can't be archived.
     * @readonly
     */
    default?: boolean;
    /**
     * Location status. Defaults to `ACTIVE`.
     * __Notes:__
     * - [Archiving a location](https://dev.wix.com/api/rest/business-info/locations/archive-location)
     * doesn't affect the location's status.
     * - `INACTIVE` status is currently not supported.
     */
    status?: LocationStatus;
    /**
     * Location type.
     *
     * **Note:** Currently not supported.
     * @deprecated
     */
    locationType?: LocationsLocationType;
    /** Fax number. */
    fax?: string | null;
    /** Timezone in `America/New_York` format. */
    timeZone?: string | null;
    /** Email address. */
    email?: string | null;
    /** Phone number. */
    phone?: string | null;
    /** Address. */
    address?: LocationsAddress;
    /**
     * Business schedule. Array of weekly recurring time periods when the location is open for business. Limited to 100 time periods.
     *
     * __Note:__ Not supported by Wix Bookings.
     */
    businessSchedule?: BusinessSchedule;
    /**
     * Revision number, which increments by 1 each time the location is updated.
     * To prevent conflicting changes, the existing revision must be used when updating a location.
     */
    revision?: string | null;
    /**
     * Whether the location is archived. Archived locations can't be updated.
     * __Note:__ [Archiving a location](https://dev.wix.com/api/rest/business-info/locations/archive-location)
     * doesn't affect its `status`.
     * @readonly
     */
    archived?: boolean;
    /**
     * Location types.
     * @maxSize 10
     */
    locationTypes?: LocationsLocationType[];
}
/** For future use */
export declare enum LocationStatus {
    ACTIVE = "ACTIVE",
    INACTIVE = "INACTIVE"
}
/** For future use */
export declare enum LocationsLocationType {
    UNKNOWN = "UNKNOWN",
    BRANCH = "BRANCH",
    OFFICES = "OFFICES",
    RECEPTION = "RECEPTION",
    HEADQUARTERS = "HEADQUARTERS",
    INVENTORY = "INVENTORY"
}
export interface LocationsAddress {
    /**
     * 2-letter country code in an [ISO-3166 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format.
     * @format COUNTRY
     */
    country?: string | null;
    /** Code for a subdivision (such as state, prefecture, or province) in [ISO 3166-2](https://en.wikipedia.org/wiki/ISO_3166-2) format. */
    subdivision?: string | null;
    /** City name. */
    city?: string | null;
    /**
     * Postal or zip code.
     * @maxLength 20
     */
    postalCode?: string | null;
    /** Street address. Includes street name, number, and apartment number in separate fields. */
    streetAddress?: LocationsStreetAddress;
    /** Full address of the location. */
    formatted?: string | null;
    /** Geographic coordinates of location. */
    location?: LocationsAddressLocation;
}
/** Street address. Includes street name, number, and apartment number in separate fields. */
export interface LocationsStreetAddress {
    /** Street number. */
    number?: string;
    /** Street name. */
    name?: string;
    /** Apartment number. */
    apt?: string;
}
/** Address Geolocation */
export interface LocationsAddressLocation {
    /** Latitude of the location. Must be between -90 and 90. */
    latitude?: number | null;
    /** Longitude of the location. Must be between -180 and 180. */
    longitude?: number | null;
}
/** Business schedule. Regular and exceptional time periods when the business is open or the service is available. */
export interface BusinessSchedule {
    /**
     * Weekly recurring time periods when the business is regularly open or the service is available. Limited to 100 time periods.
     * @maxSize 100
     */
    periods?: TimePeriod[];
    /**
     * Exceptions to the business's regular hours. The business can be open or closed during the exception.
     * @maxSize 100
     */
    specialHourPeriod?: SpecialHourPeriod[];
}
/** Weekly recurring time periods when the business is regularly open or the service is available. */
export interface TimePeriod {
    /** Day of the week the period starts on. */
    openDay?: DayOfWeek;
    /**
     * Time the period starts in 24-hour [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) extended format. Valid values are `00:00` to `24:00`, where `24:00` represents
     * midnight at the end of the specified day.
     */
    openTime?: string;
    /** Day of the week the period ends on. */
    closeDay?: DayOfWeek;
    /**
     * Time the period ends in 24-hour [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) extended format. Valid values are `00:00` to `24:00`, where `24:00` represents
     * midnight at the end of the specified day.
     *
     * __Note:__ If `openDay` and `closeDay` specify the same day of the week `closeTime` must be later than `openTime`.
     */
    closeTime?: string;
}
/** Enumerates the days of the week. */
export declare enum DayOfWeek {
    MONDAY = "MONDAY",
    TUESDAY = "TUESDAY",
    WEDNESDAY = "WEDNESDAY",
    THURSDAY = "THURSDAY",
    FRIDAY = "FRIDAY",
    SATURDAY = "SATURDAY",
    SUNDAY = "SUNDAY"
}
/** Exception to the business's regular hours. The business can be open or closed during the exception. */
export interface SpecialHourPeriod {
    /** Start date and time of the exception in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format and [Coordinated Universal Time (UTC)](https://en.wikipedia.org/wiki/Coordinated_Universal_Time). */
    startDate?: string;
    /** End date and time of the exception in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601) format and [Coordinated Universal Time (UTC)](https://en.wikipedia.org/wiki/Coordinated_Universal_Time). */
    endDate?: string;
    /**
     * Whether the business is closed (or the service is not available) during the exception.
     *
     * Default: `true`.
     */
    isClosed?: boolean;
    /** Additional info about the exception. For example, "We close earlier on New Year's Eve." */
    comment?: string;
}
export interface Rate {
    /**
     * Mapping between a named price option, for example, adult or child prices, and the price, currency, and down payment amount.
     * When present in an update request, the `default_varied_price` is ignored to support backward compatibility.
     */
    labeledPriceOptions?: Record<string, Price>;
    /**
     * Textual price information used when **Price Per Session** is set to **Custom Price** in the app's service details page.
     * When present in an update request, the `default_varied_price` is ignored to support backward compatibility.
     */
    priceText?: string | null;
}
export interface Price {
    /**
     * Required payment amount.
     * @format DECIMAL_VALUE
     */
    amount?: string;
    /**
     * Currency in which the amount is quoted.
     * @format CURRENCY
     */
    currency?: string;
    /**
     * Amount of a down payment or deposit as part of the transaction.
     * @format DECIMAL_VALUE
     */
    downPayAmount?: string;
}
/**
 * <!-- Needs updating when recurrence has been tested
 * Schedule's availability calculation is executed by the schedule's available intervals and this additional information.
 * Schedule's available intervals are recurring intervals (defined in the schedule) minus sessions that has no more spots for bookings (including time between_slots), or schedule's sessions with open spots for bookings.-->
 */
export interface Availability {
    /** Date and time the schedule starts to be available for booking. */
    start?: Date | null;
    /** Date and time the schedule stops being available for booking. No value indicates no end time. */
    end?: Date | null;
    /** Other schedules that impact the availability calculation. Relevant only when there are availability constraints. */
    linkedSchedules?: LinkedSchedule[];
    /** Constraints for calculating the schedule's availability. */
    constraints?: AvailabilityConstraints;
}
/** Describes how to calculate the specific slots that are available for booking. */
export interface AvailabilityConstraints {
    /**
     * A list of duration options for slots, in minutes. Minimum value for a duration is 1.
     * The availability calculation generates slots with these durations, where there is no conflict with existing sessions or other availability constraints.
     * @min 1
     */
    slotDurations?: number[];
    /**
     * The number of minutes between the `end` of one slot, and the `start` of the next.
     * Minimum value is 0, maximum value is 120.
     * @max 720
     */
    timeBetweenSlots?: number;
    /**
     * Specify how to split the slots in intervals of minutes.
     * This value indicates the time between available slots' start time. e.g., from 5 minute slots (3:00, 3:05, 3:15) and 1 hour slots (3:00, 4:00, 5:00).
     * Optional. The default is the first duration in slot_durations field.
     * Deprecated. Use the `split_slots_interval.value_in_minutes`.
     * @deprecated
     */
    splitInterval?: number | null;
    /**
     * An object defining the time between available slots' start times.  For example, a slot with slots_split_interval=5 can start every 5 minutes. The default is the slot duration.
     * @readonly
     */
    slotsSplitInterval?: SplitInterval;
}
/** The time between available slots' start times. For example, For 5 minute slots, 3:00, 3:05, 3:15 etc. For 1 hour slots, 3:00, 4:00, 5:00 etc. */
export interface SplitInterval {
    /**
     * Whether the slot duration is used as the split interval value.
     * If `same_as_duration` is `true`, the `value_in_minutes` is the sum of the first duration in
     * `schedule.availabilityConstraints.SlotDurations` field, and `schedule.availabilityConstraints.TimeBetweenSlots` field.
     */
    sameAsDuration?: boolean | null;
    /** Number of minutes between available slots' start times when `same_as_duration` is `false`. */
    valueInMinutes?: number | null;
}
export interface Participant {
    /**
     * Participant ID. Currently represents the booking.id.
     * @format GUID
     */
    _id?: string;
    /**
     * Contact ID.
     * @format GUID
     */
    contactId?: string | null;
    /** Participant's name. */
    name?: string | null;
    /** Participant's phone number. */
    phone?: string | null;
    /** Participant's email address. */
    email?: string | null;
    /** Group or party size. The number of people attending. Defaults to 0. Maximum is 250. */
    partySize?: number;
    /**
     * Approval status for the participant.
     * <!-- Commented out untill updateParticipant is exposed Generally the same status as the booking, unless updated using the `updateParticipant()` API. Defaults to `"UNDEFINED"`.-->
     */
    approvalStatus?: ApprovalStatus;
    /**
     * Whether the participant was inherited from the schedule, as opposed to being booked directly to the session.
     * @readonly
     */
    inherited?: boolean;
}
export declare enum ApprovalStatus {
    /** Default. */
    UNDEFINED = "UNDEFINED",
    /** Pending business approval. */
    PENDING = "PENDING",
    /** Approved by the business. */
    APPROVED = "APPROVED",
    /** Declined by the business. */
    DECLINED = "DECLINED"
}
export interface ExternalCalendarOverrides {
    /** Synced title of the external calendar event. */
    title?: string | null;
    /** Synced description of the external calendar event. */
    description?: string | null;
}
export declare enum ScheduleStatus {
    /** Undefined schedule status. */
    UNDEFINED = "UNDEFINED",
    /** The schedule was created. */
    CREATED = "CREATED",
    /** The schedule was cancelled. */
    CANCELLED = "CANCELLED"
}
export interface Version {
    /** Schedule version number, updated each time the schedule is updated. */
    scheduleVersion?: number | null;
    /** Participants version number, updated each time the schedule participants are updated. */
    participantsVersion?: number | null;
}
export interface ConferenceProvider {
    /** Conferencing provider ID */
    providerId?: string;
}
export interface CalendarConference {
    /** Wix Calendar conference ID. */
    _id?: string;
    /** Conference meeting ID in the provider's conferencing system. */
    externalId?: string;
    /** Conference provider ID. */
    providerId?: string;
    /** URL used by the host to start the conference. */
    hostUrl?: string;
    /** URL used by a guest to join the conference. */
    guestUrl?: string;
    /** Password to join the conference. */
    password?: string | null;
    /** Conference description. */
    description?: string | null;
    /** Conference type. */
    conferenceType?: ConferenceType;
    /** ID of the account owner in the video conferencing service. */
    accountOwnerId?: string | null;
}
export declare enum ConferenceType {
    /** Undefined conference type. */
    UNDEFINED = "UNDEFINED",
    /** API-generated online meeting. */
    ONLINE_MEETING_PROVIDER = "ONLINE_MEETING_PROVIDER",
    /** User-defined meeting. */
    CUSTOM = "CUSTOM"
}
export interface ScheduleUpdated {
    /** The old schedule before the update. */
    oldSchedule?: Schedule;
    /** The new schedule after the update. */
    newSchedule?: Schedule;
    /**
     * Recurring sessions updated event. If this field is given, the reason for the schedule updated event was
     * updating at least one of the given schedule's recurring sessions.
     * This event is triggered by create/update/delete recurring session apis.
     */
    recurringSessions?: RecurringSessionsUpdated;
    /** Whether to notify participants about the change and an optional custom message */
    participantNotification?: ParticipantNotification;
    /**
     * Whether this notification was created as a result of an anonymization request, such as GDPR.
     * An anonymized participant will have the following details:
     * name = "deleted"
     * phone = "deleted"
     * email = "deleted@deleted.com"
     */
    triggeredByAnonymizeRequest?: boolean | null;
}
export interface RecurringSessionsUpdated {
    /** Old schedule's recurring session list. */
    oldRecurringSessions?: Session[];
    /** New schedule's recurring session list. */
    newRecurringSessions?: Session[];
}
export interface Session {
    /**
     * Session ID.
     * @readonly
     */
    _id?: string | null;
    /**
     * ID of the schedule that the session belongs to.
     * @immutable
     */
    scheduleId?: string;
    /**
     * ID of the resource or service that the session's schedule belongs to.
     * @readonly
     */
    scheduleOwnerId?: string | null;
    /** Original start date and time of the session in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Coordinated_Universal_Time_(UTC)) format. */
    originalStart?: Date | null;
    /** An object specifying the start date and time of the session. If the session is a recurring session, `start` must contain a `localDateTime`. */
    start?: CalendarDateTime;
    /**
     * An object specifying the end date and time of the session. The `end` time must be after the `start` time and be same type as `start`.
     * If the session is a recurring session, `end` must contain a `localDateTime`.
     */
    end?: CalendarDateTime;
    /**
     * An object specifying a list of schedules and the way each schedule's availability is affected by the session. For example, the schedule of an instructor is affected by sessions of the class that they instruct.
     * The array is inherited from the schedule and can be overridden even if the session is a recurring session.
     */
    affectedSchedules?: LinkedSchedule[];
    /**
     * Session title.
     * The value is inherited from the schedule and can be overridden unless the session is a recurring session.
     * @maxLength 6000
     */
    title?: string | null;
    /**
     * __Deprecated.__
     * Tags for the session.
     * The value is inherited from the schedule and can be overridden unless the session is a recurring session.
     * @maxLength 200
     * @deprecated
     */
    tags?: string[] | null;
    /**
     * An object describing the location where the session takes place.
     * Defaults to the schedule location.
     * For single sessions, `session.location.businessLocation` can only be provided for locations that are defined in the schedule using `schedule.location` or `schedule.availability.locations`.
     */
    location?: Location;
    /**
     * Maximum number of participants that can be added to the session. Defaults to the schedule capacity.
     * The value is inherited from the schedule and can be overridden unless the session is a recurring session.
     * @max 1000
     */
    capacity?: number | null;
    /**
     * Deprecated. Please use the [Booking Services V2](https://dev.wix.com/api/rest/wix-bookings/services-v2) payment instead.
     * @deprecated
     */
    rate?: Rate;
    /**
     * Time reserved after the session end time, derived from the schedule availability constraints and the time between slots. Read-only.
     * If the session is a recurring session, this field must be empty.
     */
    timeReservedAfter?: number | null;
    /**
     * Additional information about the session.
     * Notes are not supported for recurring sessions.
     * @maxLength 10000
     */
    notes?: string;
    /**
     * The number of participants booked for the session. Read-only.
     * Calculated as the sum of the party sizes.
     * @readonly
     */
    totalNumberOfParticipants?: number;
    /**
     * *Partial list** list of participants booked for the session.
     * The list includes participants who have registered for this specific session, and participants who have registered for a schedule that includes this session.
     * If the session is a recurring session, this field must be empty.
     * To retrieve the full list of session participants please use the [Query Extended Bookings API](https://dev.wix.com/api/rest/wix-bookings/bookings-reader-v2/query-extended-bookings).
     */
    participants?: Participant[];
    /**
     * A list of properties for which values were inherited from the schedule.
     * This does not include participants that were inherited from the schedule.
     * @readonly
     */
    inheritedFields?: string[];
    /**
     * __Deprecated.__
     * @deprecated
     */
    externalCalendarOverrides?: ExternalCalendarOverrides;
    /**
     * Session status.
     * @readonly
     */
    status?: Status;
    /**
     * Recurring interval ID. Defined when a session will be a recurring session. read-only. Optional.
     * For example, when creating a class service  with recurring sessions, you add a recurrence rule to create recurring sessions.
     * This field is omitted for single sessions or instances of recurring sessions.
     * Specified when the session was originally generated from a schedule recurring interval.
     * Deprecated. Use `recurringSessionId`.
     * @readonly
     * @deprecated
     */
    recurringIntervalId?: string | null;
    /**
     * The ID of the recurring session if this session is an instance of a recurrence. Use this ID to update the recurrence and all of the instances.
     * @readonly
     */
    recurringSessionId?: string | null;
    /** Session type. */
    type?: SessionType;
    /**
     * A conference created for the session according to the details set in the schedule's conference provider information.
     * If the session is a recurring session, this field is inherited from the schedule.
     * **Partially deprecated.** Only `hostUrl` and `guestUrl` are to be supported.
     * @deprecated
     */
    calendarConference?: CalendarConference;
    /**
     * A string representing a recurrence rule (RRULE) for a recurring session, as defined in [iCalendar RFC 5545](https://icalendar.org/iCalendar-RFC-5545/3-3-10-recurrence-rule.html).
     * If the session is an instance of a recurrence pattern, the `instanceOfRecurrence` property will be contain the recurrence rule and this property will be empty.
     * The RRULE defines a rule for repeating a session.
     * Supported parameters are:
     *
     * |Keyword|Description|Supported values|
     * |--|--|---|
     * |`FREQ`|The frequency at which the session is recurs. Required.|`WEEKLY`|
     * |`INTERVAL`|How often, in terms of `FREQ`, the session recurs. Default is 1. Optional.|
     * |`UNTIL`|The UTC end date and time of the recurrence. Optional.|
     * |`BYDAY`|Day of the week when the event should recur. Required.|One of: `MO`, `TU`, `WE`, `TH`, `FR`, `SA`, `SU`|
     *
     *
     * For example, a session that repeats every second week on a Monday until January 7, 2022 at 8 AM:
     * `"FREQ=WEEKLY;INTERVAL=2;BYDAY=MO;UNTIL=20220107T080000Z"`
     *
     * <!--ORIGINAL COMMENTS:
     * `FREQ` — The frequency with which the session should be repeated (such as DAILY or WEEKLY).
     * Supported `WEEKLY` value is supported.
     * INTERVAL — Works together with FREQ to specify how often the session should be repeated. For example, FREQ=WEEKLY;INTERVAL=2 means once every two weeks. Optional. Default value is 1.
     * COUNT — The number of times this event should be repeated. Not yet supported.
     * UNTIL — The UTC date & time until which the session should be repeated. This parameter is optional. When it is not specified, the event repeats forever.
     * The format is a short ISO date, followed by 'T' and a short time with seconds and without milliseconds, terminated by the UTC designator 'Z'. For example, until Jan. 19th 2018 at 7:00 AM: 'UNTIL=20180119T070000Z'.
     * BYDAY - The days of the week when the event should be repeated. Currently, only a single day is supported. This parameter is mandatory.
     * Possible values are: MO, TU, WE, TH, FR, SA, SU
     * Note that DTSTART and DTEND lines are not allowed in this field; session start and end times are specified in the start and end fields.
     * **Example**: FREQ=WEEKLY;INTERVAL=2;BYDAY=MO;UNTIL=20200427T070000Z
     * ORIGINAL COMMENTS-->
     */
    recurrence?: string | null;
    /**
     * A string representing a recurrence rule (RRULE) if the session is an instance of a recurrence pattern.
     * Empty when the session is not an instance of a recurrence rule, or if the session defines a recurrence pattern, and `recurrence` is not empty.
     * @readonly
     */
    instanceOfRecurrence?: string | null;
    /**
     * The session version.
     * Composed by the schedule, session and participants versions.
     * @readonly
     */
    version?: SessionVersion;
}
export interface CalendarDateTime {
    /**
     * UTC date-time in [ISO 8601](https://en.wikipedia.org/wiki/ISO_8601#Coordinated_Universal_Time_(UTC)) format. If a time zone offset is specified, the time is converted to UTC. For example, if you specify  `new Date('2021-01-06T16:00:00.000-07:00')`, the stored value will be `"2021-01-06T23:00:00.000Z"`.
     * Required if `localDateTime` is not specified.
     * If `localDateTime` is specified, `timestamp` is calculated as `localDateTime`, using the business's time zone.
     */
    timestamp?: Date | null;
    /** An object containing the local date and time for the business's time zone. */
    localDateTime?: LocalDateTime;
    /**
     * The time zone. Optional. Derived from the schedule's time zone.
     * In case this field is associated with recurring session, this field is empty.
     * @readonly
     */
    timeZone?: string | null;
}
export interface LocalDateTime {
    /** Year. 4-digit format. */
    year?: number | null;
    /**
     * Month number, from 1-12.
     * @min 1
     * @max 12
     */
    monthOfYear?: number | null;
    /** Day of the month, from 1-31. */
    dayOfMonth?: number | null;
    /**
     * Hour of the day in 24-hour format, from 0-23.
     * @max 23
     */
    hourOfDay?: number | null;
    /**
     * Minute, from 0-59.
     * @max 59
     */
    minutesOfHour?: number | null;
}
export interface ExternalCalendarInfo {
    /** The external calendar type (e.g. Google Calendar, iCal, etc). */
    calendarType?: CalendarType;
}
export declare enum CalendarType {
    /** There is no information about the external calendar type. */
    UNDEFINED = "UNDEFINED",
    /** [Google Calendar](https://developers.google.com/calendar/api/guides/overview). */
    GOOGLE = "GOOGLE",
    /** Apple iCalendar. */
    I_CAL = "I_CAL",
    /** __Deprecated__. Use `MICROSOFT` instead. */
    OUTLOOK = "OUTLOOK",
    /** __Deprecated__. Use `MICROSOFT` instead. */
    OFFICE_365 = "OFFICE_365",
    /** Microsoft Calendar. For example, Office 365 calendar or Outlook calendar. */
    MICROSOFT = "MICROSOFT",
    /** A different type of external calendar, not listed here. */
    OTHER = "OTHER"
}
export declare enum Status {
    /** Undefined status. */
    UNDEFINED = "UNDEFINED",
    /** Session is confirmed. Default status. */
    CONFIRMED = "CONFIRMED",
    /**
     * Session is cancelled.
     * A cancelled session can be the cancellation of a recurring session that should no longer be displayed or a deleted single session.
     * The ListSessions returns cancelled sessions only if 'includeDelete' flag is set to true.
     */
    CANCELLED = "CANCELLED"
}
export declare enum SessionType {
    UNDEFINED = "UNDEFINED",
    /**
     * Creates an event on the calendar for the owner of the schedule that the session belongs to.
     * Default type.
     */
    EVENT = "EVENT",
    /** Represents a resource's available working hours. */
    WORKING_HOURS = "WORKING_HOURS",
    /** Deprecated. Please use WORKING_HOURS. */
    TIME_AVAILABILITY = "TIME_AVAILABILITY",
    /** Deprecated. Represents a resource's available hours. Please use WORKING_HOURS. */
    AVAILABILITY = "AVAILABILITY"
}
export interface SessionVersion {
    /** Incremental version number, which is updated on each change to the session or on changes affecting the session. */
    number?: string | null;
}
export interface ParticipantNotification {
    /**
     * Whether to send the message about the changes to the customer.
     *
     * Default: `false`
     */
    notifyParticipants?: boolean;
    /** Custom message to send to the participants about the changes to the booking. */
    message?: string | null;
}
export interface ScheduleCancelled {
    schedule?: Schedule;
    /** Whether to notify participants about the change and an optional custom message */
    participantNotification?: ParticipantNotification;
    oldSchedule?: Schedule;
}
export interface SessionCreated {
    session?: Session;
}
export interface SessionUpdated {
    oldSession?: Session;
    newSession?: Session;
    /** Whether to notify participants about the change and an optional custom message */
    participantNotification?: ParticipantNotification;
    /**
     * Whether this notification was created as a result of an anonymization request, such as GDPR.
     * An anonymized participant will have the following details:
     * name = "deleted"
     * phone = "deleted"
     * email = "deleted@deleted.com"
     */
    triggeredByAnonymizeRequest?: boolean | null;
}
export interface SessionCancelled {
    session?: Session;
    /** Whether to notify participants about the change and an optional custom message */
    participantNotification?: ParticipantNotification;
}
export interface AvailabilityPolicyUpdated {
    availabilityPolicy?: AvailabilityPolicy;
}
/** Availability policy applied to all site schedules. */
export interface AvailabilityPolicy {
    /** Specify how to split the schedule slots in intervals of minutes. */
    splitInterval?: SplitInterval;
}
export interface IntervalSplit {
    scheduleId?: string;
    intervals?: RecurringInterval[];
    newScheduleVersion?: number | null;
    oldScheduleVersion?: number | null;
}
export interface RecurringSessionSplit {
    scheduleId?: string;
    recurringSessions?: Session[];
    newScheduleVersion?: number | null;
    oldScheduleVersion?: number | null;
}
/** Schedule unassigned from user. */
export interface ScheduleUnassignedFromUser {
    /**
     * The Wix user id.
     * @format GUID
     */
    userId?: string | null;
    /** The schedule that was unassigned from the user. */
    schedule?: Schedule;
}
export interface MultipleSessionsCreated {
    schedulesWithSessions?: ScheduleWithSessions[];
}
export interface ScheduleWithSessions {
    schedule?: Schedule;
    siteProperties?: SitePropertiesOnScheduleCreation;
    sessions?: Session[];
}
export interface SitePropertiesOnScheduleCreation {
    /** The global time zone value. */
    timeZone?: string | null;
}
export interface MigrationEvent {
    migrationData?: MigrationData;
}
export interface MigrationData {
    businessId?: string | null;
    staffs?: StaffData[];
}
export interface StaffData {
    resourceId?: string;
    syncRequestEmail?: string;
    refreshToken?: string;
}
export interface ResourceNotification {
    /**
     * Updated resource entity.
     * 'resource.schedules' is deprecated and will not be returned. Please use 'resource.scheduleIds' instead.
     */
    resource?: Resource;
    /** Event type. */
    event?: ResourceNotificationEvent;
}
export interface Resource {
    /**
     * Resource ID.
     * @format GUID
     * @readonly
     */
    _id?: string | null;
    /**
     * Resource name.
     * @maxLength 1200
     */
    name?: string | null;
    /**
     * Resource email address.
     * @maxLength 500
     */
    email?: string | null;
    /**
     * Resource phone number.
     * @maxLength 500
     */
    phone?: string | null;
    /**
     * Resource description.
     * @maxLength 500
     */
    description?: string | null;
    /**
     * Deprecated. Please use tags.
     * @maxLength 500
     * @deprecated
     */
    tag?: string | null;
    /**
     * Resource tags. Tags are used to identify, group, and filter the different types of resources. For example, 'staff' or 'room'.
     * @maxLength 200
     */
    tags?: string[] | null;
    /** Resource images. */
    images?: string[];
    /**
     * Deprecated. Please use scheduleIds. List of the schedules owned by this resource. Min size 1.
     * @deprecated
     */
    schedules?: Schedule[];
    /**
     * List of IDs of schedules owned by this resource.
     * @format GUID
     * @readonly
     */
    scheduleIds?: string[] | null;
    /**
     * Resource status. Default: `CREATED`.
     * @readonly
     */
    status?: ResourceStatus;
    /**
     * Wix user ID, if the resource is associated with the Wix user.
     * A staff member resource can be associated with a Wix user via assignment of a permissions role in the business manager.
     * @format GUID
     * @readonly
     */
    wixUserId?: string | null;
}
export interface FocalPoint {
    /** X-coordinate of the focal point. */
    x?: number;
    /** Y-coordinate of the focal point. */
    y?: number;
    /** crop by height */
    height?: number | null;
    /** crop by width */
    width?: number | null;
}
export declare enum ResourceStatus {
    /** Undefined resource status. */
    UNDEFINED = "UNDEFINED",
    /** The resource was created. */
    CREATED = "CREATED",
    /** The resource was deleted. */
    DELETED = "DELETED",
    /** The resource was updated. */
    UPDATED = "UPDATED"
}
export interface BusinessLocation {
    /**
     * The ID of the business location. Has to be non-empty
     * @format GUID
     */
    locationId?: string;
}
export declare enum ResourceNotificationEvent {
    /** Undefined resource event. */
    UNDEFINED = "UNDEFINED",
    /** The resource was updated. */
    Updated = "Updated",
    /** The resource was deleted. */
    Deleted = "Deleted",
    /** The resource was created. */
    Created = "Created",
    /** The schedule was updated. */
    Schedule_Updated = "Schedule_Updated"
}
export interface BenefitNotification {
    /**
     * Plan unique ID
     * @format GUID
     */
    planId?: string;
    /**
     * App def ID
     * @format GUID
     */
    appDefId?: string;
    /** Current benefit details */
    benefit?: Benefit;
    /** Previous benefit */
    prevBenefit?: Benefit;
    /** Notification event */
    event?: Event;
}
export interface Benefit {
    /**
     * Benefit unique ID
     * @format GUID
     * @readonly
     */
    _id?: string | null;
    /** Benefit Type */
    benefitType?: BenefitType;
    /**
     * Resource IDs that serves by this benefit
     * @format GUID
     */
    resourceIds?: string[];
    /** Amount of credits that provided by this benefit */
    creditAmount?: number | null;
    /**
     * additional details related to benefit; limited to 20 entries, 20 symbols for key and 20 symbols for value
     * @maxSize 20
     */
    customFields?: Record<string, string>;
    /** return value only in case it required in the ListRequest, true means that benefit's type could be updated */
    editable?: boolean | null;
    /** Benefit behavior */
    behavior?: Behavior;
    /**
     * Id of the app associated with this benefit
     * @format GUID
     * @readonly
     */
    appDefId?: string | null;
}
export interface EntryPass {
}
export interface Discount extends DiscountDiscountOneOf {
    /**
     * Fixed-rate percent off discount
     * @decimalValue options { gt:0, lte:100, maxScale:2 }
     */
    percentOffRate?: string;
    /**
     * Absolute amount discount
     * @decimalValue options { gt:0, maxScale:2 }
     */
    moneyOffAmount?: string;
}
/** @oneof */
export interface DiscountDiscountOneOf {
    /**
     * Fixed-rate percent off discount
     * @decimalValue options { gt:0, lte:100, maxScale:2 }
     */
    percentOffRate?: string;
    /**
     * Absolute amount discount
     * @decimalValue options { gt:0, maxScale:2 }
     */
    moneyOffAmount?: string;
}
export declare enum BenefitType {
    /** Should never be used */
    UNDEFINED = "UNDEFINED",
    /** Limited benefit type */
    LIMITED = "LIMITED",
    /** Unlimited benefit type */
    UNLIMITED = "UNLIMITED"
}
export interface Behavior extends BehaviorBehaviorOneOf {
    /** Entry pass for resources, e.g. a ticket for Bookings service or a ticket for Events. */
    defaultBehavior?: EntryPass;
    /** Discount applied to paid resources */
    discount?: Discount;
}
/** @oneof */
export interface BehaviorBehaviorOneOf {
    /** Entry pass for resources, e.g. a ticket for Bookings service or a ticket for Events. */
    defaultBehavior?: EntryPass;
    /** Discount applied to paid resources */
    discount?: Discount;
}
export declare enum Event {
    Updated = "Updated",
    Deleted = "Deleted",
    Created = "Created"
}
export interface UserDomainInfoChangedEvent {
    domainName?: string;
    crudType?: CrudType;
    /** @format GUID */
    metaSiteId?: string | null;
    changeTime?: Date | null;
}
export declare enum CrudType {
    INVALID_CRUD_TYPE = "INVALID_CRUD_TYPE",
    CREATE = "CREATE",
    UPDATE = "UPDATE",
    DELETE = "DELETE",
    /** Unfortunately this action is used by hibernate save in wix-war */
    CREATE_OR_UPDATE = "CREATE_OR_UPDATE"
}
export interface HtmlSitePublished {
    /**
     * Application instance ID
     * @maxLength 50
     */
    appInstanceId?: string;
    /**
     * Application type
     * @maxLength 100
     */
    appType?: string;
    /** Revision */
    revision?: string;
    /**
     * MSID
     * @maxLength 100
     */
    metaSiteId?: string | null;
    /**
     * optional branch id if publish is done from branch
     * @format GUID
     */
    branchId?: string | null;
    /** The site's last transactionId */
    lastTransactionId?: string | null;
    /** A list of the site's pages */
    pages?: Page[];
    /** Site's publish date */
    publishDate?: string;
}
export interface Page {
    /**
     * Page's Id
     * @maxLength 100
     */
    _id?: string;
}
/** Encapsulates all details written to the Greyhound topic when a site's properties are updated. */
export interface SitePropertiesNotification {
    /** The site ID for which this update notification applies. */
    metasiteId?: string;
    /** The actual update event. */
    event?: SitePropertiesEvent;
    /**
     * A convenience set of mappings from the MetaSite ID to its constituent services.
     * @maxSize 500
     */
    translations?: Translation[];
    /** Context of the notification */
    changeContext?: ChangeContext;
}
/** The actual update event for a particular notification. */
export interface SitePropertiesEvent {
    /** Version of the site's properties represented by this update. */
    version?: number;
    /** Set of properties that were updated - corresponds to the fields in "properties". */
    fields?: string[];
    /** Updated properties. */
    properties?: Properties;
}
export interface Properties {
    /** Site categories. */
    categories?: Categories;
    /** Site locale. */
    locale?: Locale;
    /**
     * Site language.
     *
     * Two-letter language code in [ISO 639-1 alpha-2](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format.
     */
    language?: string | null;
    /**
     * Site currency format used to bill customers.
     *
     * Three-letter currency code in [ISO-4217 alphabetic](https://en.wikipedia.org/wiki/ISO_4217#Active_codes) format.
     */
    paymentCurrency?: string | null;
    /** Timezone in `America/New_York` format. */
    timeZone?: string | null;
    /** Email address. */
    email?: string | null;
    /** Phone number. */
    phone?: string | null;
    /** Fax number. */
    fax?: string | null;
    /** Address. */
    address?: V4Address;
    /** Site display name. */
    siteDisplayName?: string | null;
    /** Business name. */
    businessName?: string | null;
    /** Path to the site's logo in Wix Media (without Wix Media base URL). */
    logo?: string | null;
    /** Site description. */
    description?: string | null;
    /**
     * Business schedule. Regular and exceptional time periods when the business is open or the service is available.
     *
     * __Note:__ Not supported by Wix Bookings.
     */
    businessSchedule?: BusinessSchedule;
    /** Supported languages of a site and the primary language. */
    multilingual?: Multilingual;
    /** Cookie policy the Wix user defined for their site (before the site visitor interacts with/limits it). */
    consentPolicy?: ConsentPolicy;
    /**
     * Supported values: `FITNESS SERVICE`, `RESTAURANT`, `BLOG`, `STORE`, `EVENT`, `UNKNOWN`.
     *
     * Site business type.
     */
    businessConfig?: string | null;
    /** External site URL that uses Wix as its headless business solution. */
    externalSiteUrl?: string | null;
    /** Track clicks analytics. */
    trackClicksAnalytics?: boolean;
}
export interface Categories {
    /** Primary site category. */
    primary?: string;
    /**
     * Secondary site category.
     * @maxSize 50
     */
    secondary?: string[];
    /** Business Term Id */
    businessTermId?: string | null;
}
export interface Locale {
    /** Two-letter language code in [ISO 639-1 alpha-2](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format. */
    languageCode?: string;
    /** Two-letter country code in [ISO-3166 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2#Officially_assigned_code_elements) format. */
    country?: string;
}
export interface V4Address {
    /** Street name. */
    street?: string;
    /** City name. */
    city?: string;
    /** Two-letter country code in an [ISO-3166 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2) format. */
    country?: string;
    /** State. */
    state?: string;
    /**
     * Zip or postal code.
     * @maxLength 20
     */
    zip?: string;
    /** Extra information to be displayed in the address. */
    hint?: AddressHint;
    /** Whether this address represents a physical location. */
    isPhysical?: boolean;
    /** Google-formatted version of this address. */
    googleFormattedAddress?: string;
    /** Street number. */
    streetNumber?: string;
    /** Apartment number. */
    apartmentNumber?: string;
    /** Geographic coordinates of location. */
    coordinates?: GeoCoordinates;
}
/**
 * Extra information on displayed addresses.
 * This is used for display purposes. Used to add additional data about the address, such as "In the passage".
 * Free text. In addition, the user can state where to display the additional description - before, after, or instead of the address string.
 */
export interface AddressHint {
    /** Extra text displayed next to, or instead of, the actual address. */
    text?: string;
    /** Where the extra text should be displayed. */
    placement?: PlacementType;
}
/** Where the extra text should be displayed: before, after or instead of the actual address. */
export declare enum PlacementType {
    BEFORE = "BEFORE",
    AFTER = "AFTER",
    REPLACE = "REPLACE"
}
/** Geocoordinates for a particular address. */
export interface GeoCoordinates {
    /** Latitude of the location. Must be between -90 and 90. */
    latitude?: number;
    /** Longitude of the location. Must be between -180 and 180. */
    longitude?: number;
}
export interface Multilingual {
    /**
     * Supported languages list.
     * @maxSize 200
     */
    supportedLanguages?: SupportedLanguage[];
    /** Whether to redirect to user language. */
    autoRedirect?: boolean;
}
export interface SupportedLanguage {
    /** Two-letter language code in [ISO 639-1 alpha-2](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format. */
    languageCode?: string;
    /** Locale. */
    locale?: Locale;
    /** Whether the supported language is the primary language for the site. */
    isPrimary?: boolean;
    /** Language icon. */
    countryCode?: string;
    /** How the language will be resolved. For internal use. */
    resolutionMethod?: ResolutionMethod;
}
export declare enum ResolutionMethod {
    QUERY_PARAM = "QUERY_PARAM",
    SUBDOMAIN = "SUBDOMAIN",
    SUBDIRECTORY = "SUBDIRECTORY"
}
export interface ConsentPolicy {
    /** Whether the site uses cookies that are essential to site operation. Always `true`. */
    essential?: boolean | null;
    /** Whether the site uses cookies that affect site performance and other functional measurements. */
    functional?: boolean | null;
    /** Whether the site uses cookies that collect analytics about how the site is used (in order to improve it). */
    analytics?: boolean | null;
    /** Whether the site uses cookies that collect information allowing better customization of the experience for a current visitor. */
    advertising?: boolean | null;
    /** CCPA compliance flag. */
    dataToThirdParty?: boolean | null;
}
/** A single mapping from the MetaSite ID to a particular service. */
export interface Translation {
    /** The service type. */
    serviceType?: string;
    /** The application definition ID; this only applies to services of type ThirdPartyApps. */
    appDefId?: string;
    /** The instance ID of the service. */
    instanceId?: string;
}
export interface ChangeContext extends ChangeContextPayloadOneOf {
    /** Properties were updated. */
    propertiesChange?: PropertiesChange;
    /** Default properties were created on site creation. */
    siteCreated?: SiteCreated;
    /** Properties were cloned on site cloning. */
    siteCloned?: SiteCloned;
}
/** @oneof */
export interface ChangeContextPayloadOneOf {
    /** Properties were updated. */
    propertiesChange?: PropertiesChange;
    /** Default properties were created on site creation. */
    siteCreated?: SiteCreated;
    /** Properties were cloned on site cloning. */
    siteCloned?: SiteCloned;
}
export interface PropertiesChange {
}
export interface SiteCreated {
    /** Origin template site id. */
    originTemplateId?: string | null;
}
export interface SiteCloned {
    /** Origin site id. */
    originMetaSiteId?: string;
}
interface MediaItemNonNullableFields {
    image: string;
}
interface MediaNonNullableFields {
    items: MediaItemNonNullableFields[];
    mainMedia?: MediaItemNonNullableFields;
    coverMedia?: MediaItemNonNullableFields;
}
interface V2CategoryNonNullableFields {
    _id: string;
}
interface FormNonNullableFields {
    _id: string;
}
interface MoneyNonNullableFields {
    value: string;
    currency: string;
}
interface FixedPaymentNonNullableFields {
    price?: MoneyNonNullableFields;
    deposit?: MoneyNonNullableFields;
}
interface VariedPaymentNonNullableFields {
    defaultPrice?: MoneyNonNullableFields;
    deposit?: MoneyNonNullableFields;
    minPrice?: MoneyNonNullableFields;
    maxPrice?: MoneyNonNullableFields;
}
interface PaymentNonNullableFields {
    fixed?: FixedPaymentNonNullableFields;
    varied?: VariedPaymentNonNullableFields;
    rateType: RateType;
    pricingPlanIds: string[];
}
interface CommonStreetAddressNonNullableFields {
    number: string;
    name: string;
    apt: string;
}
interface CommonAddressNonNullableFields {
    streetAddress?: CommonStreetAddressNonNullableFields;
}
interface BusinessLocationOptionsNonNullableFields {
    _id: string;
    name: string;
    address?: CommonAddressNonNullableFields;
}
interface CustomLocationOptionsNonNullableFields {
    _id: string;
    address?: CommonAddressNonNullableFields;
}
interface V2LocationNonNullableFields {
    business?: BusinessLocationOptionsNonNullableFields;
    custom?: CustomLocationOptionsNonNullableFields;
    _id: string;
    type: LocationTypeEnumLocationType;
    calculatedAddress?: CommonAddressNonNullableFields;
}
interface PolicyDescriptionNonNullableFields {
    enabled: boolean;
    description: string;
}
interface LimitEarlyBookingPolicyNonNullableFields {
    enabled: boolean;
    earliestBookingInMinutes: number;
}
interface LimitLateBookingPolicyNonNullableFields {
    enabled: boolean;
    latestBookingInMinutes: number;
}
interface BookAfterStartPolicyNonNullableFields {
    enabled: boolean;
}
interface CancellationPolicyNonNullableFields {
    enabled: boolean;
    limitLatestCancellation: boolean;
    latestCancellationInMinutes: number;
}
interface ReschedulePolicyNonNullableFields {
    enabled: boolean;
    limitLatestReschedule: boolean;
    latestRescheduleInMinutes: number;
}
interface WaitlistPolicyNonNullableFields {
    enabled: boolean;
    capacity: number;
    reservationTimeInMinutes: number;
}
interface ParticipantsPolicyNonNullableFields {
    enabled: boolean;
    maxParticipantsPerBooking: number;
}
interface ResourcesPolicyNonNullableFields {
    enabled: boolean;
    autoAssignAllowed: boolean;
}
interface CancellationWindowNonNullableFields {
    amount?: MoneyNonNullableFields;
    percentage: string;
}
interface CancellationFeePolicyNonNullableFields {
    enabled: boolean;
    cancellationWindows: CancellationWindowNonNullableFields[];
}
interface SaveCreditCardPolicyNonNullableFields {
    enabled: boolean;
}
interface BookingPolicyNonNullableFields {
    _id: string;
    customPolicyDescription?: PolicyDescriptionNonNullableFields;
    limitEarlyBookingPolicy?: LimitEarlyBookingPolicyNonNullableFields;
    limitLateBookingPolicy?: LimitLateBookingPolicyNonNullableFields;
    bookAfterStartPolicy?: BookAfterStartPolicyNonNullableFields;
    cancellationPolicy?: CancellationPolicyNonNullableFields;
    reschedulePolicy?: ReschedulePolicyNonNullableFields;
    waitlistPolicy?: WaitlistPolicyNonNullableFields;
    participantsPolicy?: ParticipantsPolicyNonNullableFields;
    resourcesPolicy?: ResourcesPolicyNonNullableFields;
    cancellationFeePolicy?: CancellationFeePolicyNonNullableFields;
    saveCreditCardPolicy?: SaveCreditCardPolicyNonNullableFields;
}
interface DurationNonNullableFields {
    minutes: number;
}
interface V2AvailabilityConstraintsNonNullableFields {
    durations: DurationNonNullableFields[];
    sessionDurations: number[];
    timeBetweenSessions: number;
}
interface V2ScheduleNonNullableFields {
    availabilityConstraints?: V2AvailabilityConstraintsNonNullableFields;
}
interface StaffMediaItemNonNullableFields {
    image: string;
}
interface StaffMemberNonNullableFields {
    staffMemberId: string;
    workingHoursScheduleIds: string[];
    mainMedia?: StaffMediaItemNonNullableFields;
}
interface StaffMemberDetailsNonNullableFields {
    staffMembers: StaffMemberNonNullableFields[];
}
interface ResourceIdsNonNullableFields {
    values: string[];
}
interface ResourceGroupNonNullableFields {
    resourceIds?: ResourceIdsNonNullableFields;
}
interface ServiceResourceNonNullableFields {
}
interface SlugNonNullableFields {
    name: string;
}
interface URLsNonNullableFields {
    servicePage: string;
    bookingPage: string;
    calendarPage: string;
}
interface TagNonNullableFields {
    type: string;
    children: string;
    custom: boolean;
    disabled: boolean;
}
interface KeywordNonNullableFields {
    term: string;
    isMain: boolean;
}
interface SettingsNonNullableFields {
    preventAutoRedirect: boolean;
    keywords: KeywordNonNullableFields[];
}
interface SeoSchemaNonNullableFields {
    tags: TagNonNullableFields[];
    settings?: SettingsNonNullableFields;
}
export interface ServiceNonNullableFields {
    type: ServiceType;
    media?: MediaNonNullableFields;
    category?: V2CategoryNonNullableFields;
    form?: FormNonNullableFields;
    payment?: PaymentNonNullableFields;
    locations: V2LocationNonNullableFields[];
    bookingPolicy?: BookingPolicyNonNullableFields;
    schedule?: V2ScheduleNonNullableFields;
    staffMemberIds: string[];
    staffMembers: StaffMemberNonNullableFields[];
    staffMemberDetails?: StaffMemberDetailsNonNullableFields;
    resourceGroups: ResourceGroupNonNullableFields[];
    serviceResources: ServiceResourceNonNullableFields[];
    supportedSlugs: SlugNonNullableFields[];
    mainSlug?: SlugNonNullableFields;
    urls?: URLsNonNullableFields;
    seoData?: SeoSchemaNonNullableFields;
}
export interface CreateServiceResponseNonNullableFields {
    service?: ServiceNonNullableFields;
}
export interface GetServiceResponseNonNullableFields {
    service?: ServiceNonNullableFields;
}
export interface UpdateServiceResponseNonNullableFields {
    service?: ServiceNonNullableFields;
}
interface ApplicationErrorNonNullableFields {
    code: string;
    description: string;
}
interface ItemMetadataNonNullableFields {
    originalIndex: number;
    success: boolean;
    error?: ApplicationErrorNonNullableFields;
}
interface BulkServiceResultNonNullableFields {
    itemMetadata?: ItemMetadataNonNullableFields;
    item?: ServiceNonNullableFields;
}
interface BulkActionMetadataNonNullableFields {
    totalSuccesses: number;
    totalFailures: number;
    undetailedFailures: number;
}
export interface BulkUpdateServicesResponseNonNullableFields {
    results: BulkServiceResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields;
}
export interface BulkUpdateServicesByFilterResponseNonNullableFields {
    jobId: string;
}
export interface BulkDeleteServicesResponseNonNullableFields {
    results: BulkServiceResultNonNullableFields[];
    bulkActionMetadata?: BulkActionMetadataNonNullableFields;
}
export interface BulkDeleteServicesByFilterResponseNonNullableFields {
    jobId: string;
}
export interface QueryServicesResponseNonNullableFields {
    services: ServiceNonNullableFields[];
}
interface ValueAggregationResultNonNullableFields {
    value: string;
    count: number;
}
interface ValueResultsNonNullableFields {
    results: ValueAggregationResultNonNullableFields[];
}
interface RangeAggregationResultNonNullableFields {
    count: number;
}
interface RangeResultsNonNullableFields {
    results: RangeAggregationResultNonNullableFields[];
}
interface AggregationResultsScalarResultNonNullableFields {
    type: ScalarType;
    value: number;
}
interface NestedAggregationResultsNonNullableFields {
    values?: ValueResultsNonNullableFields;
    ranges?: RangeResultsNonNullableFields;
    scalar?: AggregationResultsScalarResultNonNullableFields;
    name: string;
    type: AggregationType;
    fieldPath: string;
}
interface NestedValueAggregationResultNonNullableFields {
    value: string;
    nestedResults?: NestedAggregationResultsNonNullableFields;
}
interface GroupByValueResultsNonNullableFields {
    results: NestedValueAggregationResultNonNullableFields[];
}
interface DateHistogramResultNonNullableFields {
    value: string;
    count: number;
}
interface DateHistogramResultsNonNullableFields {
    results: DateHistogramResultNonNullableFields[];
}
interface AggregationResultsNonNullableFields {
    values?: ValueResultsNonNullableFields;
    ranges?: RangeResultsNonNullableFields;
    scalar?: AggregationResultsScalarResultNonNullableFields;
    groupedByValue?: GroupByValueResultsNonNullableFields;
    dateHistogram?: DateHistogramResultsNonNullableFields;
    name: string;
    type: AggregationType;
    fieldPath: string;
}
interface AggregationDataNonNullableFields {
    results: AggregationResultsNonNullableFields[];
}
export interface SearchServicesResponseNonNullableFields {
    services: ServiceNonNullableFields[];
    aggregationData?: AggregationDataNonNullableFields;
}
interface BookingPolicyWithServicesNonNullableFields {
    bookingPolicy?: BookingPolicyNonNullableFields;
    services: ServiceNonNullableFields[];
    countOfServices: number;
    connectedServices: ServiceNonNullableFields[];
    totalServiceCount: number;
}
export interface QueryPoliciesResponseNonNullableFields {
    bookingPolicies: BookingPolicyWithServicesNonNullableFields[];
}
interface FormDetailsNonNullableFields {
    formId: string;
}
interface BookingFormNonNullableFields {
    formDetails?: FormDetailsNonNullableFields;
    totalServiceCount: number;
}
export interface QueryBookingFormsResponseNonNullableFields {
    bookingForms: BookingFormNonNullableFields[];
    defaultBookingForm?: BookingFormNonNullableFields;
}
export interface CountServicesResponseNonNullableFields {
    count: number;
}
interface BusinessLocationsNonNullableFields {
    exists: boolean;
    locations: V2LocationNonNullableFields[];
}
interface CustomLocationsNonNullableFields {
    exists: boolean;
}
interface CustomerLocationsNonNullableFields {
    exists: boolean;
}
export interface QueryLocationsResponseNonNullableFields {
    businessLocations?: BusinessLocationsNonNullableFields;
    customLocations?: CustomLocationsNonNullableFields;
    customerLocations?: CustomerLocationsNonNullableFields;
}
export interface QueryCategoriesResponseNonNullableFields {
    categories: V2CategoryNonNullableFields[];
}
export interface SetServiceLocationsResponseNonNullableFields {
    service?: ServiceNonNullableFields;
}
export interface EnablePricingPlansForServiceResponseNonNullableFields {
    service?: ServiceNonNullableFields;
}
export interface DisablePricingPlansForServiceResponseNonNullableFields {
    service?: ServiceNonNullableFields;
}
export interface SetCustomSlugResponseNonNullableFields {
    slug?: SlugNonNullableFields;
    service?: ServiceNonNullableFields;
}
export interface ValidateSlugResponseNonNullableFields {
    valid: boolean;
    errors: InvalidSlugError[];
}
export interface CloneServiceResponseNonNullableFields {
    service?: ServiceNonNullableFields;
    errors: CloneErrors[];
}
export interface BaseEventMetadata {
    /**
     * App instance ID.
     * @format GUID
     */
    instanceId?: string | null;
    /**
     * Event type.
     * @maxLength 150
     */
    eventType?: string;
    /** The identification type and identity data. */
    identity?: IdentificationData;
}
export interface EventMetadata extends BaseEventMetadata {
    /**
     * Unique event ID.
     * Allows clients to ignore duplicate webhooks.
     */
    _id?: string;
    /**
     * Assumes actions are also always typed to an entity_type
     * Example: wix.stores.catalog.product, wix.bookings.session, wix.payments.transaction
     */
    entityFqdn?: string;
    /**
     * This is top level to ease client code dispatching of messages (switch on entity_fqdn+slug)
     * This is although the created/updated/deleted notion is duplication of the oneof types
     * Example: created/updated/deleted/started/completed/email_opened
     */
    slug?: string;
    /** ID of the entity associated with the event. */
    entityId?: string;
    /** Event timestamp in [ISO-8601](https://en.wikipedia.org/wiki/ISO_8601) format and UTC time. For example: 2020-04-26T13:57:50.699Z */
    eventTime?: Date | null;
    /**
     * Whether the event was triggered as a result of a privacy regulation application
     * (for example, GDPR).
     */
    triggeredByAnonymizeRequest?: boolean | null;
    /** If present, indicates the action that triggered the event. */
    originatedFrom?: string | null;
    /**
     * A sequence number defining the order of updates to the underlying entity.
     * For example, given that some entity was updated at 16:00 and than again at 16:01,
     * it is guaranteed that the sequence number of the second update is strictly higher than the first.
     * As the consumer, you can use this value to ensure that you handle messages in the correct order.
     * To do so, you will need to persist this number on your end, and compare the sequence number from the
     * message against the one you have stored. Given that the stored number is higher, you should ignore the message.
     */
    entityEventSequence?: string | null;
}
export interface ServiceCreatedEnvelope {
    entity: Service;
    metadata: EventMetadata;
}
/**
 * Triggered when a service is created.
 * @permissionScope Read Bookings - Public Data
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-PUBLIC
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Read Bookings - Including Participants
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-SENSITIVE
 * @permissionScope Read Bookings - all read permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.READ-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @permissionId BOOKINGS.SERVICES_READ
 * @webhook
 * @eventType wix.bookings.services.v2.service_created
 * @slug created
 */
export declare function onServiceCreated(handler: (event: ServiceCreatedEnvelope) => void | Promise<void>): void;
export interface ServiceDeletedEnvelope {
    entity: Service;
    metadata: EventMetadata;
}
/**
 * Triggered when a service is deleted.
 * @permissionScope Read Bookings - Public Data
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-PUBLIC
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Read Bookings - Including Participants
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-SENSITIVE
 * @permissionScope Read Bookings - all read permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.READ-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @permissionId BOOKINGS.SERVICES_READ
 * @webhook
 * @eventType wix.bookings.services.v2.service_deleted
 * @slug deleted
 */
export declare function onServiceDeleted(handler: (event: ServiceDeletedEnvelope) => void | Promise<void>): void;
export interface ServiceUpdatedEnvelope {
    entity: Service;
    metadata: EventMetadata;
}
/**
 * Triggered when a service is updated.
 * @permissionScope Read Bookings - Public Data
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-PUBLIC
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Read Bookings - Including Participants
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-SENSITIVE
 * @permissionScope Read Bookings - all read permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.READ-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @permissionId BOOKINGS.SERVICES_READ
 * @webhook
 * @eventType wix.bookings.services.v2.service_updated
 * @slug updated
 */
export declare function onServiceUpdated(handler: (event: ServiceUpdatedEnvelope) => void | Promise<void>): void;
/**
 * Creates a service.
 *
 *
 * ## Required fields
 *
 * When creating a service you must specify the following fields:
 * - `type`
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/services/about-service-types) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/services-v2/about-service-types)):
 * Whether it's an appointment-based service, class, or course.
 * - `name`: Service name that's displayed to customers.
 * - `onlineBooking`:
 * Settings determining whether customers can book online, whether the business
 * must manually confirm bookings, and whether customers can request to book an
 * appointment time slot that already has a booking request awaiting business
 * confirmation.
 * - `payment`
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/services/about-service-payments) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/services-v2/about-service-payments)):
 * How customers can pay when signing up for the service.
 *
 * ### Session durations
 *
 * Depending on which type of service you're creating, you may also need to specify
 * supported session durations.
 *
 * __Classes and courses__
 *
 * Don't specify `schedule.availabilityConstraints.sessionDurations`.
 *
 * __Appointment-based services without varied pricing based on session length__
 *
 * Specify the single supported session duration in the
 * `schedule.availabilityConstraints.sessionDurations` array.
 *
 * __Appointment-based services with varied pricing based on session length__
 *
 * - Specify all supported session durations in `schedule.availabilityConstraints.sessionDurations`.
 * - Note that Wix Bookings doesn't display these values to customers and
 * ignores them in pricing and availability calculations. Instead session
 * durations are retrieved from the relevant service *variants*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/service-options-and-variants/introduction) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/service-options-and-variants/introduction)).
 * - It is mandatory to specify `schedule.availabilityConstraints.sessionDurations`,
 * even though these values are ignored.
 * @param service - Service to create.
 * @public
 * @requiredField service
 * @permissionId BOOKINGS.SERVICES_CREATE
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @returns Created service.
 * @fqn wix.bookings.services.v2.ServicesService.CreateService
 */
export declare function createService(service: Service): Promise<Service & ServiceNonNullableFields>;
/**
 * Retrieves a service.
 * @param serviceId - ID of the service to retrieve.
 * @public
 * @requiredField serviceId
 * @permissionId BOOKINGS.SERVICES_READ
 * @permissionScope Read Bookings - Public Data
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-PUBLIC
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Read Bookings - Including Participants
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-SENSITIVE
 * @permissionScope Read Bookings - all read permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.READ-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @applicableIdentity VISITOR
 * @returns Retrieved service.
 * @fqn wix.bookings.services.v2.ServicesService.GetService
 */
export declare function getService(serviceId: string): Promise<Service & ServiceNonNullableFields>;
/**
 * Updates a service.
 *
 *
 * Each time the service is updated, `revision` increments by 1. You must
 * include the number of the existing revision when updating the service.
 * This ensures you're working with the latest service information and
 * prevents unintended overwrites.
 *
 * ## Session durations
 *
 * Specify `schedule.availabilityConstraints.sessionDurations`
 * only if you want to update it for appointment-based services without varied
 * pricing based on session length. Don't specify `schedule.availabilityConstraints.sessionDurations`
 * for all other appointment-based services, classes, or courses. See *Create Service*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/services/create-service#session-durations) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/services-v2/create-service#session-durations))
 * for more details.
 * @param _id - Service ID.
 * @public
 * @requiredField _id
 * @requiredField service
 * @requiredField service.revision
 * @permissionId BOOKINGS.SERVICES_UPDATE
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @returns Updated service.
 * @fqn wix.bookings.services.v2.ServicesService.UpdateService
 */
export declare function updateService(_id: string | null, service: UpdateService): Promise<Service & ServiceNonNullableFields>;
export interface UpdateService {
    /**
     * Service ID.
     * @format GUID
     * @readonly
     */
    _id?: string | null;
    /**
     * Service type.
     * Learn more about *service types*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/services/about-service-types) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/services-v2/about-service-types)).
     */
    type?: ServiceType;
    /**
     * Order of the service within a *category*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/categories/setup) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/categories-v1/category-object)).
     */
    sortOrder?: number | null;
    /**
     * Service name.
     * @maxLength 400
     * @minLength 1
     */
    name?: string | null;
    /**
     * Service description. For example, `High-class hair styling, cuts, straightening and color`.
     * @maxLength 7000
     */
    description?: string | null;
    /**
     * Short service description, such as `Hair styling`.
     * @maxLength 6000
     */
    tagLine?: string | null;
    /**
     * Default maximum number of customers that can book the service. The service cannot be booked beyond this capacity.
     * @min 1
     * @max 1000
     */
    defaultCapacity?: number | null;
    /** Media associated with the service. */
    media?: Media;
    /** Whether the service is hidden from the site. */
    hidden?: boolean | null;
    /**
     * _Category_
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/categories/setup) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/categories-v1/category-object))
     * the service is associated with.
     */
    category?: V2Category;
    /** Form the customer filled out when booking the service. */
    form?: Form;
    /**
     * Payment options for booking the service.
     * Learn more about *service payments*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/services/about-service-payments) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/services-v2/about-service-payments)).
     */
    payment?: Payment;
    /** Online booking settings. */
    onlineBooking?: OnlineBooking;
    /** Conferencing options for the service. */
    conferencing?: Conferencing;
    /**
     * The locations this service is offered at. Read more about *service locations*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/services/about-service-locations) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/services-v2/about-service-locations)).
     * @immutable
     * @maxSize 500
     */
    locations?: V2Location[];
    /**
     * _Policy_
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/booking-policies/introduction) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/policies/booking-policies/introduction))
     * determining under what conditions this service can be booked. For example, whether the service can only be booked up to 30 minutes before it begins.
     */
    bookingPolicy?: BookingPolicy;
    /**
     * The service's *schedule*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/calendar/schedules/introduction) | [REST](https://dev.wix.com/docs/rest/business-management/calendar/schedules-v3/introduction)),
     * which can be used to manage the service's *events*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/calendar/events/introduction) | [REST](https://dev.wix.com/docs/rest/business-management/calendar/events-v3/introduction)).
     */
    schedule?: V2Schedule;
    /**
     * IDs of the *staff members*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/staff-members/introduction) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/staff-members/introduction))
     * providing the service. Available only for appointment-based services.
     * @maxSize 220
     * @format GUID
     */
    staffMemberIds?: string[];
    /**
     * Information about which resources must be available so customers can book the service.
     * For example, a meeting room or equipment.
     * @maxSize 3
     */
    serviceResources?: ServiceResource[];
    /**
     * A slug is the last part of the URL address that serves as a unique identifier of the service.
     * The list of supported slugs includes past service names for backwards compatibility, and a custom slug if one was set by the business owner.
     * @readonly
     * @maxSize 100
     */
    supportedSlugs?: Slug[];
    /**
     * Active slug for the service.
     * Learn more about *service slugs*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/services/about-service-slugs) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/services-v2/about-service-slugs)).
     * @readonly
     */
    mainSlug?: Slug;
    /**
     * URLs to various service-related pages, such as the calendar page and the booking page.
     * @readonly
     */
    urls?: URLs;
    /** Extensions enabling users to save custom data related to the service. */
    extendedFields?: ExtendedFields;
    /** Custom SEO data for the service. */
    seoData?: SeoSchema;
    /**
     * Date and time the service was created in `YYYY-MM-DDThh:mm:ss.sssZ` format.
     * @readonly
     */
    _createdDate?: Date | null;
    /**
     * Date and time the service was updated in `YYYY-MM-DDThh:mm:ss.sssZ` format.
     * @readonly
     */
    _updatedDate?: Date | null;
    /**
     * Revision number, which increments by 1 each time the service is updated. To
     * prevent conflicting changes, the existing revision must be used when updating
     * a service.
     * @readonly
     */
    revision?: string | null;
}
/**
 * Updates up to 100 services.
 *
 *
 * See *Update Service*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/services/update-service) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/services-v2/update-service))
 * for more details.
 *
 * The call succeeds even if one or more individual services can't be updated.
 * Information about failures is returned in `bulkActionMetadata`.
 * @public
 * @requiredField options.services.service
 * @requiredField options.services.service._id
 * @requiredField options.services.service.revision
 * @permissionId BOOKINGS.SERVICES_UPDATE
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @fqn wix.bookings.services.v2.ServicesService.BulkUpdateServices
 */
export declare function bulkUpdateServices(options?: BulkUpdateServicesOptions): Promise<BulkUpdateServicesResponse & BulkUpdateServicesResponseNonNullableFields>;
export interface BulkUpdateServicesOptions {
    /**
     * Services to update.
     * @maxSize 100
     */
    services?: MaskedService[];
    /** Whether to include the updated services in the response. Default: `false` */
    returnEntity?: boolean;
}
/**
 * Updates multiple services by filter.
 *
 *
 * Refer to the supported filters article
 * ([REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/services-v2/filtering-and-sorting#filtering))
 * for more details.
 *
 * See *Update Service*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/services/update-service) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/services-v2/update-service))
 * for more details about updating a service.
 *
 * The call succeeds even if one or more individual services can't be updated.
 * Information about failures is returned in `bulkActionMetadata`.
 * @param filter - Filter to identify the services to update.
 * @public
 * @requiredField filter
 * @requiredField options
 * @requiredField options.service
 * @permissionId BOOKINGS.SERVICES_UPDATE
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @fqn wix.bookings.services.v2.ServicesService.BulkUpdateServicesByFilter
 */
export declare function bulkUpdateServicesByFilter(filter: Record<string, any> | null, options: BulkUpdateServicesByFilterOptions): Promise<BulkUpdateServicesByFilterResponse & BulkUpdateServicesByFilterResponseNonNullableFields>;
export interface BulkUpdateServicesByFilterOptions {
    /** Service to update. */
    service: Service;
}
/**
 * Deletes a service.
 *
 *
 * Specify `{"preserveFutureSessionsWithParticipants": true}` to retain all
 * future sessions for the service. By default, all future sessions are canceled.
 * @param serviceId - ID of the service to delete.
 * @public
 * @requiredField serviceId
 * @param options - Allows you to configure how to handle the deleted service's future sessions and how to notify the sessions participants.
 * @permissionId BOOKINGS.SERVICES_DELETE
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @fqn wix.bookings.services.v2.ServicesService.DeleteService
 */
export declare function deleteService(serviceId: string, options?: DeleteServiceOptions): Promise<void>;
export interface DeleteServiceOptions {
    /**
     * Whether to preserve future sessions with participants.
     *
     * Default: `false`
     */
    preserveFutureSessionsWithParticipants?: boolean;
    /**
     * Whether to notify participants about the change and an optional
     * custom message.
     */
    participantNotification?: V2ParticipantNotification;
}
/**
 * Deletes multiple services.
 *
 *
 * See *Delete Service*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/services/delete-service) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/services-v2/delete-service))
 * for more details about deleting a service.
 *
 * The call succeeds even if one or more individual services can't be deleted.
 * Information about failures is returned in `bulkActionMetadata`.
 * @param ids - IDs of the services to delete.
 * @public
 * @requiredField ids
 * @permissionId BOOKINGS.SERVICES_DELETE
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @fqn wix.bookings.services.v2.ServicesService.BulkDeleteServices
 */
export declare function bulkDeleteServices(ids: string[], options?: BulkDeleteServicesOptions): Promise<BulkDeleteServicesResponse & BulkDeleteServicesResponseNonNullableFields>;
export interface BulkDeleteServicesOptions {
    /**
     * Whether to preserve future sessions with participants.
     *
     * Default: `false`.
     */
    preserveFutureSessionsWithParticipants?: boolean;
    /**
     * Whether to notify participants about the change and an optional
     * custom message.
     */
    participantNotification?: V2ParticipantNotification;
}
/**
 * Deletes multiple services by filter.
 *
 *
 * See *Delete Service*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/services/delete-service) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/services-v2/delete-service))
 * for more details about deleting a service.
 *
 * The call succeeds even if one or more individual services can't be deleted.
 * Information about failures is returned in `bulkActionMetadata`.
 *
 * Refer to the supported filters article
 * ([REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/services-v2/filtering-and-sorting#filtering))
 * for more details.
 *
 * To learn about working with filters in general, see
 * [API Query Language](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#filters).
 * @param filter - Filter to identify the services that need to be deleted.
 * @public
 * @requiredField filter
 * @permissionId BOOKINGS.SERVICES_DELETE
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @fqn wix.bookings.services.v2.ServicesService.BulkDeleteServicesByFilter
 */
export declare function bulkDeleteServicesByFilter(filter: Record<string, any> | null, options?: BulkDeleteServicesByFilterOptions): Promise<BulkDeleteServicesByFilterResponse & BulkDeleteServicesByFilterResponseNonNullableFields>;
export interface BulkDeleteServicesByFilterOptions {
    /**
     * Whether to preserve future sessions with participants.
     *
     * Default: `false`.
     */
    preserveFutureSessionsWithParticipants?: boolean;
    /** Whether to notify participants about the change and an optional custom message. */
    participantNotification?: V2ParticipantNotification;
}
/**
 * Creates a query to retrieve a list of `service` objects.
 *
 * The `queryServices()` function builds a query to retrieve a list of `service` objects and returns a `ServicesQueryBuilder` object.
 *
 * The returned object contains the query definition, which is typically used to run the query using the [find()](https://dev.wix.com/docs/sdk/backend-modules/bookings/services/services-query-builder/find) function.
 *
 * You can refine the query by chaining `ServicesQueryBuilder` functions onto the query. `ServicesQueryBuilder` functions enable you to sort, filter, and control the results that `queryServices()` returns.
 *
 * `queryServices()` runs with the following `ServicesQueryBuilder` defaults that you can override:
 *
 * + `limit` is `100`.
 * + Sorted by `createdDate` in ascending order.
 *
 * The functions that are chained to `queryServices()` are applied in the order they are called. For example, if you apply `ascending("category.name")` and then `ascending("name")`, the results are sorted first by `category.name`, and then, if there are multiple results with the same `category.name`, the items are sorted by `name`.
 *
 * The following `ServicesQueryBuilder` functions are supported for the `queryServices()` function. For a full description of the `service` object, see the object returned for the [items](https://dev.wix.com/docs/sdk/backend-modules/bookings/services/services-query-result/items) property in `ServicesQueryResult`.
 * @public
 * @permissionScope Read Bookings - Public Data
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-PUBLIC
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Read Bookings - Including Participants
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-SENSITIVE
 * @permissionScope Read Bookings - all read permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.READ-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @permissionId BOOKINGS.SERVICES_READ
 * @applicableIdentity APP
 * @applicableIdentity VISITOR
 * @fqn wix.bookings.services.v2.ServicesService.QueryServices
 */
export declare function queryServices(options?: QueryServicesOptions): ServicesQueryBuilder;
export interface QueryServicesOptions {
}
interface QueryOffsetResult {
    currentPage: number | undefined;
    totalPages: number | undefined;
    totalCount: number | undefined;
    hasNext: () => boolean;
    hasPrev: () => boolean;
    length: number;
    pageSize: number;
}
export interface ServicesQueryResult extends QueryOffsetResult {
    items: Service[];
    query: ServicesQueryBuilder;
    next: () => Promise<ServicesQueryResult>;
    prev: () => Promise<ServicesQueryResult>;
}
export interface ServicesQueryBuilder {
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    eq: (propertyName: '_id' | 'type' | 'name' | 'description' | 'tagLine' | 'hidden' | 'category.id' | 'category.name' | 'form.id' | 'payment.options.online' | 'payment.options.inPerson' | 'payment.options.pricingPlan' | 'onlineBooking.enabled' | 'locations.business.id' | 'schedule.firstSessionStart' | 'schedule.lastSessionEnd' | 'staffMemberIds' | 'supportedSlugs.name' | 'mainSlug.name', value: any) => ServicesQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    ne: (propertyName: '_id' | 'type' | 'name' | 'description' | 'tagLine' | 'hidden' | 'category.id' | 'category.name' | 'form.id' | 'payment.options.online' | 'payment.options.inPerson' | 'payment.options.pricingPlan' | 'onlineBooking.enabled' | 'locations.business.id' | 'schedule.firstSessionStart' | 'schedule.lastSessionEnd' | 'staffMemberIds' | 'supportedSlugs.name' | 'mainSlug.name', value: any) => ServicesQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    ge: (propertyName: 'schedule.firstSessionStart' | 'schedule.lastSessionEnd', value: any) => ServicesQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    gt: (propertyName: 'schedule.firstSessionStart' | 'schedule.lastSessionEnd', value: any) => ServicesQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    le: (propertyName: 'schedule.firstSessionStart' | 'schedule.lastSessionEnd', value: any) => ServicesQueryBuilder;
    /** @param propertyName - Property whose value is compared with `value`.
     * @param value - Value to compare against.
     */
    lt: (propertyName: 'schedule.firstSessionStart' | 'schedule.lastSessionEnd', value: any) => ServicesQueryBuilder;
    /** @param propertyName - Property whose value is compared with `string`.
     * @param string - String to compare against. Case-insensitive.
     */
    startsWith: (propertyName: '_id' | 'name' | 'description' | 'tagLine' | 'category.id' | 'category.name' | 'form.id' | 'locations.business.id' | 'supportedSlugs.name' | 'mainSlug.name', value: string) => ServicesQueryBuilder;
    /** @param propertyName - Property whose value is compared with `values`.
     * @param values - List of values to compare against.
     */
    hasSome: (propertyName: '_id' | 'type' | 'name' | 'description' | 'tagLine' | 'hidden' | 'category.id' | 'category.name' | 'form.id' | 'payment.options.online' | 'payment.options.inPerson' | 'payment.options.pricingPlan' | 'onlineBooking.enabled' | 'locations.business.id' | 'schedule.firstSessionStart' | 'schedule.lastSessionEnd' | 'staffMemberIds' | 'supportedSlugs.name' | 'mainSlug.name', value: any[]) => ServicesQueryBuilder;
    /** @param propertyName - Property whose value is compared with `values`.
     * @param values - List of values to compare against.
     */
    hasAll: (propertyName: 'staffMemberIds', value: any[]) => ServicesQueryBuilder;
    in: (propertyName: '_id' | 'type' | 'name' | 'description' | 'tagLine' | 'hidden' | 'category.id' | 'category.name' | 'form.id' | 'payment.options.online' | 'payment.options.inPerson' | 'payment.options.pricingPlan' | 'onlineBooking.enabled' | 'locations.business.id' | 'schedule.firstSessionStart' | 'schedule.lastSessionEnd' | 'staffMemberIds' | 'supportedSlugs.name' | 'mainSlug.name', value: any) => ServicesQueryBuilder;
    exists: (propertyName: '_id' | 'type' | 'name' | 'description' | 'tagLine' | 'hidden' | 'category.id' | 'category.name' | 'form.id' | 'payment.options.online' | 'payment.options.inPerson' | 'payment.options.pricingPlan' | 'onlineBooking.enabled' | 'locations.business.id' | 'schedule.firstSessionStart' | 'schedule.lastSessionEnd' | 'staffMemberIds' | 'supportedSlugs.name' | 'mainSlug.name', value: boolean) => ServicesQueryBuilder;
    /** @param limit - Number of items to return, which is also the `pageSize` of the results object. */
    limit: (limit: number) => ServicesQueryBuilder;
    /** @param skip - Number of items to skip in the query results before returning the results. */
    skip: (skip: number) => ServicesQueryBuilder;
    find: () => Promise<ServicesQueryResult>;
}
/**
 * Retrieves a list of up to 100 services, given the provided filtering, paging,
 * and sorting.
 *
 *
 * ## Defaults
 *
 * Search Services has the following default settings, which you can override:
 * + Sorted by `createdDate` in ascending order.
 * + `paging.limit` set to `100`.
 * + `paging.offset` set to `0`.
 *
 * ## Filters
 *
 * When using filters for dates, you must use
 * [UTC time](https://en.wikipedia.org/wiki/Coordinated_Universal_Time).
 *
 * Refer to the supported filters article
 * ([REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/services-v2/filtering-and-sorting))
 * for a complete list of supported filters and sorting options.
 *
 * ## See also
 *
 * To learn about working with *Search* methods, see
 * _API Query Language_
 * ([SDK](https://dev.wix.com/docs/sdk/articles/work-with-the-sdk/api-query-language) | [REST](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language))
 * and *Sorting and Paging*
 * ([SDK](https://dev.wix.com/docs/sdk/articles/work-with-the-sdk/api-query-language#the-sort-array) | [REST](https://dev.wix.com/docs/rest/articles/getting-started/sorting-and-paging)).
 * @param search - WQL, search or aggregation expression.
 * @public
 * @documentationMaturity preview
 * @requiredField search
 * @permissionId BOOKINGS.SERVICES_READ
 * @permissionScope Read Bookings - Public Data
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-PUBLIC
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Read Bookings - Including Participants
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-SENSITIVE
 * @permissionScope Read Bookings - all read permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.READ-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @applicableIdentity VISITOR
 * @fqn wix.bookings.services.v2.ServicesService.SearchServices
 */
export declare function searchServices(search: CursorSearch): Promise<SearchServicesResponse & SearchServicesResponseNonNullableFields>;
/**
 * Retrieves a list of up to 100 *booking policies*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/booking-policies/introduction) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/policies/booking-policies/introduction)),
 * and information about the services that are connected to them,
 * given the provided filtering, paging, and sorting.
 *
 * ## Defaults
 *
 * Query Policies has the following default settings, which you can override:
 *
 * + Sorted by `id` in ascending order.
 * + `cursorPaging.limit` set to `100`.
 *
 * ## Filters
 *
 * For a complete list of supported filters, refer to **Booking Policies API: Supported Filters**
 * ([REST](https://dev.wix.com/docs/rest/business-solutions/bookings/policies/booking-policies/supported-filters)).
 *
 * When using date filters, you must use
 * [UTC time](https://en.wikipedia.org/wiki/Coordinated_Universal_Time).
 *
 * ## Returned services
 *
 * If a booking policy is connected to more than 5 services, only a subset of
 * those services is returned. The `bookingPolicies.totalServiceCount` values
 * indicate the total number of services linked to each policy. You can call *Search Services*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/services/search-services) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/services-v2/search-services))
 * and specify the relevant policy ID in the filter to retrieve all services
 * connected to the booking policy.
 *
 * ## See also
 *
 * To learn about working with *Query* endpoints, see
 * [API Query Language](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language)
 * and [Sorting and Paging](https://dev.wix.com/docs/rest/articles/getting-started/sorting-and-paging).
 * @param query - Information about filters, paging, and sorting. See the article about
 * booking policy filters
 * ([REST](https://dev.wix.com/docs/rest/business-solutions/bookings/policies/booking-policies/supported-filters))
 * for all supported filters and sorting options.
 * @public
 * @documentationMaturity preview
 * @requiredField query
 * @permissionId BOOKINGS.BOOKING_POLICY_READ
 * @permissionId BOOKINGS.SERVICES_READ
 * @permissionScope Read Bookings - Public Data
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-PUBLIC
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Read Bookings - Including Participants
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-SENSITIVE
 * @permissionScope Read Bookings - all read permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.READ-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @permissionScope Read Bookings - Public Data
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-PUBLIC
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Read Bookings - Including Participants
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-SENSITIVE
 * @permissionScope Read Bookings - all read permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.READ-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @applicableIdentity VISITOR
 * @fqn wix.bookings.services.v2.ServicesService.QueryPolicies
 */
export declare function queryPolicies(query: CursorQuery): Promise<QueryPoliciesResponse & QueryPoliciesResponseNonNullableFields>;
/**
 * Retrieves a list of up to 100 *booking forms*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/forms/forms/introduction) | [REST](https://dev.wix.com/docs/rest/crm/forms/forms/introduction)),
 * and information about the services that are connected to them,
 * given the provided filtering, paging, and sorting.
 *
 *
 * ## Defaults
 *
 * Query Booking Forms has the following default settings, which you can override:
 *
 * + Sorted by `id` in ascending order.
 * + `cursorPaging.limit` set to `100`.
 *
 * ## Filters
 *
 * For a complete list of supported filters, refer to **Forms API: Supported Filters**
 * ([REST](https://dev.wix.com/docs/rest/crm/forms/forms/introduction/supported-filters)).
 *
 * When using date filters, you must use
 * [UTC time](https://en.wikipedia.org/wiki/Coordinated_Universal_Time).
 *
 * ## Returned services
 *
 * If a booking policy is connected to more than 5 services, only a subset of
 * these service IDs and names is returned. The `bookingForms.totalServiceCount`
 * values indicate the total number of services linked to each form. You can call *Query Services*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/services/query-services) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/services-v2/query-services))
 * and specify the relevant form ID in the filter to retrieve all services
 * connected to the booking form.
 *
 * ## Default booking forms
 *
 * By default, all Wix Bookings services use a standard booking form. To retrieve
 * a site's default booking form with Query Booking Forms, specify
 * `{"conditionalFields": ["DEFAULT_BOOKING_FORM"]}`.
 *
 * ## See also
 *
 * To learn about working with *Query* endpoints, see
 * [API Query Language](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language)
 * and [Sorting and Paging](https://dev.wix.com/docs/rest/articles/getting-started/sorting-and-paging).
 * @param query - Information about filters, paging, and sorting. See the article about
 * form filters ([REST](https://dev.wix.com/docs/rest/crm/forms/forms/introduction/supported-filters))
 * for all supported filters and sorting options.
 * @public
 * @requiredField query
 * @permissionId BOOKINGS.SERVICE_BOOKING_FORMS_READ
 * @permissionId BOOKINGS.SERVICES_READ
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @permissionScope Read Bookings - Public Data
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-PUBLIC
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Read Bookings - Including Participants
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-SENSITIVE
 * @permissionScope Read Bookings - all read permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.READ-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @applicableIdentity VISITOR
 * @fqn wix.bookings.services.v2.ServicesService.QueryBookingForms
 */
export declare function queryBookingForms(query: CursorQuery, options?: QueryBookingFormsOptions): Promise<QueryBookingFormsResponse & QueryBookingFormsResponseNonNullableFields>;
export interface QueryBookingFormsOptions {
    /**
     * Conditional fields to return.
     * @maxSize 1
     */
    conditionalFields?: RequestedFields[];
}
/**
 * Counts how many services match the given filter.
 *
 *
 * Refer to the supported filters article
 * ([REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/services-v2/filtering-and-sorting#filtering))
 * for more details.
 *
 * To learn about working with filters in general, see
 * [API Query Language](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language#filters)
 * @public
 * @permissionId BOOKINGS.SERVICES_COUNT
 * @permissionScope Read Bookings - Public Data
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-PUBLIC
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Read Bookings - Including Participants
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-SENSITIVE
 * @permissionScope Read Bookings - all read permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.READ-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @applicableIdentity VISITOR
 * @fqn wix.bookings.services.v2.ServicesService.CountServices
 */
export declare function countServices(options?: CountServicesOptions): Promise<CountServicesResponse & CountServicesResponseNonNullableFields>;
export interface CountServicesOptions {
    /**
     * Query filter to base the count on. See supported filters
     * ([REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/services-v2/filtering-and-sorting#filtering))
     * for more details.
     */
    filter?: Record<string, any> | null;
}
/**
 * Retrieves 3 separate lists of business, custom, and customer *locations*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/business-tools/locations/introduction) | [REST](https://dev.wix.com/docs/rest/business-management/locations/introduction)),
 * given the provided filtering, and whether each location is connected to at
 * least one of the site's services.
 *
 *
 * ## Defaults
 *
 * Query Locations has the following default setting, which you can't override:
 * Sorted by `id` in ascending order.
 *
 * ## Filters
 *
 * For a complete list of supported filters, refer to the `location` object
 * ([REST](https://dev.wix.com/docs/rest/business-management/locations/location-object)).
 *
 * When using date filters, you must use
 * [UTC time](https://en.wikipedia.org/wiki/Coordinated_Universal_Time).
 *
 * ## See also
 *
 * To learn about working with *Query* endpoints, see
 * [API Query Language](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language)
 * and [Sorting and Paging](https://dev.wix.com/docs/rest/articles/getting-started/sorting-and-paging).
 * @public
 * @documentationMaturity preview
 * @permissionId BOOKINGS.SERVICES_READ
 * @permissionScope Read Bookings - Public Data
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-PUBLIC
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Read Bookings - Including Participants
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-SENSITIVE
 * @permissionScope Read Bookings - all read permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.READ-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @applicableIdentity VISITOR
 * @fqn wix.bookings.services.v2.ServicesService.QueryLocations
 */
export declare function queryLocations(options?: QueryLocationsOptions): Promise<QueryLocationsResponse & QueryLocationsResponseNonNullableFields>;
export interface QueryLocationsOptions {
    /** Filter. */
    filter?: QueryLocationsFilter;
}
/**
 * Retrieves a list of service *categories*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/categories/setup) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/categories-v2/introduction)),
 * given the provided filtering.
 *
 *
 * ## Defaults
 *
 * Query Categories has the following default setting, which you can't override:
 * Sorted by `id` in ascending order.
 *
 * ## Filters
 *
 * For a complete list of supported filters, refer to the supported filters article
 * ([REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/services-v2/filtering-and-sorting#filtering)).
 *
 * When using date filters, you must use
 * [UTC time](https://en.wikipedia.org/wiki/Coordinated_Universal_Time).
 *
 * ## See also
 *
 * To learn about working with *Query* endpoints, see
 * [API Query Language](https://dev.wix.com/docs/rest/articles/getting-started/api-query-language)
 * and [Sorting and Paging](https://dev.wix.com/docs/rest/articles/getting-started/sorting-and-paging).
 * @public
 * @documentationMaturity preview
 * @permissionId BOOKINGS.SERVICES_READ
 * @permissionScope Read Bookings - Public Data
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-PUBLIC
 * @permissionScope Manage Bookings Services and Settings
 * @permissionScopeId SCOPE.BOOKINGS.CONFIGURATION
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Read Bookings - Including Participants
 * @permissionScopeId SCOPE.DC-BOOKINGS.READ-BOOKINGS-SENSITIVE
 * @permissionScope Read Bookings - all read permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.READ-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @applicableIdentity VISITOR
 * @fqn wix.bookings.services.v2.ServicesService.QueryCategories
 */
export declare function queryCategories(options?: QueryCategoriesOptions): Promise<QueryCategoriesResponse & QueryCategoriesResponseNonNullableFields>;
export interface QueryCategoriesOptions {
    /** Filter. */
    filter?: QueryCategoriesFilter;
}
/**
 * Replaces the list of the *locations*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/business-tools/locations/introduction) | [REST](https://dev.wix.com/docs/rest/business-management/locations/introduction))
 * where the business offers the service.
 *
 *
 * ## Consequences for customers
 *
 * Removing a service location may impact existing sessions and their
 * participants. If you remove at least one service location, you must
 * specify `removedLocationSessionsAction` to indicate what happens to all
 * future sessions scheduled at this location.
 *
 * - **Keep existing location**: If you want to retain future sessions at their
 * originally scheduled location, specify
 * `{"removedLocationSessionsAction.action": "KEEP_AT_CURRENT_LOCATION"}`.
 * This ensures nothing changes for the customer, but the business must be
 * able to provide access to the removed location in the future.
 * - **Update location**: If you want to update the location for future sessions
 * scheduled at the removed location, specify
 * `{"removedLocationSessionsAction.action": "MOVE_TO_LOCATION"}` and
 * `moveToLocationOptions.newLocation`.
 *
 * You can't mix and match to keep some sessions at the previous location while
 * moving other sessions to an updated location.
 *
 * Past session details aren't changed, no matter which option you choose for
 * future sessions.
 *
 * Future sessions scheduled for a location defined by the customer are also not
 * updated.
 *
 * ## Specify location details
 *
 * Depending on whether the new or updated location is a business or custom location,
 * you need to specify different fields.
 *
 * - **Business location**: Specify the relevant *location ID*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/business-tools/locations/introduction) | [REST](https://dev.wix.com/docs/rest/business-management/locations/introduction))
 * in `locations.business.id`.
 * - **Custom location**: Specify the complete address object as
 * `locations.custom.address`.
 *
 * ## Participant notifications
 *
 * You can specify a `participantNotification.message` that's immediately send
 * to all customers who had booked at a changed location. Ensure
 * `participantNotification.notifyParticipants` is set to `true` to send the
 * message.
 * @param serviceId - ID of the service.
 * @param locations - List of locations replacing existing service locations. Omitting an existing location removes it from the service. Specify `removedLocationSessionsAction` to determine the handling of future sessions scheduled at that location.
 * @public
 * @documentationMaturity preview
 * @requiredField locations
 * @requiredField serviceId
 * @permissionId BOOKINGS.SERVICES_LOCATIONS_SET
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @fqn wix.bookings.services.v2.ServicesService.SetServiceLocations
 */
export declare function setServiceLocations(serviceId: string, locations: V2Location[], options?: SetServiceLocationsOptions): Promise<SetServiceLocationsResponse & SetServiceLocationsResponseNonNullableFields>;
export interface SetServiceLocationsOptions {
    /**
     * The action to perform on sessions currently set to a removed location. For
     * example, move existing sessions to a new specified location.
     * If not specified, sessions will not be moved to a new location.
     */
    removedLocationSessionsAction?: RemovedLocationSessionsAction;
    /**
     * Whether to notify participants about the change of location, and an
     * Optional custom message. The notification is sent only to participants of sessions that are affected by the change.
     */
    participantNotification?: V2ParticipantNotification;
}
/**
 * Adds a list of *pricing plan IDs*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/pricing-plans/plans/introduction) | [REST](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/plans/plan-object))
 * to a service's `payment.pricingPlanIds` array.
 *
 *
 * The call doesn't validate whether the service's `payment.options.pricingPlan`
 * is set to `true`. If it's set to `false`, customers aren't able to pay
 * for their bookings using pricing plans. You can call *Update Service*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/services/update-service) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/services-v2/update-service))
 * to change a service's supported payment methods.
 * @param serviceId - ID of the service to update.
 * @param pricingPlanIds - IDs of the *pricing plans*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/pricing-plans/plans/introduction) | [REST](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/plans/plan-object))
 * to add to the service's `payment.pricingPlanIds` array.
 * @public
 * @requiredField pricingPlanIds
 * @requiredField serviceId
 * @permissionId BOOKINGS.SERVICES_PRICING_PLANS_ADD
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @fqn wix.bookings.services.v2.ServicesService.EnablePricingPlansForService
 */
export declare function enablePricingPlansForService(serviceId: string, pricingPlanIds: string[]): Promise<EnablePricingPlansForServiceResponse & EnablePricingPlansForServiceResponseNonNullableFields>;
/**
 * Removes a list of *pricing plan IDs*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/pricing-plans/plans/introduction) | [REST](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/plans/plan-object))
 * from a service's `payment.pricingPlanIds` array.
 *
 *
 * If you remove all pricing plan IDs from `payment.pricingPlanIds` and the
 * service supports only payments by pricing plan, customers will no longer be
 * able to book the service, as they will have no payment options available.
 * @param serviceId - ID of the service to update.
 * @public
 * @requiredField serviceId
 * @permissionId BOOKINGS.SERVICES_PRICING_PLANS_REMOVE
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @fqn wix.bookings.services.v2.ServicesService.DisablePricingPlansForService
 */
export declare function disablePricingPlansForService(serviceId: string, options?: DisablePricingPlansForServiceOptions): Promise<DisablePricingPlansForServiceResponse & DisablePricingPlansForServiceResponseNonNullableFields>;
export interface DisablePricingPlansForServiceOptions {
    /**
     * IDs of the *pricing plans*
     * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/pricing-plans/plans/introduction) | [REST](https://dev.wix.com/api/rest/wix-pricing-plans/pricing-plans/plans/plan-object))
     * to remove from the service's `payment.pricingPlanIds` array.
     * @format GUID
     * @maxSize 75
     */
    pricingPlanIds?: string[];
}
/**
 * Sets a new active slug for the service.
 *
 *
 * The call fails if at least one of these conditions is met:
 * - The slug doesn't adheres to the supported format.
 * - Another service is currently using the slug.
 * - Another service has used the slug in the past.
 * @param serviceId - ID of the service for which to update the active slug.
 * @public
 * @requiredField serviceId
 * @permissionId BOOKINGS.SERVICES_CUSTOM_SLUGS_SET
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @fqn wix.bookings.services.v2.ServicesService.SetCustomSlug
 */
export declare function setCustomSlug(serviceId: string, options?: SetCustomSlugOptions): Promise<SetCustomSlugResponse & SetCustomSlugResponseNonNullableFields>;
export interface SetCustomSlugOptions {
    /**
     * Slug to set as the active service slug.
     * @maxLength 500
     */
    slug?: string;
}
/**
 * Checks whether a custom slug is validate for the service.
 *
 *
 * The checks include:
 * - The slug adheres to the supported format.
 * - No other service is currently using the slug.
 * - No other service has used the slug in the past.
 *
 * The call fails if at least one of the checks fails.
 * @param serviceId - IO of the service to check custom slug validity for.
 * @public
 * @requiredField serviceId
 * @permissionId BOOKINGS.SERVICES_CUSTOM_SLUGS_SET
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @fqn wix.bookings.services.v2.ServicesService.ValidateSlug
 */
export declare function validateSlug(serviceId: string, options?: ValidateSlugOptions): Promise<ValidateSlugResponse & ValidateSlugResponseNonNullableFields>;
export interface ValidateSlugOptions {
    /**
     * Custom slug to validate.
     * @maxLength 500
     */
    slug?: string;
}
/**
 * Clones a service.
 *
 *
 * ## Connected entities
 *
 * By default, not all entities connected to the service are cloned.
 *
 * ### Schedule
 *
 * Wix Bookings automatically creates a new active *schedule*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/calendar/schedules/introduction) | [REST](https://dev.wix.com/docs/rest/business-management/calendar/schedules-v3/introduction))
 * for the cloned service. If Wix Bookings can't create this schedule, the
 * Clone Service* call fails.
 *
 * - __For appointment-based services__: Future appointments aren't added to the
 * cloned service's schedule. Use the *Events API*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/calendar/events/introduction) | [REST](https://dev.wix.com/docs/rest/business-management/calendar/events-v3/introduction))
 * to add them as needed.
 * - __For classes and courses__: Future one-time events aren't added to the
 * cloned service's schedule, while future recurring events are added
 * asynchronously. The *Clone Service* call always succeeds, whether or not
 * recurring events are added.
 * If the response includes `RECURRING_EVENTS` in the `errors` array, it means the
 * cloned service doesn't have future recurring events, even though the original
 * service does. You can either delete the cloned service and try again or use
 * the *Events API*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/calendar/events/introduction) | [REST](https://dev.wix.com/docs/rest/business-management/calendar/events-v3/introduction))
 * to add missing events to the schedule.
 *
 * Wix Bookings never adds past events to the cloned service's schedule.
 *
 * ### Service options and variants
 *
 * If the original service has *variants*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/service-options-and-variants/introduction) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/service-options-and-variants/introduction)),
 * they're cloned asynchronously. The *Clone Service* call always succeeds,
 * regardless of whether variants were cloned.
 *
 * If the response includes `OPTIONS_AND_VARIANTS` in the `errors` array, the cloned
 * service doesn't have variants, even though the original service does. You can
 * delete the cloned service and call *Clone Service* again, or use the
 * _Service Options And Variants API_
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/service-options-and-variants/introduction) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/service-options-and-variants/introduction))
 * to add variants.
 *
 * ### Booking form
 *
 * The original service's booking form isn't cloned, whether it's
 * the default or a custom booking form.
 *
 * ### Pricing plans
 *
 * If the original service's accepts payments via *pricing plans*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/pricing-plans/plans/introduction) | [REST](https://dev.wix.com/docs/rest/business-solutions/pricing-plans/pricing-plans/plans/introduction)),
 * the cloned service's `payment.options.pricingPlan` is also set to `true`. To
 * accept specific pricing plans, call *Enable Pricing Plans For Service*
 * ([SDK](https://dev.wix.com/docs/sdk/backend-modules/bookings/services/enable-pricing-plans-for-service) | [REST](https://dev.wix.com/docs/rest/business-solutions/bookings/services/services-v2/enable-pricing-plans-for-service)),
 * after cloning the service. If the original service accepts only
 * pricing plan payments and you don't call *Enable Pricing Plans For Service*
 * after cloning the service, customers will be unable to book the service.
 * @param sourceServiceId - ID of the service to clone.
 * @public
 * @requiredField sourceServiceId
 * @permissionId BOOKINGS.SERVICES_CREATE
 * @permissionScope Manage Bookings
 * @permissionScopeId SCOPE.DC-BOOKINGS.MANAGE-BOOKINGS
 * @permissionScope Manage Bookings - all permissions
 * @permissionScopeId SCOPE.DC-BOOKINGS-MEGA.MANAGE-BOOKINGS
 * @applicableIdentity APP
 * @fqn wix.bookings.services.v2.ServicesService.CloneService
 */
export declare function cloneService(sourceServiceId: string): Promise<CloneServiceResponse & CloneServiceResponseNonNullableFields>;
export {};
